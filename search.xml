<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android网络编程</title>
      <link href="/liaojie.github.io/2021/11/20/android-wang-luo-bian-cheng/"/>
      <url>/liaojie.github.io/2021/11/20/android-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus</title>
      <link href="/liaojie.github.io/2021/11/17/quartus/"/>
      <url>/liaojie.github.io/2021/11/17/quartus/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>一、官网下载(可下载Windows,linux版本. 需注册):<br><a href="http://fpgasoftware.intel.com/?edition=lite">点击</a></p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/FPGAs%E4%B8%8B%E8%BD%BD%E4%B8%AD%E5%BF%83.png"></p><p>二、网盘下载<br>9.1版本下载地址：<br>链接：<a href="https://pan.baidu.com/s/1CE_TPvpIwLXiwXtNMdSJ-A">https://pan.baidu.com/s/1CE_TPvpIwLXiwXtNMdSJ-A</a><br>提取码：cpj9</p><p>13.0版本下载地址：<br>链接：<a href="https://pan.baidu.com/s/1f-0-3VclXivQFzFX83BeCg">https://pan.baidu.com/s/1f-0-3VclXivQFzFX83BeCg</a><br>提取码：d1yd</p><p>13.1版本下载地址：<br>链接：<a href="https://pan.baidu.com/s/1V4hcfuNhY0EQ7oGmnjlpVQ">https://pan.baidu.com/s/1V4hcfuNhY0EQ7oGmnjlpVQ</a><br>提取码：k39z </p><p>18.1lite版本下载地址：<br>链接：<a href="https://pan.baidu.com/s/1JMH75Y7l1cW8x_uveJ1pVg">https://pan.baidu.com/s/1JMH75Y7l1cW8x_uveJ1pVg</a><br>提取码：i83y</p><p>版本推荐:</p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%89%88%E6%9C%AC.jpg"></p><p>注意安装路径仅限字母数字下划线,不能出现中文等特殊字符,连空格都不行</p><h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><p>什么是EDA？</p><blockquote><p>EDA(Electronic Design Automation)技术作为现代电子设计技术的核心,依赖功能强大的计算机软件。它是一门综合性学科。利用EDA技术进行电子系统设计的最后目标,是完成专用集成电路ASIC或者印刷电路板PCB的设计和实现。</p></blockquote><p>硬件描述语言Verilog:</p><ul><li><p>硬件描述语言HDL是EDA技术的重要组成部分,目前常用的主要有<code>VHDL</code>、<code>HDL</code>等。</p></li><li><p>2001年,Verilog成为基层电路建模与设计中最流行的硬件描述语言。</p></li><li><p>Verilog部分语法参照C语言语法设立(但与C有本质区别)。在语言易读性、层次化和结构化设计方面表现了强大的生命力和应用潜力,大大简化硬件设计任务，且具有良好的适应性。</p></li></ul><p>常见HDL:</p><ul><li>另一重要的硬件描述语言是VHDL(超高速集成电路硬件描述语言)。</li><li>VHDL具有与具体硬件电路无关和设计平台无关的特性,并且具有良好的电路行为能力和系统描述能力。</li><li>Verilog与VHDL各有优缺点。</li><li>综合(Synthesis):把抽象的实体结合成单个统一的实体。将用行为和功能层次表达的电子系统转换为低层次的便于具体实现的模块组合装配的过程。【类比编写大型程序】</li><li>综合器:能自动将一种设计表述形式向另一种转换的软件,或者协助进行手工转换的软件。</li></ul><p>自顶向下设计技术<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B.jpg"></p><p>EDA优点<br>1.保证设计过程的正确性，大大降低设计成本，缩短设计周期。<br>2.有各类库的支持。<br>3.极大地简化设计文档的管理。<br>4.日益强大的逻辑设计仿真测试技术。<br>5.设计者拥有完全的自主权，再无受制于人之虞。<br>6.良好的可移植与可测试性，为系统开发提供了可靠的保证。<br>7.能将所有设计环节纳入统一的自顶向下的设计方案中。<br>8.EDA不但在整个设计流程上充分利用计算机的自动设计能力，而且在各个设计层次上利用计算机完成不同内容的仿真模拟，在系统板设计结束后仍可利用计算机对硬件系统进行完整的测试。</p><ul><li>手工设计有缺陷，EDA技术则不同。</li><li>设计输入、综合、适配、仿真、编程下载、硬件测试</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/EDA%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.jpg"></p><p>ASIC及其设计流程:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/ASIC.jpg"></p><p>常见EDA工具:</p><ul><li>设计输入编辑器</li><li>HDL综合器:Quartus2</li><li>仿真器:modelsim</li><li>适配器(布局布线器):Altium Designer</li><li>下载器:Quartus2</li><li>其他<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/Quartus2%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.jpg" alt="Quartus2设计流程"></li></ul><p>1.新建:<br>点击:File-&gt;New,选择Block Diagram/Schematic File,点击OK<br>2.点击连接库()或者左键空白处:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E8%BF%9E%E6%8E%A5%E5%BA%93.png"></p><p>找到libraries-&gt;primitives-&gt;logic,选择需要的芯片;libraries-&gt;primitives-&gt;pin,输入输出端.(megafunctions:包括一些参数可设置的功能模块.others:maxplus2(Quartus软件前身:74系列芯片).primitives:logic:xnor:同或门;xor:异或门;pin:引脚(bibdr:双向引脚);storage:触发器:dff:D触发器)<br>如果发现有虚的芯片在动,说明点击了重复模式,点击Esc取消即可<br>3.连线:鼠标左键点住拖动就行<br>4.双击名字可以更改<br>5.点击左上角保存:出现:Do you want to create a new project with this file?点击Yes,点击Next,<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/devicesettings.png"></p><p>根据要求设置就行,然后点击Next,最后Finish。<br>6.然后点击紫色三角进行编译(默认编译顶层设计实体,如果要编译其他设计文件需要将其置顶:点击Files下的文件,右键选择Set as Top_Level Entity)<br>7.点击File-&gt;New-&gt;University Program VWF,然后点击Edt-&gt;Insert-&gt;Insert Node or Bus(或者将鼠标放到左边Name下面的空白处,双击左键),点击Node Finder,点击List,全部移入(&gt;&gt;),点击OK<br>8.设置:选中,然后点击:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/clock.png"><br>设置相关属性:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/clocksetting.png"><br>点击功能仿真(只仿真功能)(它的右边为时序仿真:会考虑芯片的时延):<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E4%BB%BF%E7%9C%9F.png"><br>建议:采用时序仿真<br>点击Yes,最后保存,等待仿真结束.</p><p>放大:Ctrl+鼠标滚轮<br>移位:选中+拖拽</p><h2 id="Verilog语言编程基础"><a href="#Verilog语言编程基础" class="headerlink" title="Verilog语言编程基础"></a>Verilog语言编程基础</h2><p>1.模块语句及其表达式</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module 模块名 (模块端口名表);模块端口和模块功能描述.endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.端口语句、端口信号名和端口模式</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">input 端口名1,端口名2,...;output 端口名1,端口名2,...;inout 端口名1,端口名2,...;input[msb:lsb] 端口名1,端口名2,...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.逻辑操作符<br>4.连续赋值语句</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">assign 目标变量名 = 驱动表达式;assign [延时] 目标变量名 = 驱动表达式;eg:assign #6 R1 = A&amp;B;//延时6个时间单元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5.关键字<br>6.标识符<br>7.注释符号<br>8.规范的程序书写格式<br>9.文件取名和存盘</p><p>eg:半加器电路的Verilog描述</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module h_adder (A,B,SO,CO);input A,B;output SO,CO;assign SO = A^B;//^异或assign CO = A&amp;B;//与endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多路选择器:<br>1.reg型变量定义</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">reg 变量名1,变量名2,...;reg [msb:lsb] 变量名1,变量名2,...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.过程语句</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">always@ (敏感信号及敏感信号列表或表达式)包括块语句的各类顺序语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3.块语句begin_end</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">begin [:块名]语句1;语句2;...;语句n;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4.case条件语句</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">case (表达式)取值1 : begin 语句1;语句2;...;语句n;  end取值2 : begin 语句n+1;语句n+2;...;语句n+m;  end...default : begin 语句n+m+1;...;  endendcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.Verilog的四种逻辑状态:0,1,z,x<br>6.并位操作运算符</p><blockquote><p>{a1,b1,4{a2,b2}}={a1,b1,{a2,b2},{a2,b2},{a2,b2},{a2,b2}}={a1,b1,a2,b2,a2,b2,a2,b2,a2,b2}<br>7.Verilog的数字表达式</p></blockquote><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">&lt;位宽&gt;'&lt;进制&gt;&lt;数字&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>eg:4选1多路选择器</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">//case:module MUX41a(a,b,c,d,s1,s0,y);input a,b,c,d;input s1,s0;output y;reg y;always @ (a or b or c or d or s1 or s0)begin : MUX41//块语句开始case({s1,s0})2'b00 : y&lt;=a;2'b01 : y&lt;=b;2'b10 : y&lt;=c;2'b11 : y&lt;=d;default : y&lt;=a;endcaseendendmodule//assignmodule MUX41a(a,b,c,d,s1,s0,y);input a,b,c,d,s1,s0;output y;wire [1:0] SEL;//定义2元素位矢量SEL为网线型变量wirewire AT,BT,CT,DT;//定义中间变量,以作连线或信号节点assign SEL = {s1,s0};//对s1,s0进行并位操作,即SEL[1]=s1;SEL[0]=s0;assign AT = (SEL==2'D0);assign BT = (SEL==2'D1);assign CT = (SEL==2'D2);assign DT = (SEL==2'D3);assign y = (a &amp; AT)|(b &amp; BT)|(c &amp; CT)|(d &amp; DT);//4个逻辑信号相或endmodule//条件语句module MUX41a(A,B,C,D,S1,S0,Y);input A,B,C,D,S1,S0;output Y;reg [1:0] SEL;reg Y;always @ (A,B,C,D,SEL)begin : MUX41//块语句开始SEL = {S1,S0};if(SEL==0) Y=A;else if(SEL==1) Y=B;else if(SEL==2) Y=C;else            Y=D;endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.新建:File-&gt;New-&gt;Verilog HDL File-&gt;OK<br>2.保存:File-&gt;Save,文件名需与模块名一致,其他按之前保存步骤<br>设置要更改为:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/EP3C40Q240C8.png"><br>选择Cyclone 3 -&gt; EP3C40Q240C8,最后点击紫色三角进行编译</p><p>3.点击File-&gt;New-&gt;University Program VWF,然后点击Edt-&gt;Insert-&gt;Insert Node or Bus,点击Node Finder,点击3个点(…),选中MUX41a,按下OK,然后点击List,然后点击 &gt;&gt; ,点击OK就行了</p><p>4.然后设置终止时间:Edt-&gt;Set End Time (10us)<br>5.点击:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/clock.png"><br>设置相关属性:<br>a: period:90ns;Duty Cycle:50%(b:200ns,70%;c:400ns,20%;d:780ns,85%;s0:4us,50%;s1:2us,50%),,点击OK;<br>6.然后点击仿真,出现叫你保存的页面:点击Yes保存即可</p><p>1.按位逻辑操作符<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.jpg"><br>2.等式操作符<br>等于(==)不等于(!=)全等(===)不全等(!==)<br>3.wire定义网线型变量</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">wire 变量名1,变量名2,...;wire [msb:lsb] 变量名1,变量名2,...;eg:wire a1,a2;assign Y = a1^a2;上面俩个式子等价于wire Y = a1^a2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件语句<br>1.if条件语句</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">if(s) Y=A; else Y=B;if(s) Y=A; else begin Y=B; Z=C; Q=1'b0; end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.过程赋值语句<br>(1)阻塞式赋值(=)用于assign语句<br>(2)非阻塞式赋值(&lt;=)块语句 </p><p>3.数据类型表示方式</p><h2 id="时序电路的Verilog表达"><a href="#时序电路的Verilog表达" class="headerlink" title="时序电路的Verilog表达"></a>时序电路的Verilog表达</h2><p>eg:D触发器</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module DFF1(CLK,D,Q);output Q;input CLK,D;reg Q;always @ (posedge CLK)//posedge检测上升沿;negedge检测下降沿Q &lt;= D;//将Q更新为D的状态endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用UDP表述D触发器</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">primitive EDGE_UDP(Q,D, CLK,RST) ;input D,CLK, RST; output Q;reg Q; table // D CLK RST:9 : Q+ 0 (01) 0 :? : 0; 1 (01) 0 :? : 1;      ? (1?) 0 :? : -;  ? (?0) 0 :? : -; 1  0   1 :? : 0;  1  1   11:? : 0; 0  0   1 :? : 0; 0  1   1 :? : 0;endtableendprimitive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module DFF_UDP (Q,D,CLK, RST) ;input D,CLK, RST;output Q;EDGE_UDP U1(Q,D, CLK,RST); Endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%90%AB%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8DD%E8%A7%A6%E5%8F%91%E5%99%A8.jpg"></p><h3 id="含异步复位和时钟使能的D触发器及其Verilog表述"><a href="#含异步复位和时钟使能的D触发器及其Verilog表述" class="headerlink" title="含异步复位和时钟使能的D触发器及其Verilog表述"></a>含异步复位和时钟使能的D触发器及其Verilog表述</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BDD%E8%A7%A6%E5%8F%91%E5%99%A8.jpg"><br>RST:异步复位端;EN:时钟使能端</p><h3 id="含同步复位-同步清零-控制的D触发器及其Verilog表述"><a href="#含同步复位-同步清零-控制的D触发器及其Verilog表述" class="headerlink" title="含同步复位(同步清零)控制的D触发器及其Verilog表述"></a>含同步复位(同步清零)控制的D触发器及其Verilog表述</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8DD%E8%A7%A6%E5%8F%91%E5%99%A8.jpg"></p><h3 id="基本锁存器及其Verilog描述"><a href="#基本锁存器及其Verilog描述" class="headerlink" title="基本锁存器及其Verilog描述"></a>基本锁存器及其Verilog描述</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%9F%BA%E6%9C%AC%E9%94%81%E5%AD%98%E5%99%A8.jpg"></p><h3 id="含清0控制的锁存器及其Verilog表述"><a href="#含清0控制的锁存器及其Verilog表述" class="headerlink" title="含清0控制的锁存器及其Verilog表述"></a>含清0控制的锁存器及其Verilog表述</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E6%B8%850%E6%8E%A7%E5%88%B6%E9%94%81%E5%AD%98%E5%99%A8.jpg"></p><h3 id="异步时序电路的Verilog表述特点"><a href="#异步时序电路的Verilog表述特点" class="headerlink" title="异步时序电路的Verilog表述特点"></a>异步时序电路的Verilog表述特点</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%BC%82%E6%AD%A5%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF.jpg"></p><h3 id="时钟过程表述的特点和规律"><a href="#时钟过程表述的特点和规律" class="headerlink" title="时钟过程表述的特点和规律"></a>时钟过程表述的特点和规律</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E6%97%B6%E9%92%9F%E8%BF%87%E7%A8%8B.jpg"><br>always @ (posedge CLK or DIN):不允许在敏感信号表中定义除了异步时序控制信号以外的信号</p><h3 id="电路原理图设计流程"><a href="#电路原理图设计流程" class="headerlink" title="电路原理图设计流程"></a>电路原理图设计流程</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%861.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%862.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%863.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%864.jpg"></p><h3 id="封装设计"><a href="#封装设计" class="headerlink" title="封装设计"></a>封装设计</h3><p>在已经设计好锁存器的基础上:<br>File-&gt;Create/Update-&gt;Create Symbol Files for Current File<br>这时新建一个工程:File-&gt;New-&gt;Block Diagram/Schematic File;然后保存;保存过后点击File-&gt;New Project Wizard;<br>选择新建的项目:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/LOCK02.png"><br>添加文件进去:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/LOCK02file.png"><br>还要将之前的文件添加进去:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/LOCKfile.png"></p><p>然后选择芯片:Cyclone 3-&gt;EP3C40Q240C8(实验室使用:EP3C16Q240C8);点击Next,一直到Finish.<br>右键:选择Insert-&gt;Symbol<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/InsertSymbol.png"></p><p>然后点击左下角3个点(…);选择LOCK.bsf文件(原理图设计文件);即可以插入了,添加输入输出端,编译,然后进行仿真即可.</p><h2 id="Verilog加法器设计"><a href="#Verilog加法器设计" class="headerlink" title="Verilog加法器设计"></a>Verilog加法器设计</h2><h3 id="全加器设计"><a href="#全加器设计" class="headerlink" title="全加器设计"></a>全加器设计</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%85%A8%E5%8A%A0%E5%99%A8.jpg"></p><p>3.Verilog例化语句及其用法</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">&lt;模块元件名&gt; &lt;例化元件名&gt; (.例化元件端口 (例化元件外接端口名),...);h_adder U2(.A(net1),.SO(sum),.B(cin),.CO(net3));//端口名关联法h_adder U2(.B(cin),.CO(net3),.A(net1),.S0(sum));//端口名关联法h_adder U1(ain,bin,net1,net2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="半加器的UDP结构建模描述方法"><a href="#半加器的UDP结构建模描述方法" class="headerlink" title="半加器的UDP结构建模描述方法"></a>半加器的UDP结构建模描述方法</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%8D%8A%E5%8A%A0%E5%99%A8.jpg"></p><h3 id="利用UDP元件设计多路选择器"><a href="#利用UDP元件设计多路选择器" class="headerlink" title="利用UDP元件设计多路选择器"></a>利用UDP元件设计多路选择器</h3><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">primitive MUX41_UDP(Y,D3,D2,D1,D0,S1,S0) ;input D3,D2,D1,D0,S1,S0; output Y;table // D3 D2 D1 D0 S1 S0 : Y ?  ?  ?  1  0  0  : 1; ?  ?  ?  0  0  0  : 0;      ?  ?  1  ?  0  1  : 1;  ?  ?  0  ?  0  1  : 0; ?  1  ?  ?  1  0  : 1; ?  0  ?  ?  1  0  : 0; 1  ?  ?  ?  1  1  : 1; 0  ?  ?  ?  1  1  : 0;endtableendprimitive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module MUX41UDP (D,S,DOUT);input [3:0] D;input [1:0] S;output DOUT;MUX41_UDP (DOUT,D[3],D[2],D[1],D[0],S[1],S[0]);endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8位加法器设计及其算术操作符应用"><a href="#8位加法器设计及其算术操作符应用" class="headerlink" title="8位加法器设计及其算术操作符应用"></a>8位加法器设计及其算术操作符应用</h3><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/8%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Quartus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>launchMode</title>
      <link href="/liaojie.github.io/2021/11/14/launchmode/"/>
      <url>/liaojie.github.io/2021/11/14/launchmode/</url>
      
        <content type="html"><![CDATA[<p>activity 的 android:launchMode</p><ul><li>standard</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ul><p>startActivity()时的Intent.FLAG_ACTIVITY_XXX</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_SINGLE_TOP</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_MULTIPLE_TASK</li><li>FLAG_ACTIVITY_NEW_DOCUMENT</li><li>FLAG_ACTIVITY_REORDER_TO_FRONT</li><li>FLAG_ACTIVITY_PREVIOUS_IS_TOP</li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li><li>FLAG_ACTIVITY_RETAIN_IN_RECENTS</li><li>FLAG_ACTIVITY_TASK_ON_HOME</li></ul><p>activity 的 android:taskAffinity<br>activity 的 android:allowTaskReparenting<br>activity 的 android:clearTaskOnLaunch<br>Activity的回退栈(Task)<br>Android的最近任务列表(Recents/overview)切换<br>启动器(桌面)的App图标点击</p><p>当我们在桌面上点击App图标时,App的默认Activity(MAIN+LAUNCHER intent-filter)会被启动,并且这个Activity会被放进系统刚创建的一个 Task 里,我们通过最近任务键可以在做个App之间进行切换(其实更精确的说,我们是在多个Task之间切换,每个Task都有一个自己的回退栈,它按顺序记录了用户打开的每个Activity,这样就可以在用户按返回键的时候按照倒序来依次关闭这些Activity,当回退栈里最后一个Activity被关闭,这个Task生命也就结束了,但它并不会在最近列表里消失,系统依然会保留这个Task的一个残影给用户,目的是让用户可以方便地切回去,只是这时候的切回去其实是对Appd的重新启动,因为原先的Task已经不存在了,在最近任务里看到的Task未必是”活着”的).Activity是一个可以跨线程跨应用的组件,当你在 A App里打开 B App的Activity的时候,这个Activity会被直接放进 A 的Task里,而对于 B 的Task是没有任何影响的.</p><p>Android默认规则:</p><blockquote><p>在不同Task中打开同一个Activity,Activity会被创建多个实例,分别放进每一个Task</p></blockquote><p>在Manifest.xml里 activity 中:</p><h3 id="android-launchMode-”singleTask”"><a href="#android-launchMode-”singleTask”" class="headerlink" title="android:launchMode=”singleTask”"></a>android:launchMode=”singleTask”</h3><blockquote><p>singleTask可以让Activity被别的App启动时不会进入启动它的Task里,而是会在属于他自己的Task里创建,放在自己的栈顶,然后把这整个Task一起拿过来压在启动它的Task的上面.这种逻辑可以保证不管是从哪个App启动,被标记为singleTask的Activity总会被放在自己的Task里.(这种方式打开的Activity的入场动画是应用间切换的动画,而不是普通的Activity的入场动画)</p></blockquote><blockquote><p>如果启动时这个Task栈里已经有了这个Activity,那么就不再创建新的对象,而是直接复用这个已有的对象.同时,因为Activity没有被重建,系统也就不会调用它的onCreate()方法,而是调用它的onNewIntent()方法,让他可以从Intent里解析数据来刷新界面.另外在调用onNewIntent()之前如果这个Activity上面压着有其他Activity,系统也会把这些Activity全部清掉,来确保我们的Activity出现在栈顶</p></blockquote><p>Task由前台进入后台<br>1.按Home键回到桌面<br>2.按最近任务键(方块键)查看最近任务</p><ul><li>注意:前台Task在最近任务列表显示出来的时候就已经进入后台,而不是在切换到其他应用之后</li></ul><h3 id="android-allowTaskReparenting-”true”"><a href="#android-allowTaskReparenting-”true”" class="headerlink" title="android:allowTaskReparenting=”true”"></a>android:allowTaskReparenting=”true”</h3><p>简单可理解为:你打开我的时候,我在你的Task里,而稍后我也可以回到我原本所属的Task里.<br>与singleTask相比,因为Activity刚被打开的时候并未发生Task切换,所以也没有Task切换的夸张的入场动画,并且因为只有一个Task,所以也不会像singleTask那样被切断自己的回退路径<br>但是从Android 9之后这个属性失效了.但在Android 11上又可以使用了.</p><h3 id="android-launchMode-”singleInstance”"><a href="#android-launchMode-”singleInstance”" class="headerlink" title="android:launchMode=”singleInstance”"></a>android:launchMode=”singleInstance”</h3><p>singleInstance的行为逻辑和singleTask是基本一致的,只是它多了一个更严格的限制:他要求这个Activity所在的Task里只有一个Activity</p><p>taskAffinity(相似,有关联):默认为包名</p><ul><li>默认情况下,Activity会直接进入当前Task</li><li>但对于设置了launchMode=”singleTask”的Activity,系统会比对Activity和当前的Task的taskAffinity是否相同<ul><li>如果相同,依然正常入栈</li><li>如果不同,Activity会去寻找和他的taskAffinity相同的Task后入栈<ul><li>或者如果找不到,系统就会为他创建一个新的Task</li></ul></li></ul></li></ul><p>taskAffinity和最近任务列表<br>最近任务列表会列出现有的Task(任务)</p><ul><li>但他们的taskAffinity需要不一样</li><li>当多个Task具有相同taskAffinity的时候,最近任务列表里只会显示最新展示过的那一个</li></ul><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><ul><li>和默认的(即standard)几乎一样,启动时不考虑taskAffinity</li><li>唯一的区别是singleTop会重用栈顶的Activity</li></ul><h3 id="实战的通常选择"><a href="#实战的通常选择" class="headerlink" title="实战的通常选择"></a>实战的通常选择</h3><ul><li>默认(standard)和singleTop:多用于App内部</li><li>singleInstance:多用于开放给外部App来共享使用</li><li>singleTask:内部交互和外部交互都能用得上</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning</title>
      <link href="/liaojie.github.io/2021/11/14/machinelearning/"/>
      <url>/liaojie.github.io/2021/11/14/machinelearning/</url>
      
        <content type="html"><![CDATA[<p>Arthur Samuel对机器学习的定义:</p><blockquote><p>在没有明确设置的情况下使计算机具有学习能力的研究领域<br>Tom Mitchell对机器学习的定义:<br>计算机程序从经验E中学习解决某一任务T进行某一性能度量P通过P测定在T上的表现因经验E而提高</p></blockquote><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是指:利用一组已知类别的样本调整分类器的参数,使其达到所要求性能的过程,也称为监督训练或有教师学习。<br>监督学习是从标记的训练数据来推断一个功能的机器学习任务.训练数据包括一套训练示例.在监督学习中,每个实例都是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成.监督学习算法是分析该训练数据,并产生一个推断的功能,其可以用于映射出新的实例.一个最佳的方案将允许该算法来正确地决定那些看不见的实例的类标签.这就要求学习算法是在一种”合理”的方式从一种从训练数据到看不见的情况下形成.</p><blockquote><p>eg:判断良性和恶性肿瘤的概率</p></blockquote><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习算法可能判定该数据集包含俩个不同的簇(聚类算法)</p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.jpg" alt="无监督学习概述图"></p><p>现实生活中常常会有这样的问题:缺乏足够的先验知识,因此难以人工标注类别或进行人工类别标注的成本太高.很自然地,我们希望计算机能代我们完成这些工作,或至少提供一些帮助.根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题,称之为无监督学习.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习之SpringCloud</title>
      <link href="/liaojie.github.io/2021/11/12/springcloud/"/>
      <url>/liaojie.github.io/2021/11/12/springcloud/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android启动页</title>
      <link href="/liaojie.github.io/2021/11/10/android-qi-dong-ye/"/>
      <url>/liaojie.github.io/2021/11/10/android-qi-dong-ye/</url>
      
        <content type="html"><![CDATA[<p>Android中几乎所有app都有启动页这一基本功能,但是用途都不相同。<br>有的app的启动页用于加载广告,有的启动页用于加载后台,一旦后台数据加载好了才把启动页去了,不过想来很多app是两者兼顾的。<br>需求:</p><ul><li>展示 logo 页面3秒</li><li>服务端可以控制是否播放广告</li><li>服务端可以控制播放广告的秒数</li><li>服务端可以控制广告的内容（图片）和广告详情页面的链接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/splash.png"></p><p>注意:从服务端请求数据是在展示 3 秒启动页的时候获取的</p><h3 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h3><p>启动包括冷启动和热启动:</p><ul><li>冷启动：是指进程从无到有的过程。因为要进行页面初始化,所以相对其他两个启动方式,消耗的时间是相对比较多的。</li><li>热启动：是指之前的进程还在,在之前进程的基础上创建 Activity 的过程,耗时相对少一点。<br>　　我们可以通过 Activity 的 theme 来修改这个白屏所显示的界面。根据上面的需求,我们需要显示3秒 logo 的页面。那么我们干脆将我们的logo设置为背景图就行了。</li></ul><p>新建一个activity为SplashActivity,其对应布局文件为activity_splash.xml<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/newEmptyActivity.png"><br>并在AndroidManifest.xml中将SplashActivity设置为主入口:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;activity android:name=".MainActivity"&gt;&lt;/activity&gt;&lt;activity android:name=".SplashActivity"    android:theme="@style/Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;    &lt;intent-filter&gt;        &lt;action android:name="android.intent.action.MAIN" /&gt;        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在values中的themes.xml中添加:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/themes.png"></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;style name="Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;//取消Actionbar    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;    &lt;item name="android:windowFullscreen"&gt;true&lt;/item&gt;//设置全屏    &lt;item name="android:windowBackground"&gt;@drawable/splash&lt;/item&gt;//设置背景图片&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在AndroidManifest.xml中需要主题的Activity添加:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.splashactivity"&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.SplashActivity"&gt;        &lt;activity android:name=".MainActivity"&gt;        &lt;/activity&gt;        &lt;activity android:name=".SplashActivity"            android:theme="@style/Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SplashActivity:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.WindowManager;public class SplashActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);//隐藏状态栏        //getSupportActionBar().hide();//隐藏标题栏        setContentView(R.layout.activity_splash);        Thread myThread = new Thread() {//创建子线程            @Override            public void run() {                try {                    sleep(5000);//使程序休眠五秒                    Intent intent = new Intent(getApplicationContext(), MainActivity.class);//启动MainActivity                    startActivity(intent);                    finish();//关闭当前活动                } catch (Exception e) {                    e.printStackTrace();                }            }        };        myThread.start();//启动线程    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="广告页"><a href="#广告页" class="headerlink" title="广告页"></a>广告页</h3><p>广告页我尝试过两种方式：<br>1.glide 加载<br>2.通过下载文件，然后再加载<br>如果使用glide加载广告图片,如果网络比较差,会存在广告页面空白的情况,因为使用 glide 无法判断在 3 秒展示 logo 的页面是否加载好了广告图片。这给用户的体验是比较差的,也是不太友好的,因为用户在空白界面拜拜等待了 3 秒。所以后面使用了将广告图片下载到本地的方法。</p><h3 id="动画开屏"><a href="#动画开屏" class="headerlink" title="动画开屏"></a>动画开屏</h3><p>新建EmptyActivity–AnimatedActivity<br>在build.gradle(:app)的dependencies中添加glide依赖:</p><blockquote><p>implementation ‘com.github.bumptech.glide:glide:4.12.0’<br>然后点击sync now</p></blockquote><p>新建动画所需的VectorAsset:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/VectorAsset.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/assetSet.png"></p><p>然后点击next,最后点击finish<br><a href="https://www.online-convert.com/">转换svg的网站</a></p><p>或者去<a href="https://www.iconfont.cn/">iconfont</a>查找</p><h4 id="activity-animated"><a href="#activity-animated" class="headerlink" title="activity_animated"></a>activity_animated</h4><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".AnimatedActivity"&gt;    &lt;ImageView        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:id="@+id/iv_top"        android:adjustViewBounds="true"        android:src="@drawable/ic_top_vector"/&gt;    &lt;LinearLayout        android:layout_width="match_parent"        android:layout_height="match_parent"        android:orientation="vertical"        android:gravity="center"        android:padding="16dp"&gt;        &lt;ImageView            android:layout_width="match_parent"            android:layout_height="180dp"            android:id="@+id/iv_heart"            android:adjustViewBounds="true"            android:src="@drawable/ic_heart"/&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:id="@+id/text_view"            android:textSize="48sp"            android:textStyle="bold"            android:textColor="#D75A4A"            android:layout_marginTop="8dp"/&gt;        &lt;ImageView            android:layout_width="match_parent"            android:layout_height="wrap_content"            android:id="@+id/iv_beat"            android:adjustViewBounds="true"/&gt;    &lt;/LinearLayout&gt;    &lt;ImageView        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:id="@+id/iv_bottom"        android:adjustViewBounds="true"        android:layout_alignParentBottom="true"        android:src="@drawable/ic_bottom_vector"/&gt;&lt;/RelativeLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建ResourceFile<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/resourceFile.png"></p><p>设置:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/resourceFileSet.png"></p><h4 id="top-wave-xml"><a href="#top-wave-xml" class="headerlink" title="top_wave.xml"></a>top_wave.xml</h4><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;translate        android:fromXDelta="-50%"        android:fromYDelta="0%"        android:duration="2500"/&gt;    &lt;alpha        android:fromAlpha="1.0"        android:toAlpha="0.5"        android:duration="2500"/&gt;&lt;/set&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="bottom-wave-xml"><a href="#bottom-wave-xml" class="headerlink" title="bottom_wave.xml"></a>bottom_wave.xml</h4><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;translate        android:duration="2500"        android:fromXDelta="50%"        android:fromYDelta="0%" /&gt;    &lt;alpha        android:duration="2500"        android:fromAlpha="1.0"        android:toAlpha="0.5" /&gt;&lt;/set&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="AnimatedActivity"><a href="#AnimatedActivity" class="headerlink" title="AnimatedActivity"></a>AnimatedActivity</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.animation.ObjectAnimator;import android.animation.PropertyValuesHolder;import android.animation.ValueAnimator;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.view.WindowManager;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.widget.ImageView;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;import com.bumptech.glide.Glide;import com.bumptech.glide.load.engine.DiskCacheStrategy;public class AnimatedActivity extends AppCompatActivity {    //Initialize variable    ImageView ivTop, ivHeart, ivBeat, ivBottom;    TextView textView;    CharSequence charSequence;    int index;    long delay = 200;    Handler mHandler = new Handler();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_animated);        //Assign variable        ivTop = findViewById(R.id.iv_top);        ivHeart = findViewById(R.id.iv_heart);        ivBottom = findViewById(R.id.iv_bottom);        textView = findViewById(R.id.text_view);        //set full screen        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN                , WindowManager.LayoutParams.FLAG_FULLSCREEN);        //Initialize top animation        Animation animation1 = AnimationUtils.loadAnimation(this                , R.anim.top_wave);        //start top animation        ivTop.setAnimation(animation1);        //Initialize object animation        ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(                ivHeart,                PropertyValuesHolder.ofFloat("scaleX", 1.2f),                PropertyValuesHolder.ofFloat("scaleY", 1.2f)        );        //Set duration        objectAnimator.setDuration(500);        //Set repeat count        objectAnimator.setRepeatCount(ValueAnimator.INFINITE);        //Set repeat mode        objectAnimator.setRepeatMode(ValueAnimator.REVERSE);        //Start animator        objectAnimator.start();        //Set animate text        animateText("Heart Beat");        //Load GIF        Glide.with(this).load("https://firebasestorage.googleapis.com/v0/b/demoapp-ae96a.appspot.com/o/heart_beat.gif?alt=media&amp;token=b21dddd8-782c-457c-babd-f2e922ba172b")                .diskCacheStrategy(DiskCacheStrategy.ALL)                .into(ivBottom);        //Initialize bottom animation        Animation animation2 = AnimationUtils.loadAnimation(this                , R.anim.bottom_wave);        //start bottom animation        ivBottom.setAnimation(animation2);        //Initialize handler        new Handler().postDelayed(new Runnable() {            @Override            public void run() {                //Redirect to main activity                startActivity(new Intent(AnimatedActivity.this                        , MainActivity.class)                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK));                //Finish activity                finish();            }        }, 4000);    }    Runnable mRunnable = new Runnable() {        @Override        public void run() {            //When runnable is run            //Set text            textView.setText(charSequence.subSequence(0, index++));            //Check condition            if (index &lt;= charSequence.length()) {                //When index is equal to text length                //Run handler                mHandler.postDelayed(mRunnable, delay);            }        }    };    //Create animated text method    public void animateText(CharSequence cs) {        //Set text        charSequence = cs;        //Clear index        index = 0;        //Clear text        textView.setText("");        //Remove call back        mHandler.removeCallbacks(mRunnable);        //Run handler        mHandler.postDelayed(mRunnable, delay);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在AndroidManifest.xml中添加权限:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不要忘记将AnimatedActivity设置为主入口.</p><p><a href="https://github.com/liaojie1314/SplashActivity.git">完整项目</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之服务</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/</url>
      
        <content type="html"><![CDATA[<p>Service是Android 系统中的四大组件之一,它跟Activity的级别差不多,但不能页面显示只能后台运行,并且可以和其他组件进行交互.service可以在很多场合的应用中使用,比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放,比如检测SD卡上文件的变化,再或者在后台记录你地理信息位置的改变等等,总之服务总是藏在后台的.例如,一个service可能处理网络事物、播放音乐、执行文件I/O,或与一个内容提供者交互,所有这些都在后台进行.<br>我们一定要知道的是这里Service的后台运行并不是子线程.Service的运行是在主线程中进行的,只是它没有界面显示而已,它的耗时操作同样需要开启子线程,否者会跟Activity一样出现ANR(application not response–程序没有响应).</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之广播</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/</url>
      
        <content type="html"><![CDATA[<p>在Android中,Broadcast是一种广泛运用的在应用程序之间传输信息的机制.我们拿广播电台来做个比方.我们平常使用收音机收音是这样的:许许多多不同的广播电台通过特定的频率来发送他们的内容,而我们用户只需要将频率调成和广播电台的一样就可以收听他们的内容了.Android中的广播机制就和这个是差不多的道理.</p><p>1.电台发送的内容是语音,而在Android中我们要发送的广播内容是一个Intent.这个Intent中可以携带我们要传送的数据.</p><p>2.电台通过大功率的发射器发送内容，而在Android中则是通过sendBroadcast这个方法来发送。       </p><p>3.用户通过调整到具体的电台频率接受电台的内容.而在Android中要接受广播中的内容则是通过注册一个BroadCastReceiver来接收的.只有发送广播的action和接收广播的action相同,接受者才能接受这个广播. </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之Activity</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/</url>
      
        <content type="html"><![CDATA[<p>Activity是Android的四大组件之一.是用户操作的可视化界面,它为用户提供了一个完成操作指令的窗口.当我们创建完毕Activity之后,需要调用setContentView()方法来完成界面的显示以此来为用户提供交互的入口.在Android App中只要能看见的几乎都要依托于Activity,所以Activity是在开发中使用最频繁的一种组件.</p><h5 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h5><p>在Android中会维持一个Activity Stack(Activity栈),当一个新的Activity创建时,它就会放到栈顶,这个Activity就处于运行状态.当再有一个新的Activity被创建后会重新压人栈顶,而之前的Activity则会在这个新的Activity底下.而之前的Activity就会进入后台.<br>一个Activity实质上有四种状态：</p><p>1.运行中(Running/Active):这时Activity位于栈顶,是可见的,并且可以用户交互.<br>2.暂停(Paused):当Activity失去焦点,不能跟用户交互了,但依然可见,就处于暂停状态.当一个新的非全屏的Activity或者一个透明的Activity放置在栈顶,Activity就处于暂停状态,这个时候Activity的各种数据还被保持着.只有在系统内存在极低的状态下,系统才会自动的去销毁Activity.<br>3.停止(Stoped):当一个Activity被另一个Activity完全覆盖,或者点击HOME键退入了后台,这时候Activity处于停止状态.这里有些是跟暂停状态相似的,这个时候Activity的各种数据还被保持着,当系统的别的地方需要用到内容时,系统会自动的去销毁Activity.<br>4.销毁(Detroyed):当我们点击返回键或者系统在内存不够用的情况下就会把Activity从栈里移除销毁,被系统回去.这时候,Activity处于销毁状态.</p><p><img src="/liaojie.github.io/medias/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity的生命周期"></p><p>onCreate:当Activity第一次被创建时调用.是生命周期开始的第一个方法.在这里我们可以做一些初始化的操作,比如:调用setContentView()方法去加载界面,绑定布局里的一些控件,初始化一些Activity需要用到的数据.之后会调用onStart方法.</p><p>onStart:当Activity正在变为可见时调用.这个时候Activity已经可见了,但是还没有出现在前台还不能跟用户交互.可以简单理解为Actvity已经可见但是还没有出现在前台.之后会调用onResume.</p><p>onResume:当Activity可以跟用户交互时调用.这个时候这个Activity位于栈的顶部,跟onStart相比,它们都是表示Activity已经可见,但是onStart调用时Activity还在后台,而调用onResume时,Activity已经进入了前台,可以跟用户交互了.之后会调用 onPause.</p><p>onPause:当Activity暂停时调用这个方法,在这里我们可以用来保存数据,关闭动画和其它比较耗费CPU的操作,但是在这里做的操作绝对不能耗时,因为如果当前Activity要启动一个新的Activity,这个新的Activity会在当前Activity执行完毕onPause之后才能进入可见状态.这个方法之后一般会调用的方法有onStop或者onResume.</p><p>onStop:当Activity进入后台,并且不会被用户看到时调用.当别的Activity出现在前台时,或者Activity会被销毁时,调用此方法.在这个方法调用之后,系统可能会在内存不够的情况下回收Activity.在这个方法之后一般会调用onRestart或者onDestroy.</p><p>onDestroy:这个方法是Activity生命周期中调用的最后一个方法.它会在Activity被销毁之前调用,Activity销毁原因一般是我们调用Activity的finish方法手动销毁,另一个就是系统在内存紧张的情况下去销毁Activity,以用来节省空间.我们可以通过方法 isFinishing 来判断Activity是否正在被销毁.</p><p>onRestart:这个方法是在Activity处于停止状态后,又回到可视状态时调用.之后会调用onResume.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之内容提供者</title>
      <link href="/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/"/>
      <url>/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/</url>
      
        <content type="html"><![CDATA[<p>ContentProvider(内容提供者)作为Android中的四大组件之一,但是在一般的开发中,使用比较少.ContentProvider为不同的软件之间数据共享提供统一的接口.而且ContentProvider是以类似数据库中表的方式将数据暴露,也就是说ContentProvider就像一个”数据库”.那么外界获取其提供的数据,也就应该与从数据库中获取数据的操作基本一样,只不过是采用URI来表示外界需要访问的”数据库”.至于如何从URI中识别出外界需要的是哪个”数据库”,这就是Android底层需要做的事情了.也就是说,如果我们想让其他的应用使用我们自己程序内的数据,就可以使用ContentProvider定义一个对外开放的接口,从而使得其他的应用可以使用我们自己应用中的文件、数据库内存储的信息.当然,自己开发的应用需要给其他应用共享信息的需求可能比较少见,但是在Android系统中,很多数据如:联系人信息、短信信息、图片库、音频库等,这些信息在开发中还是经常用到的,这些信息谷歌工程师已经帮我们封装好了,我们可以使用谷歌给我的Uri去直接访问这些数据.所以对于ContentProvider我们还是需要认真的学习的,在遇到获取联系人信息,图片库,音视频库等需求的时候,才能更好的实现功能.</p><h5 id="内容提供者应用场景"><a href="#内容提供者应用场景" class="headerlink" title="内容提供者应用场景"></a>内容提供者应用场景</h5><p>1.向日历里插入提醒事件</p><blockquote><p>举个例子,比如说你是淘宝app,里面有一个开团的活动,用户需要添加开团提醒,你就需要向闹钟或者日历里添加一个事件.</p></blockquote><p>2.微信/QQ/支付宝获取通讯录里的联系人</p><blockquote><p>微信,QQ,支付宝这些应用,获取通讯录里的联系人,然后向你推荐好友,就是通过内容提供者获取到通讯录信息的.</p></blockquote><p>3.媒体库</p><blockquote><p>Android的媒体库,也是一个内容提供者.比如说你微信要发朋友圈,或者你的应用要上传图片,获取系统里的图片内容视频内容,可以通过内容提供者来获取.</p></blockquote><p>4.广告精准推送</p><blockquote><p>你浏览过什么东西,搜索过什么关键字.你去上淘宝、头条之类的就会给你推荐,它们之间也可以通过内容提供者来提供数据,只要双方把利益问题处理好就行.</p></blockquote><p>5.短信备份</p><blockquote><p>短信也有内容提供者,而第三方备份工具则是通过内容提供者去获取短信内容的.</p></blockquote><h2 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h2><p>继承ContentProvider,然后实现里面是方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//创建@Overridepublic boolean onCreate() {    return false;}//查询@Nullable@Overridepublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {    return null;}@Nullable@Overridepublic String getType(@NonNull Uri uri) {    return null;}@Nullable@Overridepublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {    return null;}@Overridepublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {    return 0;}@Overridepublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Manifest中注册</p><pre class="line-numbers language-AndroidManifest" data-language="AndroidManifest"><code class="language-AndroidManifest">&lt;providerandroid:exported="true"    android:name=".provider.UserProvider"    android:authorities="com.example.contentprovider"/&gt;//一般填写包名,可添加多个,用";"隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将数据库暴露出去,给别人操作</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private UserDatabaseHelper mUserDatabaseHelper = null;//校验URI的工具类,定义为静态,因为我们需要添加一些规则//UriMatcher.NO_MATCH 当不匹配的时候的一个返回值private static UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);//弱匹配之后的返回值private static UriMatcher sUriMatcher=new UriMatcher(UriMatcher.NO_MATCH);//添加规则static {    sUriMatcher.addURI("com.example.contentprovider",null,USER_MATCH_CODE);//第二个参数为path}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在onCreate是创建DatabaseHelper</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">mUserDatabaseHelper=new UserDatabaseHelper(getContext());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询-query"><a href="#查询-query" class="headerlink" title="查询(query):"></a>查询(query):</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int result = sUriMatcher.match(uri);if (result == USER_MATCH_CODE) {    //匹配规则    SQLiteDatabase db = mUserDatabaseHelper.getReadableDatabase();    Cursor cursor = db.query(Constants.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);    return cursor;} else {    //不匹配规则    throw new IllegalArgumentException("参数错误");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:MainActivity相关为新创建的</p><p>activity_main.xml中加入获取数据的按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:id="@+id/query_btn"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="获取用户数据"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    android:onClick="getRemoteUser"    app:layout_constraintTop_toTopOf="parent"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainActivity中加入点击事件:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void getRemoteUser(View view) {    ContentResolver contentResolver = getContentResolver();    //path 为空content://com.example.contentprovider/path    Uri uri = Uri.parse("content://com.example.contentprovider");    // "http://":http协议;"tel://":电话    //query(uri,projection,selection,selectionArgs,sortOrder);    Cursor cursor = contentResolver.query(uri, null, null, null, null);//全为null,无条件查询String[] columnNames = cursor.getColumnNames();for (String columnName : columnNames) {    Log.d(TAG, "columnName == &gt;" +columnName);}while (cursor.moveToNext()) {Log.d(TAG, "=====================");    for (String columnName : columnNames) {        String value = cursor.getString(cursor.getColumnIndex(columnName));        Log.d(TAG, columnName + "====" + value);    }    Log.d(TAG, "=====================");}cursor.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入(insert):"></a>插入(insert):</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int result = sUriMatcher.match(uri);if (result == USER_MATCH_CODE) {    SQLiteDatabase db = mUserDatabaseHelper.getWritableDatabase();    long id = db.insert(Constants.TABLE_NAME, null, values);    //将规则里面的path改为user    Uri resultUri = Uri.parse("content://com.example.contentprovider/user/" + id);    //插入数据成功,数据已经变化,通知其它地方(谁监听就通知谁)    getContext().getContentResolver().notifyChange(resultUri,null);//observer可以填空,也可以new 一个出来    return resultUri;} else {    //不匹配规则    throw new IllegalArgumentException("参数错误");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>activity_main.xml中加入获取数据的按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:onClick="addUser"    android:text="插入数据"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toBottomOf="@id/query_btn" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainActivity中加入添加数据的点击事件:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String FIELD_USER_NAME="userName";public static final String FIELD_PASSWORD ="password";public static final String FIELD_SEX ="sex";public static final String FIELD_AGE ="age";public void addUser(View view) {    ContentResolver contentResolver = getContentResolver();    Uri uri = Uri.parse("content://com.example.contentprovider/user");    ContentValues values=new ContentValues();    values.put(USER_SERVICE,"BillGates");    values.put(FIELD_PASSWORD,"123456");    values.put(FIELD_SEX,"male");    values.put(FIELD_AGE,59);    contentResolver.insert(uri,values);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MainActvity的onCreate中加入:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ContentResolver contentResolver = getContentResolver();Uri uri = Uri.parse("content://com.example.contentprovider");//notifyForDescendants:true表示content://com.example.contentprovider/xxx都能监听到;//false表示严格监听content://com.example.contentprovidercontentResolver.registerContentObserver(uri, true, new ContentObserver(new Handler()) {    //Handler用于post()    @Override    public void onChange(boolean selfChange) {        super.onChange(selfChange);        Log.d(TAG, "用户数据发生变化...");        //todo:获取新的内容    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例子1-动态获取权限读取日历表内容"><a href="#例子1-动态获取权限读取日历表内容" class="headerlink" title="例子1:动态获取权限读取日历表内容"></a>例子1:动态获取权限读取日历表内容</h2><h3 id="首先拿到contentResolver-然后获取URI"><a href="#首先拿到contentResolver-然后获取URI" class="headerlink" title="首先拿到contentResolver,然后获取URI"></a>首先拿到contentResolver,然后获取URI</h3><p>如何获取uri:可以看文档,也可以看源码<br><a href="https://github.com/TrillGates/CalendarProvider/blob/master/AndroidManifest.xml">安卓上层应用源码</a><br>找到下图位置:</p><p><img src="/liaojie.github.io/medias/calendarGithub.png"></p><p>搜索: static</p><p><img src="/liaojie.github.io/medias/calendarSource.png"></p><p>可以看出authority是:CalendarContract.AUTHORITY</p><p>添加authority常量:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String AUTHORITY = "com.android.calendar";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="找到path"><a href="#找到path" class="headerlink" title="找到path"></a>找到path</h3><p><img src="/liaojie.github.io/medias/path.png"></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void queryCalendars() {    ContentResolver contentResolver=getContentResolver();    //Uri uri=Uri.parse("content://"+"com.android.calender/"+"calenders");    Uri uri= CalendarContract.Calendars.CONTENT_URI;    Cursor query = contentResolver.query(uri, null, null, null, null);    String[] columnNames=query.getColumnNames();    while (query.moveToNext()){        Log.d(TAG, "==================================");        for (String columnName:columnNames){            Log.d(TAG, columnName+"==="+query.getString(query.getColumnIndex(columnName)));        }        Log.d(TAG, "===================================");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要在AndroidManifest中添加权限</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.calendarprovider"&gt;    &lt;!--添加的俩个权限--&gt;    &lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;    &lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.CalendarProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Android6.0之后需要动态获取权限</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final int PERMISSION_REQUEST_CODE=1;private void checkCalendarPermission() {    int readPermission = checkSelfPermission(Manifest.permission.READ_CALENDAR);    int writePermission = checkSelfPermission(Manifest.permission.WRITE_CALENDAR);    if (readPermission== PackageManager.PERMISSION_GRANTED&amp;&amp;writePermission==PackageManager.PERMISSION_GRANTED){        //表示有权限    }else {        Log.d(TAG, "requestPermissions...");        //用户点击了确定以后再去调用请求权限        //如果点击了就不再提示了,就不再获取了.如果不能使用,根据需求进行下一步        requestPermissions(new String[]{Manifest.permission.READ_CALENDAR,Manifest.permission.WRITE_CALENDAR},PERMISSION_REQUEST_CODE);    }}//接收结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode==PERMISSION_REQUEST_CODE){        //判断结果        if (grantResults.length==2&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED&amp;&amp;grantResults[1]==PackageManager.PERMISSION_GRANTED){            //有权限            Log.d(TAG, "has permission...");        }else {            Log.d(TAG, "no permission...");            //没权限            finish();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在checkCalendarPermission之前加上版本检查</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {    //Build.VERSION_CODES.M(public static final int M = 23;(Build.java))  6.0    checkCalendarPermission();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>执行queryCalendars();<br>插入事件需要使用的字段<br><img src="/liaojie.github.io/medias/%E5%B8%B8%E9%87%8F%E6%8F%8F%E8%BF%B0.png"></p><p>规则：<br>    1.您必须加入 CALENDAR_ID 和 DTSTART。<br>    2.您必须加入 EVENT_TIMEZONE。如需获取系统中已安装时区 ID 的列表，请使用 getAvailableIDs()。请注意，如果您按使Intent 插入事件中所述通过 INSERT Intent 插入事件，则此规则不适用 — 在该情形下，系统会提供默认时区。<br>    3.对于非重复事件，您必须加入 DTEND。<br>    4.对于重复事件，您必须加入 DURATION，以及 RRULE 或 RDATE。请注意，如果您按使用 Intent 插入事件中所述通过 INSERT Intent 插入事件，则此规则不适用 — 在该情形下，您可以将 RRULE 与 DTSTART 和 DTEND 结合使用，日历应用会自动将其转换为持续时间。</p><p>向日历中插入事件<br>    1.先通过前面的日历表，查询到日历的id，因为CALENDAR_ID是必须填写的<br>    2.必须要填写DTSTART和EVENT_TIMEZONE<br>    3.非重复事件，必须加入DTEND<br>    4.如果重复事件，则要加入DURATION，RRULE 或 RDATE</p><p>在UI里面添加一个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:onClick="addAlertEvent"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="添加提醒"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向日历中添加提醒事件"><a href="#向日历中添加提醒事件" class="headerlink" title="向日历中添加提醒事件"></a>向日历中添加提醒事件</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void addAlertEvent(View view) {    //前面查询出来的    long calID = 1;    //创建时间    Calendar beginTime = Calendar.getInstance();    //开始时间    //月从0开始    beginTime.set(2021, 1, 14, 5, 20);    long beginTimeMills = beginTime.getTimeInMillis();    //结束时间    Calendar endTime = Calendar.getInstance();    endTime.set(2021, 2, 14, 5, 20);    long endTimeMillis = endTime.getTimeInMillis();    //事件内容        String timeZone = TimeZone.getDefault().getID();    Log.d(TAG, "timeZone--&gt;" + timeZone);    ContentValues eventValues = new ContentValues();    //开始时间    eventValues.put(CalendarContract.Events.DTSTART, beginTimeMills);    //结束时间    eventValues.put(CalendarContract.Events.DTEND, endTimeMillis);    //日历ID    eventValues.put(CalendarContract.Events.CALENDAR_ID, calID);    //时间时区    eventValues.put(CalendarContract.Events.EVENT_TIMEZONE, timeZone);    //标题    eventValues.put(CalendarContract.Events.TITLE, "双十一购物狂欢开抢");    eventValues.put(CalendarContract.Events.EVENT_LOCATION, "重庆");    eventValues.put(CalendarContract.Events.DESCRIPTION, "买东西");    Uri eventUri = CalendarContract.Events.CONTENT_URI;    //Uri uri=Uri.parse("content://"+..);    ContentResolver contentResolver = getContentResolver();    Uri resultUri = contentResolver.insert(eventUri, eventValues);    String eventID = resultUri.getLastPathSegment();    Log.d(TAG, "eventID--&gt;" + eventID);    ContentValues reminderValues = new ContentValues();    Uri reminderUri = CalendarContract.Reminders.CONTENT_URI;    contentResolver.insert(reminderUri, reminderValues);    reminderValues.put(CalendarContract.Reminders.EVENT_ID, eventID);    reminderValues.put(CalendarContract.Reminders.MINUTES, 15);    reminderValues.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALARM);    Log.d(TAG, "resultUri--&gt;" + resultUri);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入提醒"><a href="#插入提醒" class="headerlink" title="插入提醒"></a>插入提醒</h3><p>以下是提醒表的字段：<br><img src="/liaojie.github.io/medias/remain.png"><br>规则：插入新提醒时，您必须加入以上所有字段</p><p>其他操作可参考<a href="https://developer.android.google.cn/guide/topics/providers/calendar-provider.html#top_of_page">Android日历官方文档</a></p><p><a href="https://github.com/liaojie1314/CalendarProvider">完整项目</a></p><h2 id="例子2-获取通讯录联系人数据介绍"><a href="#例子2-获取通讯录联系人数据介绍" class="headerlink" title="例子2:获取通讯录联系人数据介绍"></a>例子2:获取通讯录联系人数据介绍</h2><h3 id="在配置文件里声明内容提供者的权限"><a href="#在配置文件里声明内容提供者的权限" class="headerlink" title="在配置文件里声明内容提供者的权限"></a>在配置文件里声明内容提供者的权限</h3><p><a href="https://github.com/TrillGates/ContactsProvider">联系人内容提供者源码</a></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.contactsprovider"&gt;    &lt;!--添加权限--&gt;    &lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.ContactsProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h3><p>首先是找到provider类， 或者从配置文件里找到注册的地方<br><img src="/liaojie.github.io/medias/providerGithub.png"></p><p>搜索静态代码块:static<br><img src="/liaojie.github.io/medias/providerSource.png"></p><p>ContactsContract.java的代码在framework里</p><p>设置ContactsContract.AUTHORITY常量:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String AUTHORITY = "com.android.contacts";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取数据表"><a href="#获取数据表" class="headerlink" title="获取数据表"></a>获取数据表</h3><p>raw_contacts:包含联系人数据摘要的行，针对特定用户帐户和类型。</p><p>mimetypes:数据类型描述表</p><p>data:数据表，存储号码、QQ、邮箱、昵称、图片。这些类型都在mimetypes里有。</p><p>所以如果我们要拿一个用户的数据,就应该是从raw_contacts里拿到id,再到data拿出数据,根据mimetype来判断数据的类型。</p><p>但是现在的android系统不是这样的了,也不直接给你读取mimetypes里的数据了。</p><p>得到URI:<br>content://com.android.contacts/data/phones</p><h3 id="创建Bean类-封装数据"><a href="#创建Bean类-封装数据" class="headerlink" title="创建Bean类,封装数据"></a>创建Bean类,封装数据</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class UserInfo {    private String id;    private String displayName;    private String phoneNum;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getDisplayName() {        return displayName;    }    public void setDisplayName(String displayName) {        this.displayName = displayName;    }    public String getPhoneNum() {        return phoneNum;    }    public void setPhoneNum(String phoneNum) {        this.phoneNum = phoneNum;    }    @Override    public String toString() {        return "UserInfo{" +                "id='" + id + '\'' +                ", displayName='" + displayName + '\'' +                ", phoneNum='" + phoneNum + '\'' +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="布局UI"><a href="#布局UI" class="headerlink" title="布局UI"></a>布局UI</h3><p>添加一个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="获取联系人信息"    android:onClick="getContactInfo"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.Manifest;import android.content.ContentResolver;import android.content.pm.PackageManager;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.provider.ContactsContract;import android.util.Log;import android.view.View;import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import java.util.ArrayList;import java.util.List;@RequiresApi(api = Build.VERSION_CODES.M)public class MainActivity extends AppCompatActivity {    private static final String TAG = "MainActivity";    public static final int PERMISSION_REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //getUserInfo();        checkContactReadPermission();    }    private void checkContactReadPermission() {        int readContactPermission = checkSelfPermission(Manifest.permission.READ_CONTACTS);        if (readContactPermission != PackageManager.PERMISSION_GRANTED) {            requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, PERMISSION_REQUEST_CODE);        }    }    public void getContactInfo(View view) {        getUserInfo();    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        if (requestCode == PERMISSION_REQUEST_CODE) {            if (grantResults.length == 1 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {                Log.d(TAG, "has permission...");            } else {                Log.d(TAG, "no permission...");            }        }    }    private void getUserInfo() {        ContentResolver cr = getContentResolver();        //Uri constantsUri=Uri.parse("content://com.android.contacts");        Uri rawContactUri = Uri.parse("content://" + ContactsContract.AUTHORITY + "/raw_contacts");        Cursor rawContactCursor = cr.query(rawContactUri, new String[]{"contact_id", "display_name"}, null, null, null);        //string[] columnNames = rawContactCursor.getColumnNames();        List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();        while (rawContactCursor.moveToNext()) {            UserInfo userInfo = new UserInfo();            userInfo.setId(rawContactCursor.getString(rawContactCursor.getColumnIndex("contact_id")));            userInfo.setDisplayName(rawContactCursor.getString(rawContactCursor.getColumnIndex("display_name")));            userInfos.add(userInfo);            //for (String columnName : columnNames) {            //      Log.d(TAG, columnName + " values--&gt;" + rawContactCursor.getString(rawContactCursor.getColumnIndex(columnName)));            // }        }        rawContactCursor.close();        Uri phoneUri = Uri.parse("content://" + ContactsContract.AUTHORITY + "/raw_contacts");        for (UserInfo userInfo : userInfos) {            //获取手机号码            Cursor phoneCursor = cr.query(phoneUri, new String[]{"data1"}, "raw_contact_id", new String[]{userInfo.getId()}, null);            if (phoneCursor.moveToNext()) {                userInfo.setPhoneNum(phoneCursor.getString(0).replace("-", ""));            }            phoneCursor.close();            Log.d(TAG, "UserInfo--&gt;" + userInfo);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/ContactsProvider">完整项目</a></p><h2 id="例子3-读取短信内容"><a href="#例子3-读取短信内容" class="headerlink" title="例子3:读取短信内容"></a>例子3:读取短信内容</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>provider地址:<br><a href="https://github.com/TrillGates/TelephonyProvider/blob/master/src/com/android/providers/telephony/SmsProvider.java">TelephonyProvider</a></p><p>搜索:static<br><img src="/liaojie.github.io/medias/phoneProviderSource.png"></p><p>得到Uri:<br>Uri uri = Uri.parse(“content://sms/“);</p><h3 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h3><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.smsprovider"&gt;    &lt;!--权限--&gt;    &lt;uses-permission android:name="android.permission.READ_SMS"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.SMSProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!--VerifyCodeActivity注册--&gt;        &lt;activity android:name=".VerifyCodeActivity"&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态获取权限"><a href="#动态获取权限" class="headerlink" title="动态获取权限"></a>动态获取权限</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void checkSmsReadPermission() {    int permissionResultCode = checkSelfPermission(Manifest.permission.READ_SMS);    if (permissionResultCode!= PackageManager.PERMISSION_GRANTED){        requestPermissions(new String[]{Manifest.permission.READ_SMS},PERMISSION_REQUEST_CODE);    }}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode==PERMISSION_REQUEST_CODE){        Log.d(TAG, "grantResults--&gt;"+grantResults[0]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h3><p>添加俩个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".MainActivity"&gt;    &lt;Button        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="获取短信内容"        android:onClick="getSmsContent"        android:id="@+id/get_sms_content_btn"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintLeft_toLeftOf="parent"        app:layout_constraintRight_toRightOf="parent"        app:layout_constraintTop_toTopOf="parent" /&gt;    &lt;Button        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="获取短信验证码"        android:onClick="toVerityCodePage"        app:layout_constraintLeft_toLeftOf="parent"        app:layout_constraintRight_toRightOf="parent"        app:layout_constraintTop_toBottomOf="@id/get_sms_content_btn" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加点击事件"><a href="#添加点击事件" class="headerlink" title="添加点击事件:"></a>添加点击事件:</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void getSmsContent(View view){    ContentResolver cr = getContentResolver();    Uri uri=Uri.parse("content://sms/");    Cursor query = cr.query(uri, null, null, null, null);    String[] columnNames = query.getColumnNames();    while (query.moveToNext()) {        for (String columnName : columnNames) {            Log.d(TAG, columnName+"===="+query.getString(query.getColumnIndex(columnName)));        }    }    query.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MainActivity完整代码"><a href="#MainActivity完整代码" class="headerlink" title="MainActivity完整代码"></a>MainActivity完整代码</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import android.Manifest;import android.content.ContentResolver;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;@RequiresApi(api = Build.VERSION_CODES.M)public class MainActivity extends AppCompatActivity {    private static final int PERMISSION_REQUEST_CODE=1;    private static final String TAG ="MainActivity" ;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        checkSmsReadPermission();    }    public void toVerityCodePage(View view){        startActivity(new Intent(this,VerifyCodeActivity.class));    }    public void getSmsContent(View view){        ContentResolver cr = getContentResolver();        Uri uri=Uri.parse("content://sms/");        Cursor query = cr.query(uri, null, null, null, null);        String[] columnNames = query.getColumnNames();        while (query.moveToNext()) {            for (String columnName : columnNames) {                Log.d(TAG, columnName+"===="+query.getString(query.getColumnIndex(columnName)));            }        }        query.close();    }    private void checkSmsReadPermission() {        int permissionResultCode = checkSelfPermission(Manifest.permission.READ_SMS);        if (permissionResultCode!= PackageManager.PERMISSION_GRANTED){            requestPermissions(new String[]{Manifest.permission.READ_SMS},PERMISSION_REQUEST_CODE);        }    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        if (requestCode==PERMISSION_REQUEST_CODE){            Log.d(TAG, "grantResults--&gt;"+grantResults[0]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建VerifycodeActivity"><a href="#新建VerifycodeActivity" class="headerlink" title="新建VerifycodeActivity"></a>新建VerifycodeActivity</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.content.UriMatcher;import android.database.ContentObserver;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.os.CountDownTimer;import android.os.Handler;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import java.util.concurrent.atomic.AtomicReference;import java.util.regex.Matcher;import java.util.regex.Pattern;public class VerifyCodeActivity extends AppCompatActivity {    private static final String TAG = "VerifyCodeActivity";    private EditText mPhoneNumEt;    private Button mCountDownBtn;    private EditText mVerifyCodeEt;    private Button mCommitBtn;    private static final int MATCH_CODE=1;    private static UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);    static {        uriMatcher.addURI("sms","#",MATCH_CODE);        //"#"代表数字;"*"代表文本    }    //倒计时CountDownTimer(总时间,梯度)    private CountDownTimer mCountDownTimer=new CountDownTimer(60*1000,1000) {        @Override        public void onTick(long millisUntilFinished) {            mCountDownBtn.setEnabled(false);            mCountDownBtn.setText(String.format("重新获取(%d)",millisUntilFinished/1000));        }        @Override        public void onFinish() {            mCountDownBtn.setEnabled(true);            mCountDownBtn.setText(String.format("获取验证码"));        }    };    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_verify_code);        initView();        initEvent();        //注册短信内容提供者的观察者        Uri uri=Uri.parse("content://sms/");        getContentResolver().registerContentObserver(uri, true, new ContentObserver(new Handler()) {            @Override            public void onChange(boolean selfChange, @Nullable Uri uri) {                Log.d(TAG, "selfChange--&gt;"+selfChange);                if (uriMatcher.match(uri)==MATCH_CODE) {                    Log.d(TAG, "uri--&gt;"+uri);                    Cursor query = getContentResolver().query(uri, new String[]{"body"}, null, null, null);                    if (query.moveToNext()) {                        String body = query.getString(0);                        Log.d(TAG, "body==="+body);                        handlerBody(body);                    }                    query.close();                }            }        });    }    private void handlerBody(String body) {        if (!TextUtils.isEmpty(body)&amp;&amp;body.startsWith("【xxx】")) {            Pattern p=Pattern.compile("(?&lt;![0-9])([0-9]{4})(?![0-9])");//4位验证码            Matcher matcher=p.matcher(body);            boolean contain=matcher.find();            if (contain) {                String group = matcher.group();                Log.d(TAG, "verifyCode--&gt;"+ group);                mVerifyCodeEt.setText(group);                mVerifyCodeEt.setFocusable(true);//添加焦点            }        }    }    private void initEvent() {       mCountDownBtn.setOnClickListener(new View.OnClickListener() {           @Override           public void onClick(View v) {               String phoneNum = mPhoneNumEt.getText().toString().trim();               if (TextUtils.isEmpty(phoneNum)) {                   Toast.makeText(VerifyCodeActivity.this,"手机号码不能为空",Toast.LENGTH_SHORT).show();                   return;               }               // TODO: 向服务器请求发送验证码到手机               mCountDownTimer.start();           }       });       mCommitBtn.setOnClickListener(new View.OnClickListener() {           @Override           public void onClick(View v) {               String phoneNum = mPhoneNumEt.getText().toString().trim();               String verifyCode = mVerifyCodeEt.getText().toString().trim();               if (TextUtils.isEmpty(phoneNum)||TextUtils.isEmpty(verifyCode)){                   Toast.makeText(VerifyCodeActivity.this,"验证码和手机号都不能为空",Toast.LENGTH_SHORT).show();                   return;               }               // TODO: 向服务器提交           }       });    }    private void initView() {        mPhoneNumEt = this.findViewById(R.id.phone_num_et);        mVerifyCodeEt = this.findViewById(R.id.verify_code_et);        mCountDownBtn = this.findViewById(R.id.count_down_btn);        mCommitBtn = this.findViewById(R.id.submit_btn);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="activity-verity-code-xml"><a href="#activity-verity-code-xml" class="headerlink" title="activity_verity_code.xml"></a>activity_verity_code.xml</h3><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="50dp"&gt;        &lt;EditText            android:id="@+id/phone_num_et"            android:layout_width="match_parent"            android:layout_height="match_parent"            android:layout_marginRight="120dp"            android:hint="请输入手机号码"            android:inputType="number" /&gt;        &lt;Button            android:id="@+id/count_down_btn"            android:layout_width="120dp"            android:layout_height="match_parent"            android:layout_alignParentRight="true"            android:layout_marginRight="10dp"            android:text="获取验证码" /&gt;    &lt;/RelativeLayout&gt;    &lt;EditText        android:id="@+id/verify_code_et"        android:layout_width="match_parent"        android:layout_height="50dp"        android:hint="请输入验证码"        android:inputType="number" /&gt;    &lt;Button        android:id="@+id/submit_btn"        android:layout_width="match_parent"        android:layout_height="50dp"        android:text="检查验证码" /&gt;&lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码:"></a>发送验证码:</h3><p><img src="/liaojie.github.io/medias/%E9%AA%8C%E8%AF%81.png"></p><p>在其中输入:<br>    【xxx】验证码：4356，15分钟内有效</p><p>校验结果:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);public static final int MATCH_CODE = 1;static {    sUriMatcher.addURI("sms","#",MATCH_CODE);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注册短信内容变化的观察者"><a href="#注册短信内容变化的观察者" class="headerlink" title="注册短信内容变化的观察者:"></a>注册短信内容变化的观察者:</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final ContentResolver contentResolver = getContentResolver();    Uri uri = Uri.parse("content://sms/");    contentResolver.registerContentObserver(uri,true,new ContentObserver(new Handler()) {        @Override        public void onChange(boolean selfChange,Uri uri) {            if(sUriMatcher.match(uri) == MATCH_CODE) {                Log.d(TAG,"selfChange -- &gt; " + " uri -- &gt; " + uri);                Cursor query = contentResolver.query(uri,null,null,null,null);                if(query.moveToNext()) {                    String body = query.getString(query.getColumnIndex("body"));                    Log.d(TAG,"body -- &gt; " + body);                    handlerMsg(body);                }            query.close();            }        }    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理结果:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void handlerMsg(String body) {    if(body != null &amp;&amp; body.startsWith("【xxx】")) {        //符合条件        //截取数字        Pattern p = Pattern.compile("(?&lt;![0-9])([0-9]{4})(?![0-9])");        Matcher matcher = p.matcher(body);        boolean contain = matcher.find();        if(contain) {            Log.d(TAG,"verifyCode -- &gt; " + matcher.group());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token property">D/MainActivity:</span> selfChange <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span>  uri <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> content<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>sms<span class="token operator">/</span><span class="token number">19</span><span class="token property">D/MainActivity:</span> body <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> 【xxx】验证码：<span class="token number">4356</span>，<span class="token number">15</span>分钟内有效<span class="token property">D/MainActivity:</span> verifyCode <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> <span class="token number">4356</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/SMSProvider">完整代码</a></p><h2 id="例子4-获取媒体库里的图片"><a href="#例子4-获取媒体库里的图片" class="headerlink" title="例子4:获取媒体库里的图片"></a>例子4:获取媒体库里的图片</h2><p>在android中有一个提供者中做MediaProvider</p><p>源码地址：<br><a href="https://github.com/TrillGates/MediaProvider">MediaProvider</a><br>获取到图片内容<br>URI</p><ul><li>图片的Url</li></ul><blockquote><p>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</p></blockquote><ul><li>视频的Url</li></ul><blockquote><p>MediaStore.Video.Media.EXTERNAL_CONTENT_URI</p></blockquote><ul><li>音频的Url</li></ul><blockquote><p>MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</p></blockquote><p>权限</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void checkPermission() {    int readExternalStoragePermissionResult = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);    if(readExternalStoragePermissionResult != PackageManager.PERMISSION_GRANTED) {        requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},PERMISSION_REQUEST_CODE);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据表字段"><a href="#数据表字段" class="headerlink" title="数据表字段"></a>数据表字段</h3><p>获得表的内容和字段</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ContentResolver contentResolver = getContentResolver();Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;Cursor query = contentResolver.query(uri,null,null,null,null,null);String[] columnNames = query.getColumnNames();while(query.moveToNext()) {    Log.d(TAG,"----------------------------");    for(String columnName : columnNames) {        Log.d(TAG,columnName + " ==== " + query.getString(query.getColumnIndex(columnName)));    }    Log.d(TAG,"----------------------------");}query.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得需要的字段:</p><ul><li>路径_data</li><li>图片名称_display_name</li><li>时间date_added</li></ul><p>还有经纬度等,通过这个经纬度+API转换就可以得到地址了,所以图片里可以包含着地理信息.</p><p>使用LoaderManager</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void initLoaderManager() {    LoaderManager loaderManager = LoaderManager.getInstance(this);    loaderManager.initLoader(LOADER_ID, null, new LoaderManager.LoaderCallbacks&lt;Cursor&gt;() {        @NonNull        @Override        public Loader&lt;Cursor&gt; onCreateLoader(int id, @Nullable Bundle args) {            if (id == LOADER_ID) {                return new CursorLoader(PickerActivity.this,                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                        new String[]{"_data", "_display_name", "date_added"},                        null, null, "date_added DESC");                //DESC 逆序            }            return null;        }        @Override        public void onLoadFinished(@NonNull androidx.loader.content.Loader&lt;Cursor&gt; loader, Cursor cursor) {            if (cursor != null) {                String[] columnNames = cursor.getColumnNames();                while (cursor.moveToNext()) {                    Log.d(TAG, "----------------------------");                    for (String columnName : columnNames) {                        Log.d(TAG, columnName + " ==== " + cursor.getString(cursor.getColumnIndex(columnName)));                    }                    Log.d(TAG, "----------------------------");                }                cursor.close();            }        }        @Override        public void onLoaderReset(@NonNull androidx.loader.content.Loader&lt;Cursor&gt; loader) {        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="准备一个封装数据的bean类"><a href="#准备一个封装数据的bean类" class="headerlink" title="准备一个封装数据的bean类"></a>准备一个封装数据的bean类</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class PhotoItem {    private String path;    private String name;    private long createDate;    private boolean isSelected = false;    public boolean isSelected() {        return isSelected;    }    public void setSelected(boolean selected) {        isSelected = selected;    }    public String getPath() {        return path;    }    public void setPath(String path) {        this.path = path;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public long getCreateDate() {        return createDate;    }    public void setCreateDate(long createDate) {        this.createDate = createDate;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取到图片的数据-并且封装起来-显示出来"><a href="#获取到图片的数据-并且封装起来-显示出来" class="headerlink" title="获取到图片的数据,并且封装起来,显示出来"></a>获取到图片的数据,并且封装起来,显示出来</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.content.ContentResolver;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import com.example.imagepickerdemo.domain.PhotoItem;import java.util.ArrayList;import java.util.List;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.RecyclerView;public class ImagePickerActivity extends AppCompatActivity {    private static final String TAG = "ImagePickerActivity";    private RecyclerView mPicListView;    private List&lt;PhotoItem&gt; mPics = new ArrayList&lt;&gt;();    private PicListAdapter mPicListAdapter;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_image_picker);        initView();        initData();    }    private void initData() {        //这些事情其实不能在主线程做        ContentResolver contentResolver = getContentResolver();        Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;        Cursor query = contentResolver.query(uri,new String[]{                MediaStore.Images.Media.DATA,                MediaStore.Images.Media.DISPLAY_NAME,                MediaStore.Images.Media.DATE_ADDED,                MediaStore.Images.Media._ID},null,null,null,null);        while(query.moveToNext()) {            PhotoItem photoItem = new PhotoItem();            photoItem.setPath(query.getString(0));            //这里的下标跟上面的query第一个参数对应，时间是第2个，所以下标为1            photoItem.setCreateDate(query.getLong(1));            photoItem.setName(query.getString(2));            mPics.add(photoItem);        }        query.close();        mPicListAdapter.setData(mPics);    }    private void initView() {        mPicListView = this.findViewById(R.id.pic_list);        mPicListView.setLayoutManager(new GridLayoutManager(this,3));        mPicListAdapter = new PicListAdapter();        mPicListView.setAdapter(mPicListAdapter);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="适配器代码"><a href="#适配器代码" class="headerlink" title="适配器代码"></a>适配器代码</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class PicListAdapter extends RecyclerView.Adapter&lt;PicListAdapter.InnerHolder&gt; {    private List&lt;PhotoItem&gt; mData = new ArrayList&lt;&gt;();    @NonNull    @Override    public InnerHolder onCreateViewHolder(@NonNull ViewGroup parent,int viewType) {        ImageView iv = new ImageView(parent.getContext());        iv.setScaleType(ImageView.ScaleType.CENTER_CROP);        Point point = new Point();        ((WindowManager) parent.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(point);        RecyclerView.LayoutParams layoutParams = new RecyclerView.LayoutParams(point.x / 3,point.x / 3);        iv.setLayoutParams(layoutParams);        return new InnerHolder(iv);    }    @Override    public void onBindViewHolder(@NonNull InnerHolder holder,int position) {        if(holder.itemView instanceof ImageView) {            Glide.with(holder.itemView.getContext()).load(mData.get(position).getPath()).into((ImageView) holder.itemView);        }    }    @Override    public int getItemCount() {        return mData.size();    }    public void setData(List&lt;PhotoItem&gt; pics) {        mData.clear();        mData.addAll(pics);        notifyDataSetChanged();    }    public class InnerHolder extends RecyclerView.ViewHolder {        public InnerHolder(@NonNull View itemView) {            super(itemView);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用LoaderManager来加载"><a href="#使用LoaderManager来加载" class="headerlink" title="使用LoaderManager来加载"></a>使用LoaderManager来加载</h3><p>前面我们直接在onCreate的地方加载数据,如果数据量大的话会导致主线程阻塞出现ANR异常。如果数据量小会影响页面的打开速度。<br>所以我们要么自己创建子线程去获取,要么通过LoaderManager去获取。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MediaContentPickerActivity extends AppCompatActivity {    private static final int LOADER_ALL = 0;         // 获取所有图片    private static final String TAG = "ContentPickerActivity";    private List&lt;PhotoItem&gt; photoInfoList = new ArrayList&lt;&gt;();      // 本地图片信息List    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_media_picker);        initLoader();    }    private void initLoader() {        LoaderManager loaderManager = LoaderManager.getInstance(this);        loaderManager.initLoader(LOADER_ALL,null,new LoaderManager.LoaderCallbacks&lt;Cursor&gt;() {            private final String[] IMAGE_PROJECTION = {                    MediaStore.Images.Media.DATA,                    MediaStore.Images.Media.DISPLAY_NAME,                    MediaStore.Images.Media.DATE_ADDED,                    MediaStore.Images.Media._ID,            };            @NonNull            @Override            public Loader&lt;Cursor&gt; onCreateLoader(int id,@Nullable Bundle args) {                if(id == LOADER_ALL) {                    return new CursorLoader(MediaContentPickerActivity.this,                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,IMAGE_PROJECTION,                            null,null,IMAGE_PROJECTION[2] + " DESC");                }                return null;            }            @Override            public void onLoadFinished(@NonNull Loader&lt;Cursor&gt; loader,Cursor data) {                if(data != null) {                    int count = data.getCount();                    if(count &gt; 0) {                        List&lt;PhotoItem&gt; tempPhotoList = new ArrayList&lt;&gt;();                        data.moveToFirst();                        do {                            String path = data.getString(data.getColumnIndexOrThrow(IMAGE_PROJECTION[0]));                            String name = data.getString(data.getColumnIndexOrThrow(IMAGE_PROJECTION[1]));                            long dateTime = data.getLong(data.getColumnIndexOrThrow(IMAGE_PROJECTION[2]));                            PhotoItem photoItem = new PhotoItem();                            photoItem.setName(name);                            photoItem.setPath(path);                            photoItem.setCreateDate(dateTime);                            tempPhotoList.add(photoItem);                        } while(data.moveToNext());                        photoInfoList.clear();                        photoInfoList.addAll(tempPhotoList);                    }                    //输出结果                    for(PhotoItem photoItem : photoInfoList) {                        Log.d(TAG,"photoItem -- &gt; " + photoItem);                    }                }            }            @Override            public void onLoaderReset(@NonNull Loader&lt;Cursor&gt; loader) {            }        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给PhotoItem.java添加toString方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic String toString() {    return "PhotoItem{" +            "path='" + path + '\'' +            ", name='" + name + '\'' +            ", createDate=" + createDate +            ", isSelected=" + isSelected +            '}';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们就把图片获取出来了</p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.iconfont.cn/">iconfont</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开源库之Jetpack</title>
      <link href="/liaojie.github.io/2021/10/20/jetpack/"/>
      <url>/liaojie.github.io/2021/10/20/jetpack/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是Jetpack"><a href="#什么是Jetpack" class="headerlink" title="什么是Jetpack?"></a>什么是Jetpack?</h5><p>Jetpack 是一个丰富的组件库,它的组件库按类别分为 4 类,分别是架构（Architecture）、界面（UI）、行为（behavior）和基础（foundation）.每个组件都可以单独使用,也可以配合在一起使用.每个组件都给用户提供了一个标准,能够帮助开发者遵循最佳做法,减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者能够集中精力编写重要的业务代码.</p><p><img src="/liaojie.github.io/medias/jetpack%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><pre class="line-numbers language-官方" data-language="官方"><code class="language-官方">Jetpack 是一个由多个库组成的套件,可帮助开发者遵循最佳做法、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者可将精力集中于真正重要的编码工作.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>优点:<br>1.体现了单一原则<br>2.分层清晰<br>3.不需要非常依赖Activity<br>4.旋转数据不会丢失<br>…</p><p><a href="https://developer.android.google.cn/jetpack">官方文档</a></p><h5 id="在应用中使用-Jetpack-库"><a href="#在应用中使用-Jetpack-库" class="headerlink" title="在应用中使用 Jetpack 库"></a>在应用中使用 Jetpack 库</h5><p>所有 Jetpack 组件都可在 Google Maven 代码库中找到。</p><p>打开项目的 build.gradle 文件并添加 google() 代码库，如下所示：</p><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">Groovy:allprojects {    repositories {        google()        jcenter()    }}Kotlin:allprojects {    repositories {        google()        jcenter()    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，您可以添加 Jetpack 组件（例如 LiveData 和 ViewModel 等架构组件），如下所示：</p><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">Groovy:dependencies {    def lifecycle_version = "2.2.0"    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"    ...}Kotlin:dependencies {    val lifecycle_version = "2.2.0"    implementation("androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version")    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version")    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>许多 Jetpack 库都提供 <a href="https://developer.android.google.cn/kotlin/ktx">Android KTX 扩展</a>，如上面的 lifecycle-livedata-ktx 和 lifecycle-viewmodel-ktx 所示。KTX 扩展在基于 Java 的 API 基础上构建，充分利用了 Kotlin 特有的语言功能。</p><p>基于 <a href="https://developer.android.google.cn/reference/kotlin/androidx/packages">Kotlin</a> 以及基于 <a href="https://developer.android.google.cn/reference/androidx/packages">Java</a> 的 API 参考文档页面适用于所有 Jetpack 库</p><h5 id="利用-Jetpack"><a href="#利用-Jetpack" class="headerlink" title="利用 Jetpack"></a>利用 Jetpack</h5><p>Jetpack 库可以单独使用，也可以组合使用，以满足应用的不同需求。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">WorkManager</a> - 满足您的后台调度需求。<br><a href="https://developer.android.google.cn/topic/libraries/architecture/room">Room</a> - 实现数据存储持久性。<br><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started">Navigation</a> - 管理应用导航流程。<br><a href="https://developer.android.google.cn/training/camerax">CameraX</a> - 满足相机应用需求。<br>请参阅所有 Jetpack 库的<a href="https://developer.android.google.cn/jetpack/androidx/versions#version-table">概览</a>。</p><p>Jetpack 库在 androidx 命名空间中发布。如果项目目前使用 Android 支持库，请阅读如何迁移到 androidx 命名空间。</p><p>如需详细了解如何使用 Jetpack，请查看以下页面：</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture">Android 架构组件</a><br><a href="https://developer.android.google.cn/topic/libraries/architecture">Jetpack 组件的完整列表</a></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>以注重生命周期的方式管理界面相关的数据(管理UI数据)</p><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>source:</p><p>1.首先定义一个LiveData实例</p><p>2.观察LiveData数据变化,变化时将数据展示到TextView上</p><p>3.改变LiveData里面的数据,数据变化时会回调onChanged()方法</p><p>在底层数据库更改时通知视图(感应改变数据),UI刷新(LiveData+DataBinding)</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MainViewModel extend /*ViewModel*/AndroidViewModel{  //ViewModel 无环境  //AndroidViewModel 有环境 需重写构造函数  private Context context;  public MainViewModel(@NonNull Application application)  {    super(application);    context = application;  }private MutableLiveData&lt;String&gt;info(){info.setValue("");//默认值return info;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>//DataBinding的引入(在build.gradle(:app)中添加):</p><pre class="line-numbers language-gradle(:app)" data-language="gradle(:app)"><code class="language-gradle(:app)">方式一:  dataBinding{  enabled true  }方式二:  dataBinding.enabled=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加后需同步<br>使用:(整个布局交给DataBinding管理)</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;!-- 和类交互 --&gt;    &lt;data&gt;          &lt;variable               name="name"               type="包名+类名"/&gt;    &lt;/data&gt;      //使用:android:text="@{name.info}"      //android:onClick="@{()-&gt;name.function(value)}"           所有布局...&lt;/Layout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MainActivity需要做绑定工作</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private ActivityMainBinding binding;private MainViewModel mainViewModel;//onCreate中添加binding = DataBindingUtil.setContentView(this,R.layout.activity_main);//AndroidViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(MainViewModel.class);//ViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()).get(MainViewModel.class);//绑定工作binding.setName(mainViewModel);//建立感应binding.setLifecycleOwner(this);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：非Activity启动需要加标记.</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Intent intent = new Intent();intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Jetpack+MVVM : Google标准化Jetpack架构模式(强力推荐)</p><h2 id="MVVM、MVC、MVP"><a href="#MVVM、MVC、MVP" class="headerlink" title="MVVM、MVC、MVP"></a>MVVM、MVC、MVP</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>  创建过程:C-&gt;M+V</p><p>  优点:分离了Model和Controller.view与model隔离,view换了,model不影响.model换其他的数据源,view层也不受影响.一个view可以连接多个model,有些model可以复用.比如说你这个页面需要用户信息,另外一个界面也需要用户信息.</p><p>  缺点:Controller变得复杂.这里我们主要指Android上的缺点,不适合在Android开发上使用.在Android开发中,View的相关内容和Controller都写到一起了会让Activity/Fragment越来越臃肿</p><p>  建议:用于简单的、不大修改的页面</p><p>组件的互动:<br>将应用程序划分为三种组件,模型-视图-控制器(MVC)设计定义它们之间的相互作用.<br>  模型 (Model)用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法. Model”有对数据直接访问的权力,例如对数据库的访问.”Model”不依赖”View”和”Controller”.也就是说,Model不关心它会被如何显示或是如何被操作.但是Model中数据的变化一般会通过一种刷新机制被公布.为了实现这种机制,那些用于监视此 Model 的 View 必须事先在此Model上注册,从而,View 可以了解在数据Model上发生的改变.(比如：观察者模式(软件设计模式))</p><p>  视图（View）能够实现数据有目的的显示（理论上，这不是必需的）.在 View 中一般没有程序上的逻辑.为了实现 View 上的刷新功能,View 需要访问它监视的数据模型(Model),因此应该事先在被它监视的数据那里注册.<br>  控制器(Controller)起到不同层面间的组织作用,用于控制应用程序的流程.它处理事件并作出响应.”事件”包括用户的行为和数据Model上的改变.</p><p>在不同的项目开发里面,分别有不同的内容充当MVC.那在Android里是什么充当View,什么充当Model,什么充当Controller呢？<br>  View:Acitivity(View)、Fragment(View)视图,在android里xml布局转成View后,加载到了Activity/Fragmen里了.<br>  Controller:Controller对应着Activity/Fragment,绑定UI,处理各种业务.<br>  Model：数据的获取、存储、更新、domain</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>  创建过程:C-&gt;P-&gt;M<br>  优点:在MVC的基础上,通过Interface彻底分离了View和Model<br>  缺点:Presenter与View的交互会琐碎而复杂<br>  建议:核心、复杂、需求变得快页面</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>  创建过程:C-&gt;VM-&gt;M<br>  优点:在MVP的基础上增加了DataBinding,代码量更小<br>  缺点:XML中包含代码<br>  建议:核心、复杂、需求变得快页面</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C language</title>
      <link href="/liaojie.github.io/2021/10/19/c/"/>
      <url>/liaojie.github.io/2021/10/19/c/</url>
      
        <content type="html"><![CDATA[<p>C语言是一种计算机程序设计语言.它既具有高级语言的特点.又具有汇编语言的特点,它由美国贝尔研究所的D.M.Ritchie于1972年推出.1978后,C语言已先后被移植到大、中、小及微型机上.它可以作为工作系统设计语言,编写系统应用程序,也可以作为应用程序设计语言,编写不依赖计算机硬件的应用程序.它的应用范围广泛,具备很强的数据处理能力,不仅仅是在软件开发上,而且各类科研都需要用到C语言,适于编写系统软件、三维、二维图形和动画.具体应用比如单片机以及嵌入式系统开发.C语言是一门通用计算机编程语言,应用广泛.C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言.</p><p>尽管C语言提供了许多低级处理的功能,但仍然保持着良好跨平台的特性,以一个标准规格写出的C语言程序可在许多电脑平台上进行编译,甚至包含一些嵌入式处理器(单片机或称MCU)级电脑等作业平台.</p><p>二十世纪八十年代,为了避免各开发厂商用的C语言语法产生差异,由美国国家标准局为C语言订定了一套完整的国际标准语法,称为ANSI C,作为C语言最初的标准.</p><h5 id="C都能干啥呢？"><a href="#C都能干啥呢？" class="headerlink" title="C都能干啥呢？"></a>C都能干啥呢？</h5><p>1、C语言可以做嵌入式开发.51单片机、ARM等….</p><p>2、C语言可以写漂亮的界面,以windows开发为例,你可以学习《windows程序设计（第五版）》,学完就可以写出界面来.还有一些开源库界面库,例如soui也是用C写出来的.</p><p>3、C语言可以做服务器开发,现在的游戏服务器端大多都是C/C++开发的.《windows核心编程》里面的例子就是用C写的.</p><p>4、C语言可以写游戏.cocos2d-x就是C/C++写的.DirectX也是.</p><p>5、C语言可以写驱动程序.windows下各种硬件驱动都是C/C++写的.腾讯游戏保护软件(TP)也是驱动程序.</p><p>6、C语言可以写外挂.</p><p>7、C语言可以做视频图片流媒体处理.ffmpeg、live555、sdl等开源库.</p><p>8、C语言可以做网页和爬虫相关的编程.gsoap、libcur等相关开源库.</p><p>9、C语言可以进行黑客编程.配合汇编获取随机地址、调shellcode等.</p>]]></content>
      
      
      <categories>
          
          <category> C language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发之自定义控件</title>
      <link href="/liaojie.github.io/2021/10/11/android/"/>
      <url>/liaojie.github.io/2021/10/11/android/</url>
      
        <content type="html"><![CDATA[<p>自定义控件概念:Android中组件必须是View的直接子类或间接的子类,其中View有一个ViewGroup的子类,用于定义容器,(FrameLayout,LinearLayout,都是ViewGroup的子类).如果组件中还有子组件,就是从ViewGroup类继承,否则从View类继承.只要你自定义控件,要么是View的直接子类,要么就是View的间接子类.</p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><pre class="line-numbers language-none"><code class="language-none">1.自定义组合控件  继承自ViewGroup,比如说LinearLayout/RealativeLayout/FrameLayout--&gt;定义相关属性,获取相关属性  --&gt;加载组合的View/根据属性调整UI--&gt;处理相关事件/根据属性去处理数据--&gt;定义功能接口,对外暴露接口方法  --&gt;处理事件/数据2.自定义ViewGroup  继承自ViewGroup--&gt;定义相关属性,获取相关属性--&gt;把子View添加进来--&gt;测量:测量孩子,测量自己(覆写onMeasure方法)  --&gt;布局Layout--&gt;定义功能接口--&gt;处理事件和数据  3.自定义view  继承自View--&gt;定义相关属性,获取相关属性--&gt;测量自己--&gt;创建相关画笔--&gt;覆写onDraw方法,绘制相关内容  --&gt;定义功能接口--&gt;处理相关事件和数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="属性添加"><a href="#属性添加" class="headerlink" title="属性添加"></a>属性添加</h3><p>1.声明属性名称和值的类型<br>在res/values文件下新建一个属性xml文件,如attrs.xml,然后在属性文件里添加<declare-styleable>标签,并声明属性</declare-styleable></p><pre class="line-numbers language-attrs" data-language="attrs"><code class="language-attrs">&lt;declare-styleable name="InputNumberView"&gt;    &lt;attr name="max" format="integer" /&gt;    &lt;attr name="min" format="integer" /&gt;    &lt;attr name="step" format="integer" /&gt;    &lt;attr name="defaultValue" format="integer" /&gt;    &lt;attr name="disable" format="boolean" /&gt;    &lt;attr name="btnBackground" format="reference" /&gt;    &lt;attr name="valueSize" format="dimension" /&gt;    &lt;attr name="function" format="flags"&gt;        &lt;flag name="delete" value="0x30"/&gt;        &lt;flag name="read" value="0x50"/&gt;        &lt;flag name="top" value="0x03"/&gt;    &lt;/attr&gt;&lt;/declare-styleable&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer，比如说行数，TextView的maxLine，就是Integer类型<br>enum，枚举类型，比如说left,top,bottom,center,right这些是枚举类型<br>boolean，布尔类型，比如说layout_alignParentRight<br>dimension，尺寸比如说size,margin_left这些，单位为px,dp,sp这些<br>color，颜色，比如说background，比如说textColor<br>flags，标记，比如说activity声明周期时的configChanges，gravity<br>float，浮点数，也就是小数，比如说透明度alpha<br>fraction，百分数，比如说动画的开始位置，fromDx<br>refrence，引用，比如说background，src，但background可以是color又可以是refrence，其实是可以多个，比如说：name=”switch_time” format=”integer|float”，可以是Integer类型，或者float类型<br>string，比如说text</p><p>2.获取属性值</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$  TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.looper_style);   //从TypedArray中读取属性值   //......   //如：a.getColor(R.styleable.KeypadView_numberColor, context.getResources().getColor(R.color.white));   a.recycle();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.属性的获取</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">$ app:itemMargin="4dp"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义控件基本绘制原理"><a href="#自定义控件基本绘制原理" class="headerlink" title="自定义控件基本绘制原理"></a>自定义控件基本绘制原理</h3><p>View的绘制基本上由measure()、layout()、draw()三个函数完成<br>1.测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void measure(int widthMeasureSpec, int heightMeasureSpec)  protected final void setMeasuredDimension(int measuredWidth, int measuredHeight)  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>measure调用onMeasure,onMeasure测量宽度、高度然后调用setMeasureDimension保存测量结果,measure,setMeasureDimension是final类型,view的子类不需要重写,onMeasure在view的子类中重写.<br>关于MeasureSpec的三个值：</p><p>(1) UPSPECIFIED ：未指定模式，父容器对于子容器没有任何限制,子容器想要多大就多大，通常在绘制自定义View时才会用</p><p>(2) EXACTLY：精确值模式，父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间，当控件的layout_width和layout_height属性指定为具体数值或match_parent时为该模式。</p><p>(3) AT_MOST：最大值模式，子容器可以是声明大小内的任意大小，当空间的宽高设置为wrap_content时为该模式</p><p>2.布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void layout(int l, int t, int r, int b)protected boolean setFrame(int left, int top, int right, int bottom)protected void onLayout(boolean changed, int left, int top, int right, int bottom)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>layout通过调用setFrame（l,t,r,b），l,t,r,b即子视图在父视图中的具体位置，onLayout一般只会在自定义ViewGroup中才会使用</p><p>3.绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void draw(Canvas canvas)protected void onDraw(Canvas canvas)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过调用draw函数进行视图绘制,在View类中onDraw函数是个空函数,最终的绘制需求需要在自定义的onDraw函数中进行实现,比如ImageView完成图片的绘制,如果自定义ViewGroup这个函数则不需要重载.</p><h3 id="给自定义控件添加事件"><a href="#给自定义控件添加事件" class="headerlink" title="给自定义控件添加事件"></a>给自定义控件添加事件</h3><p>1.获取自定义控件坐标</p><p><img src="/liaojie.github.io/medias/viewFunction.jpg"></p><p>1.view获取自身坐标：getLeft(),getTop(),getRight(),getBottom()<br>getTop：获取到的是view自身的顶边到其父布局顶边的距离<br>getLeft：获取到的是view自身的左边到其父布局左边的距离<br>getRight：获取到的是view自身的右边到其父布局左边的距离<br>getBottom：获取到的是view自身的底边到其父布局顶边的距离<br>2.view获取自身宽高：getHeight(),getWidth()<br>3.motionEvent获取坐标：getX(),getY(),getRawX(),getRawY()<br>getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离<br>getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离<br>getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离<br>getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离</p><p>2.计算控件左上角坐标,当按下控件移动的时候,计算偏移距离,重新绘制</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SimpleView extends View {    //创建画笔    private Paint mPaint;    private RectF oval;    //事件处理    private EventHandle mEventHandle;    //鼠标按下位置    private int startX,startY;    //按下鼠标时控件的位置    private int startLeft,startTop;    //状态栏高度    int statusHeight = 0;    public SimpleView(Context context) {        this(context,null);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs,0);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init();    }     private void init(){        mPaint = new Paint();        //设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。        mPaint.setAntiAlias(true);        mPaint.setTextSize(30.0f);        oval=new RectF();        mEventHandle=null;        startY=startX=0;        int resourceId = this.getResources().getIdentifier("status_bar_height", "dimen", "android");        if (resourceId &gt; 0) {            statusHeight = this.getResources().getDimensionPixelSize(resourceId);        }    }     @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        int widthMode = MeasureSpec.getMode(widthMeasureSpec);        int widthSize = MeasureSpec.getSize(widthMeasureSpec);        int heightMode = MeasureSpec.getMode(heightMeasureSpec);        int heightSize = MeasureSpec.getSize(heightMeasureSpec);        switch (widthMode) {            case MeasureSpec.EXACTLY:                //精确值模式，当控件的layout_width和layout_height属性指定为具体数值或match_parent时。                break;            case MeasureSpec.AT_MOST:                //最大值模式，当空间的宽高设置为wrap_content时。                break;            case MeasureSpec.UNSPECIFIED:                //未指定模式，View想多大就多大，通常在绘制自定义View时才会用。                break;        }        //取最小边为控件的宽高的最小值        int minWidth=widthSize&gt;heightSize?heightSize:widthSize;        setMeasuredDimension(minWidth,minWidth);    }      @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        mPaint.setColor(Color.GRAY);        // FILL填充, STROKE描边,FILL_AND_STROKE填充和描边        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);        int with = getWidth();        int height = getHeight();        float radius = with / 2-5;        canvas.drawCircle(with / 2, with / 2, radius, mPaint);        mPaint.setColor(Color.RED);        oval.set(with / 2 - radius, with / 2 - radius, with / 2                + radius, with / 2 + radius);//用于定义的圆弧的形状和大小的界限        int sweepAngle=120;        canvas.drawArc(oval, 0, -sweepAngle, true, mPaint);  //根据进度画圆弧        double percent=sweepAngle/360.0;        //设置文本颜色        mPaint.setColor(Color.WHITE);        //绘制文本百分比数据        canvas.drawText(String.format("%.2f",percent)+"%",(float)(with/2+radius*Math.cos(sweepAngle*Math.PI/360)/4)                ,(float)(with/2-radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);        canvas.drawText(String.format("%.2f",1-percent)+"%",(float)(with/2-radius*Math.cos(sweepAngle*Math.PI/360))                ,(float)(with/2+radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);    }     @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction())        {            case MotionEvent.ACTION_DOWN:                 startX=(int)event.getRawX();                startY=(int)event.getRawY();                startLeft=(int)(startX-event.getX());                /**                 * 这里startTop计算有些偏离，原因在于计算时加入了标题栏和状态栏的高度                 * 注意：要是你的Activity没有去掉标题栏，这里还要去掉标题栏的高度                 */                startTop= (int)(startY-event.getY())-statusHeight;//减去状态栏高度                break;            case MotionEvent.ACTION_MOVE:                if(mEventHandle!=null)                {                    mEventHandle.onTouchEvent(event);                }else{                    int disX=(int)event.getRawX()-startX;//计算偏移的X坐标                    int disY=(int)event.getRawY()-startY;//计算偏移的Y坐标;                    int left=startLeft+disX;                    int top=startTop+disY;                    //更新控件位置                    layout(left,top,left+getWidth(),top+getHeight());                }                break;            case MotionEvent.ACTION_UP:                break;        }        //返回true表示不消耗此事件，事件继续传递，返回flase表示事件消耗        return true;    }     public void setmEventHandle(EventHandle mEventHandle) {        this.mEventHandle = mEventHandle;    }     interface EventHandle{        public void onTouchEvent(MotionEvent event);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>XML文件中添加:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;com.example.myapplication.SimpleView  android:layout_width="150dp"  android:layout_height="150dp"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意:MainActivity需要将标题栏去掉,否则拖动的时候会出现偏差,在onCreate中添加</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">requestWindowFeature(Window.FEATURE_NO_TITLE);//去掉标题栏/*  requestWindowFeature(Window.FEATURE_NO_TITLE)无效解决方法：  正常情况下requestWindowFeature(Window.FEATURE_NO_TITLE)是可以生效的，  但是当Activity继承子AppCompatActivity的时候,这个就失效了   解决办法：  1、手动在oncreate里调用hide()  if (getSupportActionBar() != null){     getSupportActionBar().hide();  }*/if (getSupportActionBar() != null){    getSupportActionBar().hide();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/customviewLayout.git">自定义控件</a>,仅供参考.</p><h5 id="手机号码正则表达式"><a href="#手机号码正则表达式" class="headerlink" title="手机号码正则表达式"></a>手机号码正则表达式</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$ public static final String REGEX_MOBILE_EXACT =   "^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\\d{8}$";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="Android单位转换工具类"><a href="#Android单位转换工具类" class="headerlink" title="Android单位转换工具类"></a>Android单位转换工具类</h5><p>如果要在代码里直接填写尺寸，一般是px，如果要做好屏幕适配，我们通常使用dp作为单位</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SizeUtils {    public static int dip2px(Context context,float dpValue) {        float scale = context.getResources().getDisplayMetrics().density;        return (int) (dpValue * scale + 0.5f);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取屏幕尺寸"><a href="#获取屏幕尺寸" class="headerlink" title="获取屏幕尺寸"></a>获取屏幕尺寸</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.content.Context;import android.graphics.Point;import android.view.WindowManager;public class SizeUtils {    public static Point getScreenSize(Context context) {        Point point = new Point();        ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(point);        return point;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
