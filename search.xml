<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android四大组件之服务</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之Activity</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之广播</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之内容提供者</title>
      <link href="/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/"/>
      <url>/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开源库之Jetpack</title>
      <link href="/liaojie.github.io/2021/10/20/jetpack/"/>
      <url>/liaojie.github.io/2021/10/20/jetpack/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Lj’Blog! In this page,we will learn Android together.<br>If you have some trouble, you can send me an e-mail. I will try my best to help you.<br>This is my <a href="https://github.com/liaojie1314">github website</a>. </p><h2 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h2><p>什么是Jetpack?<br>Jetpack 是一个丰富的组件库,它的组件库按类别分为 4 类,分别是架构（Architecture）、界面（UI）、行为（behavior）和基础（foundation）.每个组件都可以单独使用,也可以配合在一起使用.每个组件都给用户提供了一个标准,能够帮助开发者遵循最佳做法,减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者能够集中精力编写重要的业务代码.</p><pre class="line-numbers language-官方" data-language="官方"><code class="language-官方">Jetpack 是一个由多个库组成的套件,可帮助开发者遵循最佳做法、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者可将精力集中于真正重要的编码工作.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>优点:<br>1.体现了单一原则<br>2.分层清晰<br>3.不需要非常依赖Activity<br>4.旋转数据不会丢失<br>…</p><p><a href="https://developer.android.google.cn/jetpack">官方文档</a></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>以注重生命周期的方式管理界面相关的数据(管理UI数据)</p><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>source:</p><p>1.首先定义一个LiveData实例</p><p>2.观察LiveData数据变化,变化时将数据展示到TextView上</p><p>3.改变LiveData里面的数据,数据变化时会回调onChanged()方法</p><p>在底层数据库更改时通知视图(感应改变数据),UI刷新(LiveData+DataBinding)</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MainViewModel extend /*ViewModel*/AndroidViewModel{  //ViewModel 无环境  //AndroidViewModel 有环境 需重写构造函数  private Context context;  public MainViewModel(@NonNull Application application)  {    super(application);    context = application;  }private MutableLiveData&lt;String&gt;info(){info.setValue("");//默认值return info;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>//DataBinding的引入(在build.gradle(:app)中添加):</p><pre class="line-numbers language-gradle(:app)" data-language="gradle(:app)"><code class="language-gradle(:app)">方式一:  dataBinding{  enabled true  }方式二:  dataBinding.enabled=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加后需同步<br>使用:(整个布局交给DataBinding管理)</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;!-- 和类交互 --&gt;    &lt;data&gt;          &lt;variable               name="name"               type="包名+类名"/&gt;    &lt;/data&gt;      //使用:android:text="@{name.info}"      //android:onClick="@{()-&gt;name.function(value)}"           所有布局...&lt;/Layout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MainActivity需要做绑定工作</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private ActivityMainBinding binding;private MainViewModel mainViewModel;//onCreate中添加binding = DataBindingUtil.setContentView(this,R.layout.activity_main);//AndroidViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(MainViewModel.class);//ViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()).get(MainViewModel.class);//绑定工作binding.setName(mainViewModel);//建立感应binding.setLifecycleOwner(this);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：非Activity启动需要加标记.</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Intent intent = new Intent();intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Jetpack+MVVM : Google标准化Jetpack架构模式(强力推荐)</p><p>MVVM、MVC、MVP:<br>MVC:<br>  创建过程:C-&gt;M+V<br>  优点:分离了Model和Controller<br>  缺点:Controller变得复杂<br>  建议:用于简单的、不大修改的页面<br>MVP:<br>  创建过程:C-&gt;P-&gt;M<br>  优点:在MVC的基础上,通过Interface彻底分离了View和Model<br>  缺点:Presenter与View的交互会琐碎而复杂<br>  建议:核心、复杂、需求变得快页面<br>MVVM:<br>  创建过程:C-&gt;VM-&gt;M<br>  优点:在MVP的基础上增加了DataBinding,代码量更小<br>  缺点:XML中包含代码<br>  建议:核心、复杂、需求变得快页面</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C language</title>
      <link href="/liaojie.github.io/2021/10/19/c/"/>
      <url>/liaojie.github.io/2021/10/19/c/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Lj’Blog! In this page,we will learn C language together.<br>If you have some trouble, you can send me an e-mail. I will try my best to help you.<br>This is my <a href="https://github.com/liaojie1314">github website</a>. </p>]]></content>
      
      
      <categories>
          
          <category> C language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发之自定义控件</title>
      <link href="/liaojie.github.io/2021/10/11/android/"/>
      <url>/liaojie.github.io/2021/10/11/android/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Lj’Blog! In this page,we will learn Android together.<br>If you have some trouble, you can send me an e-mail. I will try my best to help you.<br>This is my <a href="https://github.com/liaojie1314">github website</a>. </p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><pre class="line-numbers language-none"><code class="language-none">$ 自定义组合控件  继承自ViewGroup,比如说LinearLayout/RealativeLayout/FrameLayout--&gt;定义相关属性,获取相关属性  --&gt;加载组合的View/根据属性调整UI--&gt;处理相关事件/根据属性去处理数据--&gt;定义功能接口,对外暴露接口方法  --&gt;处理事件/数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ 自定义ViewGroup  继承自ViewGroup--&gt;定义相关属性,获取相关属性--&gt;把子View添加进来--&gt;测量:测量孩子,测量自己(覆写onMeasure方法)  --&gt;布局Layout--&gt;定义功能接口--&gt;处理事件和数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ 自定义view  继承自View--&gt;定义相关属性,获取相关属性--&gt;测量自己--&gt;创建相关画笔--&gt;覆写onDraw方法,绘制相关内容  --&gt;定义功能接口--&gt;处理相关事件和数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="属性添加"><a href="#属性添加" class="headerlink" title="属性添加"></a>属性添加</h3><p>1.声明属性名称和值的类型<br>在res/values文件下新建一个属性xml文件,如attrs.xml,然后在属性文件里添加<declare-styleable>标签,并声明属性</declare-styleable></p><pre class="line-numbers language-attrs" data-language="attrs"><code class="language-attrs">&lt;declare-styleable name="InputNumberView"&gt;    &lt;attr name="max" format="integer" /&gt;    &lt;attr name="min" format="integer" /&gt;    &lt;attr name="step" format="integer" /&gt;    &lt;attr name="defaultValue" format="integer" /&gt;    &lt;attr name="disable" format="boolean" /&gt;    &lt;attr name="btnBackground" format="reference" /&gt;    &lt;attr name="valueSize" format="dimension" /&gt;    &lt;attr name="function" format="flags"&gt;        &lt;flag name="delete" value="0x30"/&gt;        &lt;flag name="read" value="0x50"/&gt;        &lt;flag name="top" value="0x03"/&gt;    &lt;/attr&gt;&lt;/declare-styleable&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer，比如说行数，TextView的maxLine，就是Integer类型<br>enum，枚举类型，比如说left,top,bottom,center,right这些是枚举类型<br>boolean，布尔类型，比如说layout_alignParentRight<br>dimension，尺寸比如说size,margin_left这些，单位为px,dp,sp这些<br>color，颜色，比如说background，比如说textColor<br>flags，标记，比如说activity声明周期时的configChanges，gravity<br>float，浮点数，也就是小数，比如说透明度alpha<br>fraction，百分数，比如说动画的开始位置，fromDx<br>refrence，引用，比如说background，src，但background可以是color又可以是refrence，其实是可以多个，比如说：name=”switch_time” format=”integer|float”，可以是Integer类型，或者float类型<br>string，比如说text</p><p>2.获取属性值</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$  TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.looper_style);   //从TypedArray中读取属性值   //......   //如：a.getColor(R.styleable.KeypadView_numberColor, context.getResources().getColor(R.color.white));   a.recycle();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.属性的获取</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">$ app:itemMargin="4dp"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义控件基本绘制原理"><a href="#自定义控件基本绘制原理" class="headerlink" title="自定义控件基本绘制原理"></a>自定义控件基本绘制原理</h3><p>View的绘制基本上由measure()、layout()、draw()三个函数完成<br>1.测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void measure(int widthMeasureSpec, int heightMeasureSpec)  protected final void setMeasuredDimension(int measuredWidth, int measuredHeight)  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>measure调用onMeasure,onMeasure测量宽度、高度然后调用setMeasureDimension保存测量结果,measure,setMeasureDimension是final类型,view的子类不需要重写,onMeasure在view的子类中重写.<br>关于MeasureSpec的三个值：</p><p>(1) UPSPECIFIED ：未指定模式，父容器对于子容器没有任何限制,子容器想要多大就多大，通常在绘制自定义View时才会用</p><p>(2) EXACTLY：精确值模式，父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间，当控件的layout_width和layout_height属性指定为具体数值或match_parent时为该模式。</p><p>(3) AT_MOST：最大值模式，子容器可以是声明大小内的任意大小，当空间的宽高设置为wrap_content时为该模式</p><p>2.布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void layout(int l, int t, int r, int b)protected boolean setFrame(int left, int top, int right, int bottom)protected void onLayout(boolean changed, int left, int top, int right, int bottom)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>layout通过调用setFrame（l,t,r,b），l,t,r,b即子视图在父视图中的具体位置，onLayout一般只会在自定义ViewGroup中才会使用</p><p>3.绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void draw(Canvas canvas)protected void onDraw(Canvas canvas)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过调用draw函数进行视图绘制,在View类中onDraw函数是个空函数,最终的绘制需求需要在自定义的onDraw函数中进行实现,比如ImageView完成图片的绘制,如果自定义ViewGroup这个函数则不需要重载.</p><h3 id="给自定义控件添加事件"><a href="#给自定义控件添加事件" class="headerlink" title="给自定义控件添加事件"></a>给自定义控件添加事件</h3><p>1.获取自定义控件坐标<br>1.view获取自身坐标：getLeft(),getTop(),getRight(),getBottom()<br>getTop：获取到的是view自身的顶边到其父布局顶边的距离<br>getLeft：获取到的是view自身的左边到其父布局左边的距离<br>getRight：获取到的是view自身的右边到其父布局左边的距离<br>getBottom：获取到的是view自身的底边到其父布局顶边的距离<br>2.view获取自身宽高：getHeight(),getWidth()<br>3.motionEvent获取坐标：getX(),getY(),getRawX(),getRawY()<br>getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离<br>getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离<br>getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离<br>getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离</p><p>2.计算控件左上角坐标,当按下控件移动的时候,计算偏移距离,重新绘制</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SimpleView extends View {    //创建画笔    private Paint mPaint;    private RectF oval;    //事件处理    private EventHandle mEventHandle;    //鼠标按下位置    private int startX,startY;    //按下鼠标时控件的位置    private int startLeft,startTop;    //状态栏高度    int statusHeight = 0;    public SimpleView(Context context) {        this(context,null);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs,0);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init();    }     private void init(){        mPaint = new Paint();        //设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。        mPaint.setAntiAlias(true);        mPaint.setTextSize(30.0f);        oval=new RectF();        mEventHandle=null;        startY=startX=0;        int resourceId = this.getResources().getIdentifier("status_bar_height", "dimen", "android");        if (resourceId &gt; 0) {            statusHeight = this.getResources().getDimensionPixelSize(resourceId);        }    }     @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        int widthMode = MeasureSpec.getMode(widthMeasureSpec);        int widthSize = MeasureSpec.getSize(widthMeasureSpec);        int heightMode = MeasureSpec.getMode(heightMeasureSpec);        int heightSize = MeasureSpec.getSize(heightMeasureSpec);        switch (widthMode) {            case MeasureSpec.EXACTLY:                //精确值模式，当控件的layout_width和layout_height属性指定为具体数值或match_parent时。                break;            case MeasureSpec.AT_MOST:                //最大值模式，当空间的宽高设置为wrap_content时。                break;            case MeasureSpec.UNSPECIFIED:                //未指定模式，View想多大就多大，通常在绘制自定义View时才会用。                break;        }        //取最小边为控件的宽高的最小值        int minWidth=widthSize&gt;heightSize?heightSize:widthSize;        setMeasuredDimension(minWidth,minWidth);    }      @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        mPaint.setColor(Color.GRAY);        // FILL填充, STROKE描边,FILL_AND_STROKE填充和描边        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);        int with = getWidth();        int height = getHeight();        float radius = with / 2-5;        canvas.drawCircle(with / 2, with / 2, radius, mPaint);        mPaint.setColor(Color.RED);        oval.set(with / 2 - radius, with / 2 - radius, with / 2                + radius, with / 2 + radius);//用于定义的圆弧的形状和大小的界限        int sweepAngle=120;        canvas.drawArc(oval, 0, -sweepAngle, true, mPaint);  //根据进度画圆弧        double percent=sweepAngle/360.0;        //设置文本颜色        mPaint.setColor(Color.WHITE);        //绘制文本百分比数据        canvas.drawText(String.format("%.2f",percent)+"%",(float)(with/2+radius*Math.cos(sweepAngle*Math.PI/360)/4)                ,(float)(with/2-radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);        canvas.drawText(String.format("%.2f",1-percent)+"%",(float)(with/2-radius*Math.cos(sweepAngle*Math.PI/360))                ,(float)(with/2+radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);    }     @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction())        {            case MotionEvent.ACTION_DOWN:                 startX=(int)event.getRawX();                startY=(int)event.getRawY();                startLeft=(int)(startX-event.getX());                /**                 * 这里startTop计算有些偏离，原因在于计算时加入了标题栏和状态栏的高度                 * 注意：要是你的Activity没有去掉标题栏，这里还要去掉标题栏的高度                 */                startTop= (int)(startY-event.getY())-statusHeight;//减去状态栏高度                break;            case MotionEvent.ACTION_MOVE:                if(mEventHandle!=null)                {                    mEventHandle.onTouchEvent(event);                }else{                    int disX=(int)event.getRawX()-startX;//计算偏移的X坐标                    int disY=(int)event.getRawY()-startY;//计算偏移的Y坐标;                    int left=startLeft+disX;                    int top=startTop+disY;                    //更新控件位置                    layout(left,top,left+getWidth(),top+getHeight());                }                break;            case MotionEvent.ACTION_UP:                break;        }        //返回true表示不消耗此事件，事件继续传递，返回flase表示事件消耗        return true;    }     public void setmEventHandle(EventHandle mEventHandle) {        this.mEventHandle = mEventHandle;    }     interface EventHandle{        public void onTouchEvent(MotionEvent event);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>XML文件中添加:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;com.example.myapplication.SimpleView  android:layout_width="150dp"  android:layout_height="150dp"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意:MainActivity需要将标题栏去掉,否则拖动的时候会出现偏差,在onCreate中添加</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">requestWindowFeature(Window.FEATURE_NO_TITLE);//去掉标题栏/*  requestWindowFeature(Window.FEATURE_NO_TITLE)无效解决方法：  正常情况下requestWindowFeature(Window.FEATURE_NO_TITLE)是可以生效的，  但是当Activity继承子AppCompatActivity的时候,这个就失效了   解决办法：  1、手动在oncreate里调用hide()  if (getSupportActionBar() != null){     getSupportActionBar().hide();  }*/if (getSupportActionBar() != null){    getSupportActionBar().hide();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/customviewLayout.git">自定义控件</a>,仅供参考.</p><h1 id="手机号码正则表达式"><a href="#手机号码正则表达式" class="headerlink" title="手机号码正则表达式"></a>手机号码正则表达式</h1><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$ public static final String REGEX_MOBILE_EXACT =   "^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\\d{8}$";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Android单位转换工具类"><a href="#Android单位转换工具类" class="headerlink" title="Android单位转换工具类"></a>Android单位转换工具类</h1><p>如果要在代码里直接填写尺寸，一般是px，如果要做好屏幕适配，我们通常使用dp作为单位</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$ public class SizeUtils {    public static int dip2px(Context context,float dpValue) {        float scale = context.getResources().getDisplayMetrics().density;        return (int) (dpValue * scale + 0.5f);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
