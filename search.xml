<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android启动页</title>
      <link href="/liaojie.github.io/2021/11/10/android-qi-dong-ye/"/>
      <url>/liaojie.github.io/2021/11/10/android-qi-dong-ye/</url>
      
        <content type="html"><![CDATA[<p>Android中几乎所有app都有启动页这一基本功能,但是用途都不相同。<br>有的app的启动页用于加载广告,有的启动页用于加载后台,一旦后台数据加载好了才把启动页去了,不过想来很多app是两者兼顾的。<br>需求:</p><ul><li>展示 logo 页面3秒</li><li>服务端可以控制是否播放广告</li><li>服务端可以控制播放广告的秒数</li><li>服务端可以控制广告的内容（图片）和广告详情页面的链接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/splash.png"></p><p>注意:从服务端请求数据是在展示 3 秒启动页的时候获取的</p><h3 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h3><p>启动包括冷启动和热启动:</p><ul><li>冷启动：是指进程从无到有的过程。因为要进行页面初始化,所以相对其他两个启动方式,消耗的时间是相对比较多的。</li><li>热启动：是指之前的进程还在,在之前进程的基础上创建 Activity 的过程,耗时相对少一点。<br>　　我们可以通过 Activity 的 theme 来修改这个白屏所显示的界面。根据上面的需求,我们需要显示3秒 logo 的页面。那么我们干脆将我们的logo设置为背景图就行了。</li></ul><p>新建一个activity为SplashActivity,其对应布局文件为activity_splash.xml<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/newEmptyActivity.png"><br>并在AndroidManifest.xml中将SplashActivity设置为主入口:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;activity android:name=".MainActivity"&gt;&lt;/activity&gt;&lt;activity android:name=".SplashActivity"    android:theme="@style/Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;    &lt;intent-filter&gt;        &lt;action android:name="android.intent.action.MAIN" /&gt;        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在values中的themes.xml中添加:<br><img src="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/themes.png"></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;style name="Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;//取消Actionbar    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;    &lt;item name="android:windowFullscreen"&gt;true&lt;/item&gt;//设置全屏    &lt;item name="android:windowBackground"&gt;@drawable/splash&lt;/item&gt;//设置背景图片&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在AndroidManifest.xml中需要主题的Activity添加:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.splashactivity"&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.SplashActivity"&gt;        &lt;activity android:name=".MainActivity"&gt;        &lt;/activity&gt;        &lt;activity android:name=".SplashActivity"            android:theme="@style/Theme.AppCompat.NoActionBar.NoActionBarWithBackGround"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SplashActivity:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.WindowManager;public class SplashActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);//隐藏状态栏        //getSupportActionBar().hide();//隐藏标题栏        setContentView(R.layout.activity_splash);        Thread myThread = new Thread() {//创建子线程            @Override            public void run() {                try {                    sleep(5000);//使程序休眠五秒                    Intent intent = new Intent(getApplicationContext(), MainActivity.class);//启动MainActivity                    startActivity(intent);                    finish();//关闭当前活动                } catch (Exception e) {                    e.printStackTrace();                }            }        };        myThread.start();//启动线程    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="广告页"><a href="#广告页" class="headerlink" title="广告页"></a>广告页</h3><p>广告页我尝试过两种方式：<br>1.glide 加载<br>2.通过下载文件，然后再加载<br>如果使用glide加载广告图片,如果网络比较差,会存在广告页面空白的情况,因为使用 glide 无法判断在 3 秒展示 logo 的页面是否加载好了广告图片。这给用户的体验是比较差的,也是不太友好的,因为用户在空白界面拜拜等待了 3 秒。所以后面使用了将广告图片下载到本地的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之服务</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-fu-wu/</url>
      
        <content type="html"><![CDATA[<p>Service是Android 系统中的四大组件之一,它跟Activity的级别差不多,但不能页面显示只能后台运行,并且可以和其他组件进行交互.service可以在很多场合的应用中使用,比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放,比如检测SD卡上文件的变化,再或者在后台记录你地理信息位置的改变等等,总之服务总是藏在后台的.例如,一个service可能处理网络事物、播放音乐、执行文件I/O,或与一个内容提供者交互,所有这些都在后台进行.<br>我们一定要知道的是这里Service的后台运行并不是子线程.Service的运行是在主线程中进行的,只是它没有界面显示而已,它的耗时操作同样需要开启子线程,否者会跟Activity一样出现ANR(application not response–程序没有响应).</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之Activity</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-activity/</url>
      
        <content type="html"><![CDATA[<p>Activity是Android的四大组件之一.是用户操作的可视化界面,它为用户提供了一个完成操作指令的窗口.当我们创建完毕Activity之后,需要调用setContentView()方法来完成界面的显示以此来为用户提供交互的入口.在Android App中只要能看见的几乎都要依托于Activity,所以Activity是在开发中使用最频繁的一种组件.</p><h5 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h5><p>在Android中会维持一个Activity Stack(Activity栈),当一个新的Activity创建时,它就会放到栈顶,这个Activity就处于运行状态.当再有一个新的Activity被创建后会重新压人栈顶,而之前的Activity则会在这个新的Activity底下.而之前的Activity就会进入后台.<br>一个Activity实质上有四种状态：</p><p>1.运行中(Running/Active):这时Activity位于栈顶,是可见的,并且可以用户交互.<br>2.暂停(Paused):当Activity失去焦点,不能跟用户交互了,但依然可见,就处于暂停状态.当一个新的非全屏的Activity或者一个透明的Activity放置在栈顶,Activity就处于暂停状态,这个时候Activity的各种数据还被保持着.只有在系统内存在极低的状态下,系统才会自动的去销毁Activity.<br>3.停止(Stoped):当一个Activity被另一个Activity完全覆盖,或者点击HOME键退入了后台,这时候Activity处于停止状态.这里有些是跟暂停状态相似的,这个时候Activity的各种数据还被保持着,当系统的别的地方需要用到内容时,系统会自动的去销毁Activity.<br>4.销毁(Detroyed):当我们点击返回键或者系统在内存不够用的情况下就会把Activity从栈里移除销毁,被系统回去.这时候,Activity处于销毁状态.</p><p><img src="/liaojie.github.io/medias/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity的生命周期"></p><p>onCreate:当Activity第一次被创建时调用.是生命周期开始的第一个方法.在这里我们可以做一些初始化的操作,比如:调用setContentView()方法去加载界面,绑定布局里的一些控件,初始化一些Activity需要用到的数据.之后会调用onStart方法.</p><p>onStart:当Activity正在变为可见时调用.这个时候Activity已经可见了,但是还没有出现在前台还不能跟用户交互.可以简单理解为Actvity已经可见但是还没有出现在前台.之后会调用onResume.</p><p>onResume:当Activity可以跟用户交互时调用.这个时候这个Activity位于栈的顶部,跟onStart相比,它们都是表示Activity已经可见,但是onStart调用时Activity还在后台,而调用onResume时,Activity已经进入了前台,可以跟用户交互了.之后会调用 onPause.</p><p>onPause:当Activity暂停时调用这个方法,在这里我们可以用来保存数据,关闭动画和其它比较耗费CPU的操作,但是在这里做的操作绝对不能耗时,因为如果当前Activity要启动一个新的Activity,这个新的Activity会在当前Activity执行完毕onPause之后才能进入可见状态.这个方法之后一般会调用的方法有onStop或者onResume.</p><p>onStop:当Activity进入后台,并且不会被用户看到时调用.当别的Activity出现在前台时,或者Activity会被销毁时,调用此方法.在这个方法调用之后,系统可能会在内存不够的情况下回收Activity.在这个方法之后一般会调用onRestart或者onDestroy.</p><p>onDestroy:这个方法是Activity生命周期中调用的最后一个方法.它会在Activity被销毁之前调用,Activity销毁原因一般是我们调用Activity的finish方法手动销毁,另一个就是系统在内存紧张的情况下去销毁Activity,以用来节省空间.我们可以通过方法 isFinishing 来判断Activity是否正在被销毁.</p><p>onRestart:这个方法是在Activity处于停止状态后,又回到可视状态时调用.之后会调用onResume.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之广播</title>
      <link href="/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/"/>
      <url>/liaojie.github.io/2021/10/24/android-si-da-zu-jian-zhi-guang-bo/</url>
      
        <content type="html"><![CDATA[<p>在Android中,Broadcast是一种广泛运用的在应用程序之间传输信息的机制.我们拿广播电台来做个比方.我们平常使用收音机收音是这样的:许许多多不同的广播电台通过特定的频率来发送他们的内容,而我们用户只需要将频率调成和广播电台的一样就可以收听他们的内容了.Android中的广播机制就和这个是差不多的道理.</p><p>1.电台发送的内容是语音,而在Android中我们要发送的广播内容是一个Intent.这个Intent中可以携带我们要传送的数据.</p><p>2.电台通过大功率的发射器发送内容，而在Android中则是通过sendBroadcast这个方法来发送（很形象的名字吧）。       </p><p>3.用户通过调整到具体的电台频率接受电台的内容.而在Android中要接受广播中的内容则是通过注册一个BroadCastReceiver来接收的.只有发送广播的action和接收广播的action相同,接受者才能接受这个广播. </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件之内容提供者</title>
      <link href="/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/"/>
      <url>/liaojie.github.io/2021/10/23/android-si-da-zu-jian-zhi-nei-rong-ti-gong-zhe/</url>
      
        <content type="html"><![CDATA[<p>ContentProvider(内容提供者)作为Android中的四大组件之一,但是在一般的开发中,使用比较少.ContentProvider为不同的软件之间数据共享提供统一的接口.而且ContentProvider是以类似数据库中表的方式将数据暴露,也就是说ContentProvider就像一个”数据库”.那么外界获取其提供的数据,也就应该与从数据库中获取数据的操作基本一样,只不过是采用URI来表示外界需要访问的”数据库”.至于如何从URI中识别出外界需要的是哪个”数据库”,这就是Android底层需要做的事情了.也就是说,如果我们想让其他的应用使用我们自己程序内的数据,就可以使用ContentProvider定义一个对外开放的接口,从而使得其他的应用可以使用我们自己应用中的文件、数据库内存储的信息.当然,自己开发的应用需要给其他应用共享信息的需求可能比较少见,但是在Android系统中,很多数据如:联系人信息、短信信息、图片库、音频库等,这些信息在开发中还是经常用到的,这些信息谷歌工程师已经帮我们封装好了,我们可以使用谷歌给我的Uri去直接访问这些数据.所以对于ContentProvider我们还是需要认真的学习的,在遇到获取联系人信息,图片库,音视频库等需求的时候,才能更好的实现功能.</p><h5 id="内容提供者应用场景"><a href="#内容提供者应用场景" class="headerlink" title="内容提供者应用场景"></a>内容提供者应用场景</h5><p>1.向日历里插入提醒事件</p><blockquote><p>举个例子,比如说你是淘宝app,里面有一个开团的活动,用户需要添加开团提醒,你就需要向闹钟或者日历里添加一个事件.</p></blockquote><p>2.微信/QQ/支付宝获取通讯录里的联系人</p><blockquote><p>微信,QQ,支付宝这些应用,获取通讯录里的联系人,然后向你推荐好友,就是通过内容提供者获取到通讯录信息的.</p></blockquote><p>3.媒体库</p><blockquote><p>Android的媒体库,也是一个内容提供者.比如说你微信要发朋友圈,或者你的应用要上传图片,获取系统里的图片内容视频内容,可以通过内容提供者来获取.</p></blockquote><p>4.广告精准推送</p><blockquote><p>你浏览过什么东西,搜索过什么关键字.你去上淘宝、头条之类的就会给你推荐,它们之间也可以通过内容提供者来提供数据,只要双方把利益问题处理好就行.</p></blockquote><p>5.短信备份</p><blockquote><p>短信也有内容提供者,而第三方备份工具则是通过内容提供者去获取短信内容的.</p></blockquote><h2 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h2><p>继承ContentProvider,然后实现里面是方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//创建@Overridepublic boolean onCreate() {    return false;}//查询@Nullable@Overridepublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {    return null;}@Nullable@Overridepublic String getType(@NonNull Uri uri) {    return null;}@Nullable@Overridepublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {    return null;}@Overridepublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {    return 0;}@Overridepublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Manifest中注册</p><pre class="line-numbers language-AndroidManifest" data-language="AndroidManifest"><code class="language-AndroidManifest">&lt;providerandroid:exported="true"    android:name=".provider.UserProvider"    android:authorities="com.example.contentprovider"/&gt;//一般填写包名,可添加多个,用";"隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将数据库暴露出去,给别人操作</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private UserDatabaseHelper mUserDatabaseHelper = null;//校验URI的工具类,定义为静态,因为我们需要添加一些规则//UriMatcher.NO_MATCH 当不匹配的时候的一个返回值private static UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);//弱匹配之后的返回值private static UriMatcher sUriMatcher=new UriMatcher(UriMatcher.NO_MATCH);//添加规则static {    sUriMatcher.addURI("com.example.contentprovider",null,USER_MATCH_CODE);//第二个参数为path}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在onCreate是创建DatabaseHelper</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">mUserDatabaseHelper=new UserDatabaseHelper(getContext());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询-query"><a href="#查询-query" class="headerlink" title="查询(query):"></a>查询(query):</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int result = sUriMatcher.match(uri);if (result == USER_MATCH_CODE) {    //匹配规则    SQLiteDatabase db = mUserDatabaseHelper.getReadableDatabase();    Cursor cursor = db.query(Constants.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);    return cursor;} else {    //不匹配规则    throw new IllegalArgumentException("参数错误");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:MainActivity相关为新创建的</p><p>activity_main.xml中加入获取数据的按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:id="@+id/query_btn"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="获取用户数据"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    android:onClick="getRemoteUser"    app:layout_constraintTop_toTopOf="parent"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainActivity中加入点击事件:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void getRemoteUser(View view) {    ContentResolver contentResolver = getContentResolver();    //path 为空content://com.example.contentprovider/path    Uri uri = Uri.parse("content://com.example.contentprovider");    // "http://":http协议;"tel://":电话    //query(uri,projection,selection,selectionArgs,sortOrder);    Cursor cursor = contentResolver.query(uri, null, null, null, null);//全为null,无条件查询String[] columnNames = cursor.getColumnNames();for (String columnName : columnNames) {    Log.d(TAG, "columnName == &gt;" +columnName);}while (cursor.moveToNext()) {Log.d(TAG, "=====================");    for (String columnName : columnNames) {        String value = cursor.getString(cursor.getColumnIndex(columnName));        Log.d(TAG, columnName + "====" + value);    }    Log.d(TAG, "=====================");}cursor.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入(insert):"></a>插入(insert):</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int result = sUriMatcher.match(uri);if (result == USER_MATCH_CODE) {    SQLiteDatabase db = mUserDatabaseHelper.getWritableDatabase();    long id = db.insert(Constants.TABLE_NAME, null, values);    //将规则里面的path改为user    Uri resultUri = Uri.parse("content://com.example.contentprovider/user/" + id);    //插入数据成功,数据已经变化,通知其它地方(谁监听就通知谁)    getContext().getContentResolver().notifyChange(resultUri,null);//observer可以填空,也可以new 一个出来    return resultUri;} else {    //不匹配规则    throw new IllegalArgumentException("参数错误");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>activity_main.xml中加入获取数据的按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:onClick="addUser"    android:text="插入数据"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toBottomOf="@id/query_btn" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在MainActivity中加入添加数据的点击事件:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String FIELD_USER_NAME="userName";public static final String FIELD_PASSWORD ="password";public static final String FIELD_SEX ="sex";public static final String FIELD_AGE ="age";public void addUser(View view) {    ContentResolver contentResolver = getContentResolver();    Uri uri = Uri.parse("content://com.example.contentprovider/user");    ContentValues values=new ContentValues();    values.put(USER_SERVICE,"BillGates");    values.put(FIELD_PASSWORD,"123456");    values.put(FIELD_SEX,"male");    values.put(FIELD_AGE,59);    contentResolver.insert(uri,values);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MainActvity的onCreate中加入:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ContentResolver contentResolver = getContentResolver();Uri uri = Uri.parse("content://com.example.contentprovider");//notifyForDescendants:true表示content://com.example.contentprovider/xxx都能监听到;//false表示严格监听content://com.example.contentprovidercontentResolver.registerContentObserver(uri, true, new ContentObserver(new Handler()) {    //Handler用于post()    @Override    public void onChange(boolean selfChange) {        super.onChange(selfChange);        Log.d(TAG, "用户数据发生变化...");        //todo:获取新的内容    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例子1-动态获取权限读取日历表内容"><a href="#例子1-动态获取权限读取日历表内容" class="headerlink" title="例子1:动态获取权限读取日历表内容"></a>例子1:动态获取权限读取日历表内容</h2><h3 id="首先拿到contentResolver-然后获取URI"><a href="#首先拿到contentResolver-然后获取URI" class="headerlink" title="首先拿到contentResolver,然后获取URI"></a>首先拿到contentResolver,然后获取URI</h3><p>如何获取uri:可以看文档,也可以看源码<br><a href="https://github.com/TrillGates/CalendarProvider/blob/master/AndroidManifest.xml">安卓上层应用源码</a><br>找到下图位置:</p><p><img src="/liaojie.github.io/medias/calendarGithub.png"></p><p>搜索: static</p><p><img src="/liaojie.github.io/medias/calendarSource.png"></p><p>可以看出authority是:CalendarContract.AUTHORITY</p><p>添加authority常量:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String AUTHORITY = "com.android.calendar";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="找到path"><a href="#找到path" class="headerlink" title="找到path"></a>找到path</h3><p><img src="/liaojie.github.io/medias/path.png"></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void queryCalendars() {    ContentResolver contentResolver=getContentResolver();    //Uri uri=Uri.parse("content://"+"com.android.calender/"+"calenders");    Uri uri= CalendarContract.Calendars.CONTENT_URI;    Cursor query = contentResolver.query(uri, null, null, null, null);    String[] columnNames=query.getColumnNames();    while (query.moveToNext()){        Log.d(TAG, "==================================");        for (String columnName:columnNames){            Log.d(TAG, columnName+"==="+query.getString(query.getColumnIndex(columnName)));        }        Log.d(TAG, "===================================");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要在AndroidManifest中添加权限</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.calendarprovider"&gt;    &lt;!--添加的俩个权限--&gt;    &lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;    &lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.CalendarProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Android6.0之后需要动态获取权限</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final int PERMISSION_REQUEST_CODE=1;private void checkCalendarPermission() {    int readPermission = checkSelfPermission(Manifest.permission.READ_CALENDAR);    int writePermission = checkSelfPermission(Manifest.permission.WRITE_CALENDAR);    if (readPermission== PackageManager.PERMISSION_GRANTED&amp;&amp;writePermission==PackageManager.PERMISSION_GRANTED){        //表示有权限    }else {        Log.d(TAG, "requestPermissions...");        //用户点击了确定以后再去调用请求权限        //如果点击了就不再提示了,就不再获取了.如果不能使用,根据需求进行下一步        requestPermissions(new String[]{Manifest.permission.READ_CALENDAR,Manifest.permission.WRITE_CALENDAR},PERMISSION_REQUEST_CODE);    }}//接收结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode==PERMISSION_REQUEST_CODE){        //判断结果        if (grantResults.length==2&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED&amp;&amp;grantResults[1]==PackageManager.PERMISSION_GRANTED){            //有权限            Log.d(TAG, "has permission...");        }else {            Log.d(TAG, "no permission...");            //没权限            finish();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在checkCalendarPermission之前加上版本检查</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {    //Build.VERSION_CODES.M(public static final int M = 23;(Build.java))  6.0    checkCalendarPermission();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>执行queryCalendars();<br>插入事件需要使用的字段<br><img src="/liaojie.github.io/medias/%E5%B8%B8%E9%87%8F%E6%8F%8F%E8%BF%B0.png"></p><p>规则：<br>    1.您必须加入 CALENDAR_ID 和 DTSTART。<br>    2.您必须加入 EVENT_TIMEZONE。如需获取系统中已安装时区 ID 的列表，请使用 getAvailableIDs()。请注意，如果您按使Intent 插入事件中所述通过 INSERT Intent 插入事件，则此规则不适用 — 在该情形下，系统会提供默认时区。<br>    3.对于非重复事件，您必须加入 DTEND。<br>    4.对于重复事件，您必须加入 DURATION，以及 RRULE 或 RDATE。请注意，如果您按使用 Intent 插入事件中所述通过 INSERT Intent 插入事件，则此规则不适用 — 在该情形下，您可以将 RRULE 与 DTSTART 和 DTEND 结合使用，日历应用会自动将其转换为持续时间。</p><p>向日历中插入事件<br>    1.先通过前面的日历表，查询到日历的id，因为CALENDAR_ID是必须填写的<br>    2.必须要填写DTSTART和EVENT_TIMEZONE<br>    3.非重复事件，必须加入DTEND<br>    4.如果重复事件，则要加入DURATION，RRULE 或 RDATE</p><p>在UI里面添加一个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:onClick="addAlertEvent"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="添加提醒"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向日历中添加提醒事件"><a href="#向日历中添加提醒事件" class="headerlink" title="向日历中添加提醒事件"></a>向日历中添加提醒事件</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void addAlertEvent(View view) {    //前面查询出来的    long calID = 1;    //创建时间    Calendar beginTime = Calendar.getInstance();    //开始时间    //月从0开始    beginTime.set(2021, 1, 14, 5, 20);    long beginTimeMills = beginTime.getTimeInMillis();    //结束时间    Calendar endTime = Calendar.getInstance();    endTime.set(2021, 2, 14, 5, 20);    long endTimeMillis = endTime.getTimeInMillis();    //事件内容        String timeZone = TimeZone.getDefault().getID();    Log.d(TAG, "timeZone--&gt;" + timeZone);    ContentValues eventValues = new ContentValues();    //开始时间    eventValues.put(CalendarContract.Events.DTSTART, beginTimeMills);    //结束时间    eventValues.put(CalendarContract.Events.DTEND, endTimeMillis);    //日历ID    eventValues.put(CalendarContract.Events.CALENDAR_ID, calID);    //时间时区    eventValues.put(CalendarContract.Events.EVENT_TIMEZONE, timeZone);    //标题    eventValues.put(CalendarContract.Events.TITLE, "双十一购物狂欢开抢");    eventValues.put(CalendarContract.Events.EVENT_LOCATION, "重庆");    eventValues.put(CalendarContract.Events.DESCRIPTION, "买东西");    Uri eventUri = CalendarContract.Events.CONTENT_URI;    //Uri uri=Uri.parse("content://"+..);    ContentResolver contentResolver = getContentResolver();    Uri resultUri = contentResolver.insert(eventUri, eventValues);    String eventID = resultUri.getLastPathSegment();    Log.d(TAG, "eventID--&gt;" + eventID);    ContentValues reminderValues = new ContentValues();    Uri reminderUri = CalendarContract.Reminders.CONTENT_URI;    contentResolver.insert(reminderUri, reminderValues);    reminderValues.put(CalendarContract.Reminders.EVENT_ID, eventID);    reminderValues.put(CalendarContract.Reminders.MINUTES, 15);    reminderValues.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALARM);    Log.d(TAG, "resultUri--&gt;" + resultUri);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入提醒"><a href="#插入提醒" class="headerlink" title="插入提醒"></a>插入提醒</h3><p>以下是提醒表的字段：<br><img src="/liaojie.github.io/medias/remain.png"><br>规则：插入新提醒时，您必须加入以上所有字段</p><p>其他操作可参考<a href="https://developer.android.google.cn/guide/topics/providers/calendar-provider.html#top_of_page">Android日历官方文档</a></p><p><a href="https://github.com/liaojie1314/CalendarProvider">完整项目</a></p><h2 id="例子2-获取通讯录联系人数据介绍"><a href="#例子2-获取通讯录联系人数据介绍" class="headerlink" title="例子2:获取通讯录联系人数据介绍"></a>例子2:获取通讯录联系人数据介绍</h2><h3 id="在配置文件里声明内容提供者的权限"><a href="#在配置文件里声明内容提供者的权限" class="headerlink" title="在配置文件里声明内容提供者的权限"></a>在配置文件里声明内容提供者的权限</h3><p><a href="https://github.com/TrillGates/ContactsProvider">联系人内容提供者源码</a></p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.contactsprovider"&gt;    &lt;!--添加权限--&gt;    &lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.ContactsProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h3><p>首先是找到provider类， 或者从配置文件里找到注册的地方<br><img src="/liaojie.github.io/medias/providerGithub.png"></p><p>搜索静态代码块:static<br><img src="/liaojie.github.io/medias/providerSource.png"></p><p>ContactsContract.java的代码在framework里</p><p>设置ContactsContract.AUTHORITY常量:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String AUTHORITY = "com.android.contacts";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取数据表"><a href="#获取数据表" class="headerlink" title="获取数据表"></a>获取数据表</h3><p>raw_contacts:包含联系人数据摘要的行，针对特定用户帐户和类型。</p><p>mimetypes:数据类型描述表</p><p>data:数据表，存储号码、QQ、邮箱、昵称、图片。这些类型都在mimetypes里有。</p><p>所以如果我们要拿一个用户的数据,就应该是从raw_contacts里拿到id,再到data拿出数据,根据mimetype来判断数据的类型。</p><p>但是现在的android系统不是这样的了,也不直接给你读取mimetypes里的数据了。</p><p>得到URI:<br>content://com.android.contacts/data/phones</p><h3 id="创建Bean类-封装数据"><a href="#创建Bean类-封装数据" class="headerlink" title="创建Bean类,封装数据"></a>创建Bean类,封装数据</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class UserInfo {    private String id;    private String displayName;    private String phoneNum;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getDisplayName() {        return displayName;    }    public void setDisplayName(String displayName) {        this.displayName = displayName;    }    public String getPhoneNum() {        return phoneNum;    }    public void setPhoneNum(String phoneNum) {        this.phoneNum = phoneNum;    }    @Override    public String toString() {        return "UserInfo{" +                "id='" + id + '\'' +                ", displayName='" + displayName + '\'' +                ", phoneNum='" + phoneNum + '\'' +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="布局UI"><a href="#布局UI" class="headerlink" title="布局UI"></a>布局UI</h3><p>添加一个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Button    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="获取联系人信息"    android:onClick="getContactInfo"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintLeft_toLeftOf="parent"    app:layout_constraintRight_toRightOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.Manifest;import android.content.ContentResolver;import android.content.pm.PackageManager;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.provider.ContactsContract;import android.util.Log;import android.view.View;import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import java.util.ArrayList;import java.util.List;@RequiresApi(api = Build.VERSION_CODES.M)public class MainActivity extends AppCompatActivity {    private static final String TAG = "MainActivity";    public static final int PERMISSION_REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //getUserInfo();        checkContactReadPermission();    }    private void checkContactReadPermission() {        int readContactPermission = checkSelfPermission(Manifest.permission.READ_CONTACTS);        if (readContactPermission != PackageManager.PERMISSION_GRANTED) {            requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, PERMISSION_REQUEST_CODE);        }    }    public void getContactInfo(View view) {        getUserInfo();    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        if (requestCode == PERMISSION_REQUEST_CODE) {            if (grantResults.length == 1 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {                Log.d(TAG, "has permission...");            } else {                Log.d(TAG, "no permission...");            }        }    }    private void getUserInfo() {        ContentResolver cr = getContentResolver();        //Uri constantsUri=Uri.parse("content://com.android.contacts");        Uri rawContactUri = Uri.parse("content://" + ContactsContract.AUTHORITY + "/raw_contacts");        Cursor rawContactCursor = cr.query(rawContactUri, new String[]{"contact_id", "display_name"}, null, null, null);        //string[] columnNames = rawContactCursor.getColumnNames();        List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();        while (rawContactCursor.moveToNext()) {            UserInfo userInfo = new UserInfo();            userInfo.setId(rawContactCursor.getString(rawContactCursor.getColumnIndex("contact_id")));            userInfo.setDisplayName(rawContactCursor.getString(rawContactCursor.getColumnIndex("display_name")));            userInfos.add(userInfo);            //for (String columnName : columnNames) {            //      Log.d(TAG, columnName + " values--&gt;" + rawContactCursor.getString(rawContactCursor.getColumnIndex(columnName)));            // }        }        rawContactCursor.close();        Uri phoneUri = Uri.parse("content://" + ContactsContract.AUTHORITY + "/raw_contacts");        for (UserInfo userInfo : userInfos) {            //获取手机号码            Cursor phoneCursor = cr.query(phoneUri, new String[]{"data1"}, "raw_contact_id", new String[]{userInfo.getId()}, null);            if (phoneCursor.moveToNext()) {                userInfo.setPhoneNum(phoneCursor.getString(0).replace("-", ""));            }            phoneCursor.close();            Log.d(TAG, "UserInfo--&gt;" + userInfo);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/ContactsProvider">完整项目</a></p><h2 id="例子3-读取短信内容"><a href="#例子3-读取短信内容" class="headerlink" title="例子3:读取短信内容"></a>例子3:读取短信内容</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>provider地址:<br><a href="https://github.com/TrillGates/TelephonyProvider/blob/master/src/com/android/providers/telephony/SmsProvider.java">TelephonyProvider</a></p><p>搜索:static<br><img src="/liaojie.github.io/medias/phoneProviderSource.png"></p><p>得到Uri:<br>Uri uri = Uri.parse(“content://sms/“);</p><h3 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h3><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.example.smsprovider"&gt;    &lt;!--权限--&gt;    &lt;uses-permission android:name="android.permission.READ_SMS"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/Theme.SMSProvider"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!--VerifyCodeActivity注册--&gt;        &lt;activity android:name=".VerifyCodeActivity"&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态获取权限"><a href="#动态获取权限" class="headerlink" title="动态获取权限"></a>动态获取权限</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void checkSmsReadPermission() {    int permissionResultCode = checkSelfPermission(Manifest.permission.READ_SMS);    if (permissionResultCode!= PackageManager.PERMISSION_GRANTED){        requestPermissions(new String[]{Manifest.permission.READ_SMS},PERMISSION_REQUEST_CODE);    }}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode==PERMISSION_REQUEST_CODE){        Log.d(TAG, "grantResults--&gt;"+grantResults[0]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h3><p>添加俩个按钮:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".MainActivity"&gt;    &lt;Button        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="获取短信内容"        android:onClick="getSmsContent"        android:id="@+id/get_sms_content_btn"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintLeft_toLeftOf="parent"        app:layout_constraintRight_toRightOf="parent"        app:layout_constraintTop_toTopOf="parent" /&gt;    &lt;Button        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="获取短信验证码"        android:onClick="toVerityCodePage"        app:layout_constraintLeft_toLeftOf="parent"        app:layout_constraintRight_toRightOf="parent"        app:layout_constraintTop_toBottomOf="@id/get_sms_content_btn" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加点击事件"><a href="#添加点击事件" class="headerlink" title="添加点击事件:"></a>添加点击事件:</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void getSmsContent(View view){    ContentResolver cr = getContentResolver();    Uri uri=Uri.parse("content://sms/");    Cursor query = cr.query(uri, null, null, null, null);    String[] columnNames = query.getColumnNames();    while (query.moveToNext()) {        for (String columnName : columnNames) {            Log.d(TAG, columnName+"===="+query.getString(query.getColumnIndex(columnName)));        }    }    query.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MainActivity完整代码"><a href="#MainActivity完整代码" class="headerlink" title="MainActivity完整代码"></a>MainActivity完整代码</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import android.Manifest;import android.content.ContentResolver;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;@RequiresApi(api = Build.VERSION_CODES.M)public class MainActivity extends AppCompatActivity {    private static final int PERMISSION_REQUEST_CODE=1;    private static final String TAG ="MainActivity" ;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        checkSmsReadPermission();    }    public void toVerityCodePage(View view){        startActivity(new Intent(this,VerifyCodeActivity.class));    }    public void getSmsContent(View view){        ContentResolver cr = getContentResolver();        Uri uri=Uri.parse("content://sms/");        Cursor query = cr.query(uri, null, null, null, null);        String[] columnNames = query.getColumnNames();        while (query.moveToNext()) {            for (String columnName : columnNames) {                Log.d(TAG, columnName+"===="+query.getString(query.getColumnIndex(columnName)));            }        }        query.close();    }    private void checkSmsReadPermission() {        int permissionResultCode = checkSelfPermission(Manifest.permission.READ_SMS);        if (permissionResultCode!= PackageManager.PERMISSION_GRANTED){            requestPermissions(new String[]{Manifest.permission.READ_SMS},PERMISSION_REQUEST_CODE);        }    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        if (requestCode==PERMISSION_REQUEST_CODE){            Log.d(TAG, "grantResults--&gt;"+grantResults[0]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建VerifycodeActivity"><a href="#新建VerifycodeActivity" class="headerlink" title="新建VerifycodeActivity"></a>新建VerifycodeActivity</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.content.UriMatcher;import android.database.ContentObserver;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.os.CountDownTimer;import android.os.Handler;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import java.util.concurrent.atomic.AtomicReference;import java.util.regex.Matcher;import java.util.regex.Pattern;public class VerifyCodeActivity extends AppCompatActivity {    private static final String TAG = "VerifyCodeActivity";    private EditText mPhoneNumEt;    private Button mCountDownBtn;    private EditText mVerifyCodeEt;    private Button mCommitBtn;    private static final int MATCH_CODE=1;    private static UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);    static {        uriMatcher.addURI("sms","#",MATCH_CODE);        //"#"代表数字;"*"代表文本    }    //倒计时CountDownTimer(总时间,梯度)    private CountDownTimer mCountDownTimer=new CountDownTimer(60*1000,1000) {        @Override        public void onTick(long millisUntilFinished) {            mCountDownBtn.setEnabled(false);            mCountDownBtn.setText(String.format("重新获取(%d)",millisUntilFinished/1000));        }        @Override        public void onFinish() {            mCountDownBtn.setEnabled(true);            mCountDownBtn.setText(String.format("获取验证码"));        }    };    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_verify_code);        initView();        initEvent();        //注册短信内容提供者的观察者        Uri uri=Uri.parse("content://sms/");        getContentResolver().registerContentObserver(uri, true, new ContentObserver(new Handler()) {            @Override            public void onChange(boolean selfChange, @Nullable Uri uri) {                Log.d(TAG, "selfChange--&gt;"+selfChange);                if (uriMatcher.match(uri)==MATCH_CODE) {                    Log.d(TAG, "uri--&gt;"+uri);                    Cursor query = getContentResolver().query(uri, new String[]{"body"}, null, null, null);                    if (query.moveToNext()) {                        String body = query.getString(0);                        Log.d(TAG, "body==="+body);                        handlerBody(body);                    }                    query.close();                }            }        });    }    private void handlerBody(String body) {        if (!TextUtils.isEmpty(body)&amp;&amp;body.startsWith("【xxx】")) {            Pattern p=Pattern.compile("(?&lt;![0-9])([0-9]{4})(?![0-9])");//4位验证码            Matcher matcher=p.matcher(body);            boolean contain=matcher.find();            if (contain) {                String group = matcher.group();                Log.d(TAG, "verifyCode--&gt;"+ group);                mVerifyCodeEt.setText(group);                mVerifyCodeEt.setFocusable(true);//添加焦点            }        }    }    private void initEvent() {       mCountDownBtn.setOnClickListener(new View.OnClickListener() {           @Override           public void onClick(View v) {               String phoneNum = mPhoneNumEt.getText().toString().trim();               if (TextUtils.isEmpty(phoneNum)) {                   Toast.makeText(VerifyCodeActivity.this,"手机号码不能为空",Toast.LENGTH_SHORT).show();                   return;               }               // TODO: 向服务器请求发送验证码到手机               mCountDownTimer.start();           }       });       mCommitBtn.setOnClickListener(new View.OnClickListener() {           @Override           public void onClick(View v) {               String phoneNum = mPhoneNumEt.getText().toString().trim();               String verifyCode = mVerifyCodeEt.getText().toString().trim();               if (TextUtils.isEmpty(phoneNum)||TextUtils.isEmpty(verifyCode)){                   Toast.makeText(VerifyCodeActivity.this,"验证码和手机号都不能为空",Toast.LENGTH_SHORT).show();                   return;               }               // TODO: 向服务器提交           }       });    }    private void initView() {        mPhoneNumEt = this.findViewById(R.id.phone_num_et);        mVerifyCodeEt = this.findViewById(R.id.verify_code_et);        mCountDownBtn = this.findViewById(R.id.count_down_btn);        mCommitBtn = this.findViewById(R.id.submit_btn);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="activity-verity-code-xml"><a href="#activity-verity-code-xml" class="headerlink" title="activity_verity_code.xml"></a>activity_verity_code.xml</h3><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="50dp"&gt;        &lt;EditText            android:id="@+id/phone_num_et"            android:layout_width="match_parent"            android:layout_height="match_parent"            android:layout_marginRight="120dp"            android:hint="请输入手机号码"            android:inputType="number" /&gt;        &lt;Button            android:id="@+id/count_down_btn"            android:layout_width="120dp"            android:layout_height="match_parent"            android:layout_alignParentRight="true"            android:layout_marginRight="10dp"            android:text="获取验证码" /&gt;    &lt;/RelativeLayout&gt;    &lt;EditText        android:id="@+id/verify_code_et"        android:layout_width="match_parent"        android:layout_height="50dp"        android:hint="请输入验证码"        android:inputType="number" /&gt;    &lt;Button        android:id="@+id/submit_btn"        android:layout_width="match_parent"        android:layout_height="50dp"        android:text="检查验证码" /&gt;&lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码:"></a>发送验证码:</h3><p><img src="/liaojie.github.io/medias/%E9%AA%8C%E8%AF%81.png"></p><p>在其中输入:<br>    【xxx】验证码：4356，15分钟内有效</p><p>校验结果:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);public static final int MATCH_CODE = 1;static {    sUriMatcher.addURI("sms","#",MATCH_CODE);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注册短信内容变化的观察者"><a href="#注册短信内容变化的观察者" class="headerlink" title="注册短信内容变化的观察者:"></a>注册短信内容变化的观察者:</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final ContentResolver contentResolver = getContentResolver();    Uri uri = Uri.parse("content://sms/");    contentResolver.registerContentObserver(uri,true,new ContentObserver(new Handler()) {        @Override        public void onChange(boolean selfChange,Uri uri) {            if(sUriMatcher.match(uri) == MATCH_CODE) {                Log.d(TAG,"selfChange -- &gt; " + " uri -- &gt; " + uri);                Cursor query = contentResolver.query(uri,null,null,null,null);                if(query.moveToNext()) {                    String body = query.getString(query.getColumnIndex("body"));                    Log.d(TAG,"body -- &gt; " + body);                    handlerMsg(body);                }            query.close();            }        }    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理结果:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void handlerMsg(String body) {    if(body != null &amp;&amp; body.startsWith("【xxx】")) {        //符合条件        //截取数字        Pattern p = Pattern.compile("(?&lt;![0-9])([0-9]{4})(?![0-9])");        Matcher matcher = p.matcher(body);        boolean contain = matcher.find();        if(contain) {            Log.d(TAG,"verifyCode -- &gt; " + matcher.group());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token property">D/MainActivity:</span> selfChange <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span>  uri <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> content<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>sms<span class="token operator">/</span><span class="token number">19</span><span class="token property">D/MainActivity:</span> body <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> 【xxx】验证码：<span class="token number">4356</span>，<span class="token number">15</span>分钟内有效<span class="token property">D/MainActivity:</span> verifyCode <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">&gt;</span> <span class="token number">4356</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/SMSProvider">完整代码</a></p><h2 id="例子4-获取媒体库里的图片"><a href="#例子4-获取媒体库里的图片" class="headerlink" title="例子4:获取媒体库里的图片"></a>例子4:获取媒体库里的图片</h2><p>在android中有一个提供者中做MediaProvider</p><p>源码地址：<br><a href="https://github.com/TrillGates/MediaProvider">MediaProvider</a><br>获取到图片内容<br>URI</p><ul><li>图片的Url</li></ul><blockquote><p>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</p></blockquote><ul><li>视频的Url</li></ul><blockquote><p>MediaStore.Video.Media.EXTERNAL_CONTENT_URI</p></blockquote><ul><li>音频的Url</li></ul><blockquote><p>MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</p></blockquote><p>权限</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void checkPermission() {    int readExternalStoragePermissionResult = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);    if(readExternalStoragePermissionResult != PackageManager.PERMISSION_GRANTED) {        requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},PERMISSION_REQUEST_CODE);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据表字段"><a href="#数据表字段" class="headerlink" title="数据表字段"></a>数据表字段</h3><p>获得表的内容和字段</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ContentResolver contentResolver = getContentResolver();       Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;       Cursor query = contentResolver.query(uri,null,null,null,null,null);       String[] columnNames = query.getColumnNames();       while(query.moveToNext()) {           Log.d(TAG,"----------------------------");           for(String columnName : columnNames) {               Log.d(TAG,columnName + " ==== " + query.getString(query.getColumnIndex(columnName)));           }           Log.d(TAG,"----------------------------");       }       query.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得需要的字段:</p><ul><li>路径_data</li><li>图片名称_display_name</li><li>时间date_added</li></ul><p>还有经纬度等,通过这个经纬度+API转换就可以得到地址了,所以图片里可以包含着地理信息.</p><h3 id="准备一个封装数据的bean类"><a href="#准备一个封装数据的bean类" class="headerlink" title="准备一个封装数据的bean类"></a>准备一个封装数据的bean类</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class PhotoItem {    private String path;    private String name;    private long createDate;    private boolean isSelected = false;    public boolean isSelected() {        return isSelected;    }    public void setSelected(boolean selected) {        isSelected = selected;    }    public String getPath() {        return path;    }    public void setPath(String path) {        this.path = path;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public long getCreateDate() {        return createDate;    }    public void setCreateDate(long createDate) {        this.createDate = createDate;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取到图片的数据-并且封装起来-显示出来"><a href="#获取到图片的数据-并且封装起来-显示出来" class="headerlink" title="获取到图片的数据,并且封装起来,显示出来"></a>获取到图片的数据,并且封装起来,显示出来</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import android.content.ContentResolver;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import com.example.imagepickerdemo.domain.PhotoItem;import java.util.ArrayList;import java.util.List;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.RecyclerView;public class ImagePickerActivity extends AppCompatActivity {    private static final String TAG = "ImagePickerActivity";    private RecyclerView mPicListView;    private List&lt;PhotoItem&gt; mPics = new ArrayList&lt;&gt;();    private PicListAdapter mPicListAdapter;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_image_picker);        initView();        initData();    }    private void initData() {        //这些事情其实不能在主线程做        ContentResolver contentResolver = getContentResolver();        Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;        Cursor query = contentResolver.query(uri,new String[]{                MediaStore.Images.Media.DATA,                MediaStore.Images.Media.DISPLAY_NAME,                MediaStore.Images.Media.DATE_ADDED,                MediaStore.Images.Media._ID},null,null,null,null);        while(query.moveToNext()) {            PhotoItem photoItem = new PhotoItem();            photoItem.setPath(query.getString(0));            //这里的下标跟上面的query第一个参数对应，时间是第2个，所以下标为1            photoItem.setCreateDate(query.getLong(1));            photoItem.setName(query.getString(2));            mPics.add(photoItem);        }        query.close();        mPicListAdapter.setData(mPics);    }    private void initView() {        mPicListView = this.findViewById(R.id.pic_list);        mPicListView.setLayoutManager(new GridLayoutManager(this,3));        mPicListAdapter = new PicListAdapter();        mPicListView.setAdapter(mPicListAdapter);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="适配器代码"><a href="#适配器代码" class="headerlink" title="适配器代码"></a>适配器代码</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class PicListAdapter extends RecyclerView.Adapter&lt;PicListAdapter.InnerHolder&gt; {    private List&lt;PhotoItem&gt; mData = new ArrayList&lt;&gt;();    @NonNull    @Override    public InnerHolder onCreateViewHolder(@NonNull ViewGroup parent,int viewType) {        ImageView iv = new ImageView(parent.getContext());        iv.setScaleType(ImageView.ScaleType.CENTER_CROP);        Point point = new Point();        ((WindowManager) parent.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(point);        RecyclerView.LayoutParams layoutParams = new RecyclerView.LayoutParams(point.x / 3,point.x / 3);        iv.setLayoutParams(layoutParams);        return new InnerHolder(iv);    }    @Override    public void onBindViewHolder(@NonNull InnerHolder holder,int position) {        if(holder.itemView instanceof ImageView) {            Glide.with(holder.itemView.getContext()).load(mData.get(position).getPath()).into((ImageView) holder.itemView);        }    }    @Override    public int getItemCount() {        return mData.size();    }    public void setData(List&lt;PhotoItem&gt; pics) {        mData.clear();        mData.addAll(pics);        notifyDataSetChanged();    }    public class InnerHolder extends RecyclerView.ViewHolder {        public InnerHolder(@NonNull View itemView) {            super(itemView);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用LoaderManager来加载"><a href="#使用LoaderManager来加载" class="headerlink" title="使用LoaderManager来加载"></a>使用LoaderManager来加载</h3><p>前面我们直接在onCreate的地方加载数据,如果数据量大的话会导致主线程阻塞出现ANR异常。如果数据量小会影响页面的打开速度。<br>所以我们要么自己创建子线程去获取,要么通过LoaderManager去获取。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MediaContentPickerActivity extends AppCompatActivity {    private static final int LOADER_ALL = 0;         // 获取所有图片    private static final String TAG = "ContentPickerActivity";    private List&lt;PhotoItem&gt; photoInfoList = new ArrayList&lt;&gt;();      // 本地图片信息List    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_media_picker);        initLoader();    }    private void initLoader() {        LoaderManager loaderManager = LoaderManager.getInstance(this);        loaderManager.initLoader(LOADER_ALL,null,new LoaderManager.LoaderCallbacks&lt;Cursor&gt;() {            private final String[] IMAGE_PROJECTION = {                    MediaStore.Images.Media.DATA,                    MediaStore.Images.Media.DISPLAY_NAME,                    MediaStore.Images.Media.DATE_ADDED,                    MediaStore.Images.Media._ID,            };            @NonNull            @Override            public Loader&lt;Cursor&gt; onCreateLoader(int id,@Nullable Bundle args) {                if(id == LOADER_ALL) {                    return new CursorLoader(MediaContentPickerActivity.this,                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,IMAGE_PROJECTION,                            null,null,IMAGE_PROJECTION[2] + " DESC");                }                return null;            }            @Override            public void onLoadFinished(@NonNull Loader&lt;Cursor&gt; loader,Cursor data) {                if(data != null) {                    int count = data.getCount();                    if(count &gt; 0) {                        List&lt;PhotoItem&gt; tempPhotoList = new ArrayList&lt;&gt;();                        data.moveToFirst();                        do {                            String path = data.getString(data.getColumnIndexOrThrow(IMAGE_PROJECTION[0]));                            String name = data.getString(data.getColumnIndexOrThrow(IMAGE_PROJECTION[1]));                            long dateTime = data.getLong(data.getColumnIndexOrThrow(IMAGE_PROJECTION[2]));                            PhotoItem photoItem = new PhotoItem();                            photoItem.setName(name);                            photoItem.setPath(path);                            photoItem.setCreateDate(dateTime);                            tempPhotoList.add(photoItem);                        } while(data.moveToNext());                        photoInfoList.clear();                        photoInfoList.addAll(tempPhotoList);                    }                    //输出结果                    for(PhotoItem photoItem : photoInfoList) {                        Log.d(TAG,"photoItem -- &gt; " + photoItem);                    }                }            }            @Override            public void onLoaderReset(@NonNull Loader&lt;Cursor&gt; loader) {            }        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给PhotoItem.java添加toString方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic String toString() {    return "PhotoItem{" +            "path='" + path + '\'' +            ", name='" + name + '\'' +            ", createDate=" + createDate +            ", isSelected=" + isSelected +            '}';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们就把图片获取出来了</p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.iconfont.cn/">iconfont</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开源库之Jetpack</title>
      <link href="/liaojie.github.io/2021/10/20/jetpack/"/>
      <url>/liaojie.github.io/2021/10/20/jetpack/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是Jetpack"><a href="#什么是Jetpack" class="headerlink" title="什么是Jetpack?"></a>什么是Jetpack?</h5><p>Jetpack 是一个丰富的组件库,它的组件库按类别分为 4 类,分别是架构（Architecture）、界面（UI）、行为（behavior）和基础（foundation）.每个组件都可以单独使用,也可以配合在一起使用.每个组件都给用户提供了一个标准,能够帮助开发者遵循最佳做法,减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者能够集中精力编写重要的业务代码.</p><p><img src="/liaojie.github.io/medias/jetpack%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><pre class="line-numbers language-官方" data-language="官方"><code class="language-官方">Jetpack 是一个由多个库组成的套件,可帮助开发者遵循最佳做法、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码,让开发者可将精力集中于真正重要的编码工作.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>优点:<br>1.体现了单一原则<br>2.分层清晰<br>3.不需要非常依赖Activity<br>4.旋转数据不会丢失<br>…</p><p><a href="https://developer.android.google.cn/jetpack">官方文档</a></p><h5 id="在应用中使用-Jetpack-库"><a href="#在应用中使用-Jetpack-库" class="headerlink" title="在应用中使用 Jetpack 库"></a>在应用中使用 Jetpack 库</h5><p>所有 Jetpack 组件都可在 Google Maven 代码库中找到。</p><p>打开项目的 build.gradle 文件并添加 google() 代码库，如下所示：</p><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">Groovy:allprojects {    repositories {        google()        jcenter()    }}Kotlin:allprojects {    repositories {        google()        jcenter()    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，您可以添加 Jetpack 组件（例如 LiveData 和 ViewModel 等架构组件），如下所示：</p><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">Groovy:dependencies {    def lifecycle_version = "2.2.0"    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"    ...}Kotlin:dependencies {    val lifecycle_version = "2.2.0"    implementation("androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version")    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version")    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>许多 Jetpack 库都提供 <a href="https://developer.android.google.cn/kotlin/ktx">Android KTX 扩展</a>，如上面的 lifecycle-livedata-ktx 和 lifecycle-viewmodel-ktx 所示。KTX 扩展在基于 Java 的 API 基础上构建，充分利用了 Kotlin 特有的语言功能。</p><p>基于 <a href="https://developer.android.google.cn/reference/kotlin/androidx/packages">Kotlin</a> 以及基于 <a href="https://developer.android.google.cn/reference/androidx/packages">Java</a> 的 API 参考文档页面适用于所有 Jetpack 库</p><h5 id="利用-Jetpack"><a href="#利用-Jetpack" class="headerlink" title="利用 Jetpack"></a>利用 Jetpack</h5><p>Jetpack 库可以单独使用，也可以组合使用，以满足应用的不同需求。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">WorkManager</a> - 满足您的后台调度需求。<br><a href="https://developer.android.google.cn/topic/libraries/architecture/room">Room</a> - 实现数据存储持久性。<br><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started">Navigation</a> - 管理应用导航流程。<br><a href="https://developer.android.google.cn/training/camerax">CameraX</a> - 满足相机应用需求。<br>请参阅所有 Jetpack 库的<a href="https://developer.android.google.cn/jetpack/androidx/versions#version-table">概览</a>。</p><p>Jetpack 库在 androidx 命名空间中发布。如果项目目前使用 Android 支持库，请阅读如何迁移到 androidx 命名空间。</p><p>如需详细了解如何使用 Jetpack，请查看以下页面：</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture">Android 架构组件</a><br><a href="https://developer.android.google.cn/topic/libraries/architecture">Jetpack 组件的完整列表</a></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>以注重生命周期的方式管理界面相关的数据(管理UI数据)</p><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>source:</p><p>1.首先定义一个LiveData实例</p><p>2.观察LiveData数据变化,变化时将数据展示到TextView上</p><p>3.改变LiveData里面的数据,数据变化时会回调onChanged()方法</p><p>在底层数据库更改时通知视图(感应改变数据),UI刷新(LiveData+DataBinding)</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class MainViewModel extend /*ViewModel*/AndroidViewModel{  //ViewModel 无环境  //AndroidViewModel 有环境 需重写构造函数  private Context context;  public MainViewModel(@NonNull Application application)  {    super(application);    context = application;  }private MutableLiveData&lt;String&gt;info(){info.setValue("");//默认值return info;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>//DataBinding的引入(在build.gradle(:app)中添加):</p><pre class="line-numbers language-gradle(:app)" data-language="gradle(:app)"><code class="language-gradle(:app)">方式一:  dataBinding{  enabled true  }方式二:  dataBinding.enabled=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加后需同步<br>使用:(整个布局交给DataBinding管理)</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;Layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;!-- 和类交互 --&gt;    &lt;data&gt;          &lt;variable               name="name"               type="包名+类名"/&gt;    &lt;/data&gt;      //使用:android:text="@{name.info}"      //android:onClick="@{()-&gt;name.function(value)}"           所有布局...&lt;/Layout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MainActivity需要做绑定工作</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private ActivityMainBinding binding;private MainViewModel mainViewModel;//onCreate中添加binding = DataBindingUtil.setContentView(this,R.layout.activity_main);//AndroidViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(MainViewModel.class);//ViewModelmainViewModel = new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()).get(MainViewModel.class);//绑定工作binding.setName(mainViewModel);//建立感应binding.setLifecycleOwner(this);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：非Activity启动需要加标记.</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Intent intent = new Intent();intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Jetpack+MVVM : Google标准化Jetpack架构模式(强力推荐)</p><h2 id="MVVM、MVC、MVP"><a href="#MVVM、MVC、MVP" class="headerlink" title="MVVM、MVC、MVP"></a>MVVM、MVC、MVP</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>  创建过程:C-&gt;M+V</p><p>  优点:分离了Model和Controller.view与model隔离,view换了,model不影响.model换其他的数据源,view层也不受影响.一个view可以连接多个model,有些model可以复用.比如说你这个页面需要用户信息,另外一个界面也需要用户信息.</p><p>  缺点:Controller变得复杂.这里我们主要指Android上的缺点,不适合在Android开发上使用.在Android开发中,View的相关内容和Controller都写到一起了会让Activity/Fragment越来越臃肿</p><p>  建议:用于简单的、不大修改的页面</p><p>组件的互动:<br>将应用程序划分为三种组件,模型-视图-控制器(MVC)设计定义它们之间的相互作用.<br>  模型 (Model)用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法. Model”有对数据直接访问的权力,例如对数据库的访问.”Model”不依赖”View”和”Controller”.也就是说,Model不关心它会被如何显示或是如何被操作.但是Model中数据的变化一般会通过一种刷新机制被公布.为了实现这种机制,那些用于监视此 Model 的 View 必须事先在此Model上注册,从而,View 可以了解在数据Model上发生的改变.(比如：观察者模式(软件设计模式))</p><p>  视图（View）能够实现数据有目的的显示（理论上，这不是必需的）.在 View 中一般没有程序上的逻辑.为了实现 View 上的刷新功能,View 需要访问它监视的数据模型(Model),因此应该事先在被它监视的数据那里注册.<br>  控制器(Controller)起到不同层面间的组织作用,用于控制应用程序的流程.它处理事件并作出响应.”事件”包括用户的行为和数据Model上的改变.</p><p>在不同的项目开发里面,分别有不同的内容充当MVC.那在Android里是什么充当View,什么充当Model,什么充当Controller呢？<br>  View:Acitivity(View)、Fragment(View)视图,在android里xml布局转成View后,加载到了Activity/Fragmen里了.<br>  Controller:Controller对应着Activity/Fragment,绑定UI,处理各种业务.<br>  Model：数据的获取、存储、更新、domain</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>  创建过程:C-&gt;P-&gt;M<br>  优点:在MVC的基础上,通过Interface彻底分离了View和Model<br>  缺点:Presenter与View的交互会琐碎而复杂<br>  建议:核心、复杂、需求变得快页面</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>  创建过程:C-&gt;VM-&gt;M<br>  优点:在MVP的基础上增加了DataBinding,代码量更小<br>  缺点:XML中包含代码<br>  建议:核心、复杂、需求变得快页面</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C language</title>
      <link href="/liaojie.github.io/2021/10/19/c/"/>
      <url>/liaojie.github.io/2021/10/19/c/</url>
      
        <content type="html"><![CDATA[<p>C语言是一种计算机程序设计语言.它既具有高级语言的特点.又具有汇编语言的特点,它由美国贝尔研究所的D.M.Ritchie于1972年推出.1978后,C语言已先后被移植到大、中、小及微型机上.它可以作为工作系统设计语言,编写系统应用程序,也可以作为应用程序设计语言,编写不依赖计算机硬件的应用程序.它的应用范围广泛,具备很强的数据处理能力,不仅仅是在软件开发上,而且各类科研都需要用到C语言,适于编写系统软件、三维、二维图形和动画.具体应用比如单片机以及嵌入式系统开发.C语言是一门通用计算机编程语言,应用广泛.C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言.</p><p>尽管C语言提供了许多低级处理的功能,但仍然保持着良好跨平台的特性,以一个标准规格写出的C语言程序可在许多电脑平台上进行编译,甚至包含一些嵌入式处理器(单片机或称MCU)级电脑等作业平台.</p><p>二十世纪八十年代,为了避免各开发厂商用的C语言语法产生差异,由美国国家标准局为C语言订定了一套完整的国际标准语法,称为ANSI C,作为C语言最初的标准.</p><h5 id="C都能干啥呢？"><a href="#C都能干啥呢？" class="headerlink" title="C都能干啥呢？"></a>C都能干啥呢？</h5><p>1、C语言可以做嵌入式开发.51单片机、ARM等….</p><p>2、C语言可以写漂亮的界面,以windows开发为例,你可以学习《windows程序设计（第五版）》,学完就可以写出界面来.还有一些开源库界面库,例如soui也是用C写出来的.</p><p>3、C语言可以做服务器开发,现在的游戏服务器端大多都是C/C++开发的.《windows核心编程》里面的例子就是用C写的.</p><p>4、C语言可以写游戏.cocos2d-x就是C/C++写的.DirectX也是.</p><p>5、C语言可以写驱动程序.windows下各种硬件驱动都是C/C++写的.腾讯游戏保护软件(TP)也是驱动程序.</p><p>6、C语言可以写外挂.</p><p>7、C语言可以做视频图片流媒体处理.ffmpeg、live555、sdl等开源库.</p><p>8、C语言可以做网页和爬虫相关的编程.gsoap、libcur等相关开源库.</p><p>9、C语言可以进行黑客编程.配合汇编获取随机地址、调shellcode等.</p>]]></content>
      
      
      <categories>
          
          <category> C language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发之自定义控件</title>
      <link href="/liaojie.github.io/2021/10/11/android/"/>
      <url>/liaojie.github.io/2021/10/11/android/</url>
      
        <content type="html"><![CDATA[<p>自定义控件概念:Android中组件必须是View的直接子类或间接的子类,其中View有一个ViewGroup的子类,用于定义容器,(FrameLayout,LinearLayout,都是ViewGroup的子类).如果组件中还有子组件,就是从ViewGroup类继承,否则从View类继承.只要你自定义控件,要么是View的直接子类,要么就是View的间接子类.</p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><pre class="line-numbers language-none"><code class="language-none">1.自定义组合控件  继承自ViewGroup,比如说LinearLayout/RealativeLayout/FrameLayout--&gt;定义相关属性,获取相关属性  --&gt;加载组合的View/根据属性调整UI--&gt;处理相关事件/根据属性去处理数据--&gt;定义功能接口,对外暴露接口方法  --&gt;处理事件/数据2.自定义ViewGroup  继承自ViewGroup--&gt;定义相关属性,获取相关属性--&gt;把子View添加进来--&gt;测量:测量孩子,测量自己(覆写onMeasure方法)  --&gt;布局Layout--&gt;定义功能接口--&gt;处理事件和数据  3.自定义view  继承自View--&gt;定义相关属性,获取相关属性--&gt;测量自己--&gt;创建相关画笔--&gt;覆写onDraw方法,绘制相关内容  --&gt;定义功能接口--&gt;处理相关事件和数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="属性添加"><a href="#属性添加" class="headerlink" title="属性添加"></a>属性添加</h3><p>1.声明属性名称和值的类型<br>在res/values文件下新建一个属性xml文件,如attrs.xml,然后在属性文件里添加<declare-styleable>标签,并声明属性</declare-styleable></p><pre class="line-numbers language-attrs" data-language="attrs"><code class="language-attrs">&lt;declare-styleable name="InputNumberView"&gt;    &lt;attr name="max" format="integer" /&gt;    &lt;attr name="min" format="integer" /&gt;    &lt;attr name="step" format="integer" /&gt;    &lt;attr name="defaultValue" format="integer" /&gt;    &lt;attr name="disable" format="boolean" /&gt;    &lt;attr name="btnBackground" format="reference" /&gt;    &lt;attr name="valueSize" format="dimension" /&gt;    &lt;attr name="function" format="flags"&gt;        &lt;flag name="delete" value="0x30"/&gt;        &lt;flag name="read" value="0x50"/&gt;        &lt;flag name="top" value="0x03"/&gt;    &lt;/attr&gt;&lt;/declare-styleable&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer，比如说行数，TextView的maxLine，就是Integer类型<br>enum，枚举类型，比如说left,top,bottom,center,right这些是枚举类型<br>boolean，布尔类型，比如说layout_alignParentRight<br>dimension，尺寸比如说size,margin_left这些，单位为px,dp,sp这些<br>color，颜色，比如说background，比如说textColor<br>flags，标记，比如说activity声明周期时的configChanges，gravity<br>float，浮点数，也就是小数，比如说透明度alpha<br>fraction，百分数，比如说动画的开始位置，fromDx<br>refrence，引用，比如说background，src，但background可以是color又可以是refrence，其实是可以多个，比如说：name=”switch_time” format=”integer|float”，可以是Integer类型，或者float类型<br>string，比如说text</p><p>2.获取属性值</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$  TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.looper_style);   //从TypedArray中读取属性值   //......   //如：a.getColor(R.styleable.KeypadView_numberColor, context.getResources().getColor(R.color.white));   a.recycle();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.属性的获取</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">$ app:itemMargin="4dp"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义控件基本绘制原理"><a href="#自定义控件基本绘制原理" class="headerlink" title="自定义控件基本绘制原理"></a>自定义控件基本绘制原理</h3><p>View的绘制基本上由measure()、layout()、draw()三个函数完成<br>1.测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void measure(int widthMeasureSpec, int heightMeasureSpec)  protected final void setMeasuredDimension(int measuredWidth, int measuredHeight)  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>measure调用onMeasure,onMeasure测量宽度、高度然后调用setMeasureDimension保存测量结果,measure,setMeasureDimension是final类型,view的子类不需要重写,onMeasure在view的子类中重写.<br>关于MeasureSpec的三个值：</p><p>(1) UPSPECIFIED ：未指定模式，父容器对于子容器没有任何限制,子容器想要多大就多大，通常在绘制自定义View时才会用</p><p>(2) EXACTLY：精确值模式，父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间，当控件的layout_width和layout_height属性指定为具体数值或match_parent时为该模式。</p><p>(3) AT_MOST：最大值模式，子容器可以是声明大小内的任意大小，当空间的宽高设置为wrap_content时为该模式</p><p>2.布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void layout(int l, int t, int r, int b)protected boolean setFrame(int left, int top, int right, int bottom)protected void onLayout(boolean changed, int left, int top, int right, int bottom)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>layout通过调用setFrame（l,t,r,b），l,t,r,b即子视图在父视图中的具体位置，onLayout一般只会在自定义ViewGroup中才会使用</p><p>3.绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void draw(Canvas canvas)protected void onDraw(Canvas canvas)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过调用draw函数进行视图绘制,在View类中onDraw函数是个空函数,最终的绘制需求需要在自定义的onDraw函数中进行实现,比如ImageView完成图片的绘制,如果自定义ViewGroup这个函数则不需要重载.</p><h3 id="给自定义控件添加事件"><a href="#给自定义控件添加事件" class="headerlink" title="给自定义控件添加事件"></a>给自定义控件添加事件</h3><p>1.获取自定义控件坐标</p><p><img src="/liaojie.github.io/medias/viewFunction.jpg"></p><p>1.view获取自身坐标：getLeft(),getTop(),getRight(),getBottom()<br>getTop：获取到的是view自身的顶边到其父布局顶边的距离<br>getLeft：获取到的是view自身的左边到其父布局左边的距离<br>getRight：获取到的是view自身的右边到其父布局左边的距离<br>getBottom：获取到的是view自身的底边到其父布局顶边的距离<br>2.view获取自身宽高：getHeight(),getWidth()<br>3.motionEvent获取坐标：getX(),getY(),getRawX(),getRawY()<br>getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离<br>getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离<br>getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离<br>getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离</p><p>2.计算控件左上角坐标,当按下控件移动的时候,计算偏移距离,重新绘制</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SimpleView extends View {    //创建画笔    private Paint mPaint;    private RectF oval;    //事件处理    private EventHandle mEventHandle;    //鼠标按下位置    private int startX,startY;    //按下鼠标时控件的位置    private int startLeft,startTop;    //状态栏高度    int statusHeight = 0;    public SimpleView(Context context) {        this(context,null);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs,0);        //统一入口    }     public SimpleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init();    }     private void init(){        mPaint = new Paint();        //设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。        mPaint.setAntiAlias(true);        mPaint.setTextSize(30.0f);        oval=new RectF();        mEventHandle=null;        startY=startX=0;        int resourceId = this.getResources().getIdentifier("status_bar_height", "dimen", "android");        if (resourceId &gt; 0) {            statusHeight = this.getResources().getDimensionPixelSize(resourceId);        }    }     @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        int widthMode = MeasureSpec.getMode(widthMeasureSpec);        int widthSize = MeasureSpec.getSize(widthMeasureSpec);        int heightMode = MeasureSpec.getMode(heightMeasureSpec);        int heightSize = MeasureSpec.getSize(heightMeasureSpec);        switch (widthMode) {            case MeasureSpec.EXACTLY:                //精确值模式，当控件的layout_width和layout_height属性指定为具体数值或match_parent时。                break;            case MeasureSpec.AT_MOST:                //最大值模式，当空间的宽高设置为wrap_content时。                break;            case MeasureSpec.UNSPECIFIED:                //未指定模式，View想多大就多大，通常在绘制自定义View时才会用。                break;        }        //取最小边为控件的宽高的最小值        int minWidth=widthSize&gt;heightSize?heightSize:widthSize;        setMeasuredDimension(minWidth,minWidth);    }      @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        mPaint.setColor(Color.GRAY);        // FILL填充, STROKE描边,FILL_AND_STROKE填充和描边        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);        int with = getWidth();        int height = getHeight();        float radius = with / 2-5;        canvas.drawCircle(with / 2, with / 2, radius, mPaint);        mPaint.setColor(Color.RED);        oval.set(with / 2 - radius, with / 2 - radius, with / 2                + radius, with / 2 + radius);//用于定义的圆弧的形状和大小的界限        int sweepAngle=120;        canvas.drawArc(oval, 0, -sweepAngle, true, mPaint);  //根据进度画圆弧        double percent=sweepAngle/360.0;        //设置文本颜色        mPaint.setColor(Color.WHITE);        //绘制文本百分比数据        canvas.drawText(String.format("%.2f",percent)+"%",(float)(with/2+radius*Math.cos(sweepAngle*Math.PI/360)/4)                ,(float)(with/2-radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);        canvas.drawText(String.format("%.2f",1-percent)+"%",(float)(with/2-radius*Math.cos(sweepAngle*Math.PI/360))                ,(float)(with/2+radius*Math.sin(sweepAngle*Math.PI/360)/3),mPaint);    }     @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction())        {            case MotionEvent.ACTION_DOWN:                 startX=(int)event.getRawX();                startY=(int)event.getRawY();                startLeft=(int)(startX-event.getX());                /**                 * 这里startTop计算有些偏离，原因在于计算时加入了标题栏和状态栏的高度                 * 注意：要是你的Activity没有去掉标题栏，这里还要去掉标题栏的高度                 */                startTop= (int)(startY-event.getY())-statusHeight;//减去状态栏高度                break;            case MotionEvent.ACTION_MOVE:                if(mEventHandle!=null)                {                    mEventHandle.onTouchEvent(event);                }else{                    int disX=(int)event.getRawX()-startX;//计算偏移的X坐标                    int disY=(int)event.getRawY()-startY;//计算偏移的Y坐标;                    int left=startLeft+disX;                    int top=startTop+disY;                    //更新控件位置                    layout(left,top,left+getWidth(),top+getHeight());                }                break;            case MotionEvent.ACTION_UP:                break;        }        //返回true表示不消耗此事件，事件继续传递，返回flase表示事件消耗        return true;    }     public void setmEventHandle(EventHandle mEventHandle) {        this.mEventHandle = mEventHandle;    }     interface EventHandle{        public void onTouchEvent(MotionEvent event);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>XML文件中添加:</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;com.example.myapplication.SimpleView  android:layout_width="150dp"  android:layout_height="150dp"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意:MainActivity需要将标题栏去掉,否则拖动的时候会出现偏差,在onCreate中添加</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">requestWindowFeature(Window.FEATURE_NO_TITLE);//去掉标题栏/*  requestWindowFeature(Window.FEATURE_NO_TITLE)无效解决方法：  正常情况下requestWindowFeature(Window.FEATURE_NO_TITLE)是可以生效的，  但是当Activity继承子AppCompatActivity的时候,这个就失效了   解决办法：  1、手动在oncreate里调用hide()  if (getSupportActionBar() != null){     getSupportActionBar().hide();  }*/if (getSupportActionBar() != null){    getSupportActionBar().hide();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/liaojie1314/customviewLayout.git">自定义控件</a>,仅供参考.</p><h5 id="手机号码正则表达式"><a href="#手机号码正则表达式" class="headerlink" title="手机号码正则表达式"></a>手机号码正则表达式</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$ public static final String REGEX_MOBILE_EXACT =   "^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\\d{8}$";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="Android单位转换工具类"><a href="#Android单位转换工具类" class="headerlink" title="Android单位转换工具类"></a>Android单位转换工具类</h5><p>如果要在代码里直接填写尺寸，一般是px，如果要做好屏幕适配，我们通常使用dp作为单位</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">$ public class SizeUtils {    public static int dip2px(Context context,float dpValue) {        float scale = context.getResources().getDisplayMetrics().density;        return (int) (dpValue * scale + 0.5f);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
