<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="C++, Android,Java,Python,C language,C#,C++,HTML,CSS,JavaScript,JQuery,Vue.js等"><meta name="description" content="成功的信念在人脑中的作用就如闹钟,会在你需要时将你唤醒"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>C++ | Lj&#39;blog</title><link rel="icon" type="image/png" href="/liaojie.github.io/medias/dog.png"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/css/matery.css"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/css/my.css"><script src="/liaojie.github.io/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/liaojie.github.io/atom.xml" title="Lj'blog" type="application/atom+xml"></head><script type="text/javascript">WIDGET={FID:"1tFpFZ5Mtj"}</script><script type="text/javascript">var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"><\/script>')</script><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/liaojie.github.io/" class="waves-effect waves-light"><div><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/medias/ljlogo.png" class="logo-img" alt="LOGO"> <span class="logo-span">Lj'blog</span></div></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/liaojie.github.io/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/liaojie.github.io/medias/ljlogo.png" class="logo-img circle responsive-img"><div class="logo-name">Lj&#39;blog</div><div class="logo-desc">成功的信念在人脑中的作用就如闹钟,会在你需要时将你唤醒</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/liaojie.github.io/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/liaojie.github.io/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/liaojie.github.io/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/liaojie.github.io/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/liaojie.github.io/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/liaojie.github.io/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/liaojie.github.io/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li></ul></div></div></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/liaojie.github.io/medias/featureimages/3.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">C++</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/liaojie.github.io/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/liaojie.github.io/tags/C/"><span class="chip bg-color">C++</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/liaojie.github.io/categories/C/" class="post-category">C++</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2022-01-15</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-02-11</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 38.9k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 175 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><link rel="stylesheet" href="/liaojie.github.io/libs/prism/prism.css"><div class="card-content article-card-content"><div id="articleContent"><p>C++编写软件(推荐):Visual Studio</p><p>Visual Studio安装:</p><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-创建新项目"><a href="#1-1-创建新项目" class="headerlink" title="1.1 创建新项目"></a>1.1 创建新项目</h3><p>选择Visual C++下的空项目,然后给项目取一个名;右键源文件,添加-&gt;新建项,在弹出的页面中选择C++文件(.cpp),给它取一个名称.</p><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>作用:方便程序员阅读</p><p>俩种格式:<br>1.单行注释: <code>//描述信息</code></p><ul><li>通常放在一行代码的上方,或者一条语句的末尾,对该行代码说明</li></ul><p>2.多行注释: <code>/* 描述信息 */</code></p><ul><li>通常放在一段代码的上方,对该段代码做整体说明</li></ul><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>作用: 给一段指定的内存空间起名,方便操作这段内存</p><p>语法: <code>数据类型 变量名 = 初始值</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a = 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>作用: 用于记录程序中不可更改的数据</p><p>C++定义常量的俩种方式:<br>1.#define宏常量: <code>#define 常量名 常量值</code></p><ul><li>通常在文件上方定义,表示一个常量</li></ul><p>2.const修饰的变量: <code>const 数据类型 常量名 = 常量值</code></p><ul><li>通常在变量定义前加关键字const,修饰该变量为常量,不可修改</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define month 12

const int month = 12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>作用: 定义变量或者常量时,不能使用关键字</p><p>C++关键字如下:</p><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><p>标识符争取做到见名知意的效果</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>-2^15~2^15-1</td></tr><tr><td>int(整型)</td><td>4字节</td><td>-2^31~2^31-1</td></tr><tr><td>long(长整型)</td><td>Window为4字节,Linux为4字节(32位),8字节(64位)</td><td>-2^31~2^31-1</td></tr><tr><td>long long(长长整型)</td><td>8字节</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>作用: 利用sizeof关键字可以统计数据类型所占内存大小</p><p>语法: <code>sizeof(数据类型/变量)</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout &lt;&lt; "short占用内存空间为:" &lt;&lt; sizeof(short) &lt;&lt; endl;
cout &lt;&lt; "int占用内存空间为:" &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; "long占用内存空间为:" &lt;&lt; sizeof(long) &lt;&lt; endl;
cout &lt;&lt; "long long占用内存空间为:" &lt;&lt; sizeof(long long) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大小比较:</p><blockquote><p>short &lt; int &lt;= long &lt;= long long</p></blockquote><h3 id="2-3-实型-浮点型"><a href="#2-3-实型-浮点型" class="headerlink" title="2.3 实型(浮点型)"></a>2.3 实型(浮点型)</h3><p>作用: 用于表示小数</p><p>浮点型变量分为俩种:<br>1.单精度float<br>2.双精度double</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15~16位有效数字</td></tr></tbody></table><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">float f1 = 3.14f;
double d1 = 3.14;
//科学计数法
float f2 = 3e2;//3*10^2
float f3 = 3e-2;//3*0.1^2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>默认情况下输出一个小数会显示出6位有效数字</p></blockquote><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>作用: 字符型变量用于显示单个字符</p><p>语法: <code>char ch = 'a';</code></p><blockquote><p>注意1: 在显示字符型变量时,用单引号将字符括起来,不要用双引号</p></blockquote><blockquote><p>注意2: 单引号内只能有一个字符,不可能是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用1个字节</li><li>字符型变量并不是把字符本身放到内存中存储,而是将对应的ASCII编码(int(ch))放入到存储单元</li></ul><p>a - 97<br>A - 65</p><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>作用: 用于表示一些不能显示出来的ASCII字符<br>常用转义字符有: <code>\n \\ \t</code></p><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码值(十进制)</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS),将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF),将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF),将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR),将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) (跳到下一个TAB位置)</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>代表一个反斜线字符”"</td><td>092</td></tr><tr><td>'</td><td>代表一个单引号(撇号)字符</td><td>039</td></tr><tr><td>"</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>\？</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符,d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符,h范围0<del>9,A</del>F</td><td>3位16进制</td></tr></tbody></table><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>作用: 用于表示一串字符</p><p>俩种风格:<br>1.C风格字符串: <code>char 变量名[] = "字符串值";</code><br></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   //C风格字符串 等号后面要用双引号
char str1[] = "hello world";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>2.C++风格字符串: <code>string 变量名 = "字符串值";</code><br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   //C++风格字符串 需包含头文件：#include&lt;string&gt;
string str2 = "hello world";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h3 id="2-7-布尔类型bool"><a href="#2-7-布尔类型bool" class="headerlink" title="2.7 布尔类型bool"></a>2.7 布尔类型bool</h3><p>作用: 布尔数据类型代表真或假的值</p><p>bool类型只有俩个值:</p><ul><li>true — 真 (本质是1)</li><li>false — 假 (本质是0)</li></ul><p>bool类型占1个字节大小</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool flag = true;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p>作用: 用于从键盘获取数据</p><p>关键字: cin</p><p>语法: <code>cin &gt;&gt; 变量</code></p><blockquote><p>bool类型只要是非0的值都代表真</p></blockquote><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p>作用: 用于执行代码的运算</p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋值给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较,并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p>作用: 用于处理四则运算</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>1+2</td><td>3</td></tr><tr><td>-</td><td>减</td><td>2-1</td><td>1</td></tr><tr><td>*</td><td>乘</td><td>1*2</td><td>2</td></tr><tr><td>/</td><td>除</td><td>2/1</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10%3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a=2;b=++a;</td><td>a=3;b=3;</td></tr><tr><td>++</td><td>后置递增</td><td>a=2;b=a++;</td><td>a=3;b=2;</td></tr><tr><td>–</td><td>前置递减</td><td>a=2;b=–a;</td><td>a=1;b=1;</td></tr><tr><td>–</td><td>后置递减</td><td>a=2;b=a–;</td><td>a=1;b=2;</td></tr></tbody></table><blockquote><p>俩个整数相除结果依然是整数,将小数部分去除</p></blockquote><blockquote><p>前置递增 先让变量+1,然后进行表达式计算;后置递增 先进行表达式计算,然后让变量+1(递减同理)</p></blockquote><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p>作用: 用于将表达式的值赋值给变量</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2;b=3;</td><td>a=2;b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0;a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5;a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2;a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4;a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3;a%=2;</td><td>a=1;</td></tr></tbody></table><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p>作用: 用于表达式的比较,并返回一个真值或假值</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4==3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4!=3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4&lt;3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4&gt;3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4&lt;=3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4&gt;=3</td><td>1</td></tr></tbody></table><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p>作用: 用于根据表达式的值返回真值或假值</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假,则!a为真;如果a为真,则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a&amp;&amp;b</td><td>如果a和b都为真,则结果为真,否则为假。</td></tr><tr><td>||</td><td>或</td><td>a||b</td><td>如果a和b有一个为真,则结果为真,二者都为假时,结果为假。</td></tr></tbody></table><p>在C++中,除0外都为真</p><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基础的三种程序运算结构:顺序结构、选择结构、循环结构</p><ul><li>顺序结构:程序按顺序执行,不发生跳转</li><li>选择结构:依据条件是否满足,有选择的执行相应功能</li><li>循环结构:依据条件是否满足,循环多次执行某段代码</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p>作用: 执行满足条件的语句</p><p>if语句的三种形式</p><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><p>1.单行格式if语句: <code>if(条件){条件满足执行的语句}</code></p><p>2.多行格式if语句: <code>if(条件){条件满足执行的语句}else{条件不满足执行的语句}</code></p><p>3.多条件的if语句: <code>if(条件1){条件1满足执行的语句}else if(条件2){条件2满足执行的语句}... else{条件都不满足执行的语句}</code></p><p>嵌套if语句: 在if语句中,可以嵌套使用if语句,达到更精确的条件判断</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  int score = 0;
  cout &lt;&lt; "请输入你的分数：" &lt;&lt; endl;
  cin &gt;&gt; score;
  cout &lt;&lt; "你的分数为：" &lt;&lt; score &lt;&lt; endl;
  if (score &gt; 600)// 注意:if 条件后面不能加分号
  {
    cout &lt;&lt; "恭喜你考上一本" &lt;&lt; endl;
    if (score &gt; 700) 
    {
      cout &lt;&lt; "恭喜你考上北大" &lt;&lt; endl;
    }
    else if (score&gt;650)
    {
      cout &lt;&lt; "恭喜你考上清华" &lt;&lt; endl;
    }
    else {
      cout &lt;&lt; "恭喜你考上重大" &lt;&lt; endl;
    }
  }
  else if(score&gt;500)
  {
    cout &lt;&lt; "恭喜你考上二本" &lt;&lt; endl;
  }
  else  if (score&gt;400)
  {
    cout &lt;&lt; "恭喜你考上三本" &lt;&lt; endl;
  }else
  {
    cout &lt;&lt; "未考上本科大学" &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>作用: 通过三目运算符实现简单的判断</p><p>语法: <code>表达式1?表达式2:表达式3</code></p><p>解释:</p><ul><li>如果表达式1的值为真,执行表达式2,并返回表达式2的结果;</li><li>如果表达式1的值为假,执行表达式3,并返回表达式3的结果。</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //三目运算符
  int a = 10;
  int b = 20;
  int c = 0;
  c = (a &gt; b ? a : b);
  //C++中三目运算符返回的是变量可以继续赋值  (a &lt; b ? a : b)=100; ==&gt;a=100;b=20
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p>作用: 执行多条件分支语句</p><p>语法:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">switch(表达式)
{
  case 结果1: 执行语句1;break;
  case 结果2: 执行语句2;break;
  ...
  default: 执行语句;break;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  int score = 0;
  cout &lt;&lt; "请打分" &lt;&lt; endl;
  cin &gt;&gt; score;
  cout &lt;&lt; "你打的分为" &lt;&lt; score &lt;&lt; endl;
  switch (score)
    //缺点：只能是整数或者字符
    //优点：结构清晰，执行效率高
  {
  case 10:
    cout &lt;&lt; "经典" &lt;&lt; endl;
    break;
  case 9:
    cout &lt;&lt; "经典" &lt;&lt; endl;
    break;
  case 8:
    cout &lt;&lt; "很好" &lt;&lt; endl;
    break;
  case 7:
    cout &lt;&lt; "很好" &lt;&lt; endl;
    break;
  case 6:
    cout &lt;&lt; "一般" &lt;&lt; endl;
    break;
  case 5:
    cout &lt;&lt; "一般" &lt;&lt; endl;
    break;
  default:
    cout &lt;&lt; "不好" &lt;&lt; endl;
    break;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>case里如果没有break,那么程序会一直向下执行</p><blockquote><p>if与switch区别?<br>switch 缺点：判断时只能是整数或者字符,不可以是一个区间<br>switch 优点：结构清晰，执行效率高</p></blockquote><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p>作用: 满足循环条件,执行循环语句</p><p>语法: <code>while(循环条件){循环语句}</code></p><p>解释: 只要循环条件的结果为真,就执行循环语句</p><p>写循环时应避免死循环!!!</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main1()
{
  int num = 0;
  //打印0~9
  while (num &lt; 10)
  {
    cout &lt;&lt; num &lt;&lt; endl;
    num++;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p>作用: 满足循环条件,执行循环语句</p><p>语法: <code>do{循环语句}while(循环条件);</code></p><p>注意: 与while的区别在于do…while会先执行一次循环语句,在判断循环条件</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  int num = 0;
  //打印0~9
  do
  {
    cout &lt;&lt; num &lt;&lt; endl;
    num++;
  } while (num&lt;10);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>生成随机数<br>添加随机数种子 利用系统当前时间生成随机数,防止每次随机数相同<br>srand((unsigned int)time(NULL));<br>int num = rand() % 100 + 1;<br>生成 0 + 1 ~ 99 + 1随机数</p></blockquote><h5 id="案例-水仙花数"><a href="#案例-水仙花数" class="headerlink" title="案例: 水仙花数"></a>案例: 水仙花数</h5><p>案例描述: 水仙花数是指一个3位数,它的每个位上的数字的3次幂之和等于它本身<br>例如: 1^3+5^3+3^3=153</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //1.先打印所有三位数
  int num = 100;
  do
  {
    //2.从所有三位数中找到水仙花数
    int a = num % 10; // 个位
    int b = num / 10 % 10;//十位
    int c = num / 100;//百位
    if (a*a*a+b*b*b+c*c*c == num)//如果是水仙花数才打印
    {
      cout &lt;&lt; num &lt;&lt; endl;
    }
    num++;
  } while (num&lt;1000);
  
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p>作用: 满足循环条件,执行循环语句</p><p>语法: <code>for(起始表达式;条件表达式;末尾循环体){循环语句;}</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //打印0~9
  for (int i = 0;i &lt; 10;i++) {
    cout &lt;&lt; i &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>作用: 在循环体中再嵌套一层循环,解决一些设计问题</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  /* 打印10*10星图
  for (int i = 0;i &lt; 10;i++) 
  {
    for (int j = 0;j &lt; 10;j++)
    {
      cout &lt;&lt; "*";
    }
    cout &lt;&lt; endl;
  }*/
  //九九乘法表
  for (int i = 1;i &lt;= 9;i++)
  {
    for (int j = 1;j &lt;= i;j++)
    {
      cout &lt;&lt; j &lt;&lt; "x" &lt;&lt; i &lt;&lt; "=" &lt;&lt; (i * j)&lt;&lt;"\t";
    }
    cout &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p>作用: 用于跳出选择结构或循环结构</p><p>break 使用场景：<br>1.switch语句中 case:break;<br>2.循环语句中 跳出当前循环<br>3.嵌套循环语句中 跳出内部循环</p><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>作用: 在循环语句中,跳出本次循环中余下尚未执行的语句,继续执行下一次循环</p><p>continue:筛选条件符合的内容</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p>作用: 可以无条件跳转语句</p><p>语法: <code>goto 标记;</code><br>翻译: 如果标记的名称存在,在执行到goto语句时,会跳转到标记的位置</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //goto:
  //语法：goto 标记;
  cout &lt;&lt; "1 ..." &lt;&lt; endl;
  cout &lt;&lt; "2 ..." &lt;&lt; endl;
  goto FLAG;
  cout &lt;&lt; "3 ..." &lt;&lt; endl;
  cout &lt;&lt; "4 ..." &lt;&lt; endl;
  FLAG:
  cout &lt;&lt; "5 ..." &lt;&lt; endl;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/goto.png"></p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组就是一个集合里面存放了相同类型的数据结构</p><p>特点1:数组中的每个数据元素都是相同的数据类型<br>特点2:数组是由连续的内存位置组成的</p><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>1.<code>数据类型 数组名[数组长度];</code><br>2.<code>数据类型 数组名[数组长度] = {值1,值2...};</code><br>3.<code>数据类型 数组名[] = {值1,值2...};</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //一维定义：
  //1.
  int arr1[5];
  arr1[0] = 10;
  arr1[1] = 20;
  arr1[2] = 30;
  arr1[3] =40;
  arr1[4] = 50;
  //2.
  int arr2[5]={10,20,30,40,50};
  //3.
  int arr3[]={10,20,30,40,50};
  //定义数组的时候,必须有初始长度
  //数组名(常量，不可修改)：
  //1.统计整个数组在内存中的长度 sizeof(arr)
  //2.获取数组在内存中的首地址  cout&lt;&lt;(int)arr&lt;&lt;endl;  第一个元素地址: (int)&amp;arr[0]
  //3.元素个数 sizeof(arr)/sizeof(arr[0])
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组元素逆置"><a href="#数组元素逆置" class="headerlink" title="数组元素逆置"></a>数组元素逆置</h5><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //元素逆置：(start&lt;end执行互换)
  int arr[] = { 1,2,3,5,7 };
  cout &lt;&lt; "逆序前" &lt;&lt; endl;
  for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++)
  {
    cout &lt;&lt; arr[i] &lt;&lt; endl;
  }
  int start = 0;
  int end = sizeof(arr) / sizeof(arr[0]) - 1;//末尾元素下标
  while (start&lt;end)
  {
    //起始下标与结束下标的元素互换
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    //起始位置++;结束位置--
    start++;
    end--;
  }
  cout &lt;&lt; "逆序后" &lt;&lt; endl;
  for (int j = 0; j &lt; sizeof(arr) / sizeof(arr[0]); j++)
  {
    cout &lt;&lt; arr[j] &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE.png"></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //冒泡排序
  int arr[9] = { 4,2,8,0,5,7,1,3,9 };
  cout &lt;&lt; "排序前" &lt;&lt; endl;
  for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)
  {
    cout &lt;&lt; arr[i] &lt;&lt; endl;
  }
  //排序总轮数=元素个数-1
  //每轮对比次数=元素个数-排序轮数-1
  for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]) - 1; i++)
  {
    for (int j = 0; j &lt; sizeof(arr) / sizeof(arr[0])-i - 1; j++)
    {
      if (arr[j] &gt; arr[j + 1])
      {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  cout &lt;&lt; "排序后" &lt;&lt; endl;
  for (int j = 0; j &lt; sizeof(arr) / sizeof(arr[0]); j++)
  {
    cout &lt;&lt; arr[j] &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>1.<code>数据类型 数组名[行数][列数];</code><br>2.<code>数据类型 数组名[行数][列数] = {{数据1,数据2},{数据3,数据4}};</code><br>3.<code>数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};</code><br>3.<code>数据类型 数组名[][列数] = {数据1,数据2,数据3,数据4};;</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{
  //二维定义:
  int arr[2][3] = {
    {1,2,3},
    {4,5,6}
  };
  //数组名(常量，不可修改)：
  //1.占内存空间大小 sizeof(arr) 第一行占用内存 sizeof(arr[0]) 第一个元素 sizeof(arr[0][0])
  //行数：sizeof(arr)/sizeof(arr[0]) 列数：sizeof(arr[0])/sizeof(arr[0][0])
  //2.获取数组在内存中的首地址  cout&lt;&lt;arr&lt;&lt;endl; (arr arr[0] &amp;arr[0][0])
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><p>作用: 将一段经常用的代码封装起来,减少重复代码</p><h3 id="6-1-函数的定义"><a href="#6-1-函数的定义" class="headerlink" title="6.1 函数的定义"></a>6.1 函数的定义</h3><p>函数的定义一般主要有5个步骤</p><p>1、返回值类型<br>2、函数名<br>3、参数列表(形参)<br>4、函数体语句<br>5、return表达式</p><p>语法:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">返回值类型 函数名 (参数列表)
{
  函数体语句

  return 表达式
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-函数的调用"><a href="#6-2-函数的调用" class="headerlink" title="6.2 函数的调用"></a>6.2 函数的调用</h3><p>功能: 使用定义好的函数</p><p>语法: <code>函数名 (参数)</code></p><p>当调用函数时候,实参的值会传递给形参</p><h3 id="6-3-值传递"><a href="#6-3-值传递" class="headerlink" title="6.3 值传递"></a>6.3 值传递</h3><ul><li>所谓值传递,就是函数调用时实参将数值传入给形参</li><li>值传递时,如果形参发生,并不会影响实参</li></ul><h3 id="6-4-函数的常见样式"><a href="#6-4-函数的常见样式" class="headerlink" title="6.4 函数的常见样式"></a>6.4 函数的常见样式</h3><p>1.无参无返<br>2.有参无返<br>3.无参有返<br>4.有参有返</p><h3 id="6-5-函数的声明"><a href="#6-5-函数的声明" class="headerlink" title="6.5 函数的声明"></a>6.5 函数的声明</h3><p>作用: 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义</p><ul><li>函数的声明可以多次,但是函数的定义只能有一次</li></ul><h3 id="6-6-函数的分文件编写"><a href="#6-6-函数的分文件编写" class="headerlink" title="6.6 函数的分文件编写"></a>6.6 函数的分文件编写</h3><p>作用: 让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤:<br>1.创建.h头文件<br>头文件右键-&gt;添加-&gt;新建项,在弹出页面中选择头文件(eg:max.h)<br><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E5%A4%B4%E6%96%87%E4%BB%B6.png"><br>2.创建.cpp源文件<br>源文件右键-&gt;添加-&gt;新建项,在弹出页面中选择源文件(eg:max.cpp)<br>3.头文件写函数声明<br>4.源文件写函数定义</p><p>代码:</p><p>max.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//函数声明
#include&lt;iostream&gt;
using namespace std;
int max(int a, int b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>max.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//函数定义
int max(int a, int b)
{
  return a &gt; b ? a : b;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include"max.h"
int main()
{
  int a = 10;
  int b = 20;
  int c = max(a, b);
  cout &lt;&lt; c &lt;&lt; endl;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><p>作用: 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的,一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="7-1-指针变量的定义和使用"><a href="#7-1-指针变量的定义和使用" class="headerlink" title="7.1 指针变量的定义和使用"></a>7.1 指针变量的定义和使用</h3><p>语法: <code>数据类型 * 变量名;</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{ 
  int a = 10;
  /*int* p;
  p = &amp;a;*/
  //32位系统指针占4个字节
  //64位系统指针占8个字节
  int* p = &amp;a;
  cout &lt;&lt; "a地址为" &lt;&lt; &amp;a &lt;&lt; endl;
  cout &lt;&lt; "p=" &lt;&lt; p &lt;&lt; endl;
  /*通过解引用使用指针
  *p = 100;
  cout &lt;&lt; "*p=" &lt;&lt; *p &lt;&lt; endl;
  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
  */
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-空指针和野指针"><a href="#7-2-空指针和野指针" class="headerlink" title="7.2 空指针和野指针"></a>7.2 空指针和野指针</h3><p>空指针：<br>1.用于指针变量初始化： int* p =NULL;<br>2.空指针不可以进行访问：0 ~ 255之间的内存编号是系统占用</p><p>野指针：避免出现<br>int* p= (int *)0x1100;</p><h3 id="7-3-const修饰指针"><a href="#7-3-const修饰指针" class="headerlink" title="7.3 const修饰指针"></a>7.3 const修饰指针</h3><p>const修饰指针：常量指针const int* p = &amp;a(指针指向可以修改，指针指向的值不可以改)<br>指针常量int * const p = &amp;a(指针指向不可以改，指针指向的值可以修改)<br>const int* const p = &amp;a(指针指向,指针指向的值都不可以改)</p><h3 id="7-4-指针和数组"><a href="#7-4-指针和数组" class="headerlink" title="7.4 指针和数组"></a>7.4 指针和数组</h3><p>作用: 利用指针访问数组中元素</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
int main()
{ 
  //指针与数组：
  int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
  int* p = arr;
  cout &lt;&lt; "arr[0]=" &lt;&lt; *p&lt;&lt;endl;
  p++;
  cout &lt;&lt; "arr[1]=" &lt;&lt; *p &lt;&lt; endl;
  cout &lt;&lt; "指针遍历数组" &lt;&lt; endl;
  int* p2 = arr;
  for (int i = 0; i &lt; 10; i++)
  {
    cout &lt;&lt; *p2 &lt;&lt; endl;
    p2++;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-5-指针和函数"><a href="#7-5-指针和函数" class="headerlink" title="7.5 指针和函数"></a>7.5 指针和函数</h3><p>作用: 利用指针作函数参数,可以修改实参的值</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
void swap(int* p1, int* p2);
int main()
{ 
  /*地址传递：
  */
  int num1 = 10;
  int num2 = 20;
  swap(&amp;num1, &amp;num2);
  cout &lt;&lt; "num1=" &lt;&lt; num1 &lt;&lt; endl;
  cout &lt;&lt; "num2=" &lt;&lt; num2 &lt;&lt; endl;
  system("pause");
  return 0;
}
void swap(int* p1, int* p2)
{
  int temp = *p1;
  *p1 = *p2;
  *p2 = temp;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/swap.png"></p><h5 id="案例-指针、数组、函数"><a href="#案例-指针、数组、函数" class="headerlink" title="案例: 指针、数组、函数"></a>案例: 指针、数组、函数</h5><p>案例描述: 封装一个函数,利用冒泡排序,实现对整型数组的升序排序<br>例如数组: <code>int arr[10] = {4,3,6,9,1,2,10,8,7,5};</code></p><p>代码:</p><p>bubbleSort.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
void bubbleSort(int* arr, int len);
void printArray(int* arr, int len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>bubbleSort.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
void bubbleSort(int* arr, int len)
{
  //排序总轮数=元素个数-1
  //每轮对比次数=元素个数-排序轮数-1
  for (int i = 0; i &lt; len - 1; i++)
  {
    for (int j = 0; j &lt; len- i - 1; j++)
    {
      if (arr[j] &gt; arr[j + 1])
      {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
void printArray(int* arr, int len)
{
  for (int i = 0; i &lt; len; i++)
  {
    cout &lt;&lt; arr[i] &lt;&lt; endl;
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include"bubbleSort.h"
int main()
{
  //案例：
  int arr[10] = {4,3,6,9,1,2,10,8,7,5};
  int len = sizeof(arr) / sizeof(arr[0]);
  bubbleSort(arr, len);
  printArray(arr, len);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0.png"></p><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><p>结构体属于用户自定义的数据类型,允许用户存储不同的数据类型</p><h3 id="8-1-结构体定义和使用"><a href="#8-1-结构体定义和使用" class="headerlink" title="8.1 结构体定义和使用"></a>8.1 结构体定义和使用</h3><p>语法: <code>struct 结构体名 {结构体成员列表};</code></p><p>通过结构体创建变量的方式有三种:</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = {成员1值,成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
struct Student
{
  string name;
  int age;
  int score;
}s3;
int main()
{
  struct Student s1;
  //等同于Student s1;
  s1.name = "张三";
  s1.age = 18;
  s1.score = 80;
  struct  Student s2= { "李四",19,88 };
  s3.name = "王五";
  s3.age = 17;
  s3.score = 90;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-结构体数组"><a href="#8-2-结构体数组" class="headerlink" title="8.2 结构体数组"></a>8.2 结构体数组</h3><p>作用: 将自定义的结构体放入到数组中方便维护</p><p>语法: <code>struct 结构体名 数组名[元素个数] = {{},{},...{}}</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//结构体数组
//1.定义结构体
#include&lt;string&gt;
struct Student
{
  string name;
  int age;
  int score;
};
int main()
{
  //2.创建结构体数组
  struct Student stuArray[3] =
  {
    {"张三",18,100},
    {"李四",16,89},
    {"王五",18,98}
  };
  //3.给结构体数组赋值
  stuArray[2].name = "张六";
  stuArray[2].age = 19;
  stuArray[2].score = 90;
  //4.遍历结构体数组
  for (int i = 0; i &lt; 3; i++)
  {
    cout &lt;&lt; "姓名：" &lt;&lt; stuArray[i].name 
      &lt;&lt; " 年龄：" &lt;&lt; stuArray[i].age 
      &lt;&lt; " 分数：" &lt;&lt; stuArray[i].score &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3-结构体指针"><a href="#8-3-结构体指针" class="headerlink" title="8.3 结构体指针"></a>8.3 结构体指针</h3><p>作用: 通过指针访问结构体中的成员</p><ul><li>利用操作符<code>-&gt;</code>可以通过结构体指针访问结构体属性</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//结构体指针
#include&lt;string&gt;
struct Student
{
  string name;
  int age;
  int score;
};
int main()
{
  //1.创建结构体变量
  Student s = { "张三",18,90 };
  //2.通过指针指向结构体变量
  Student* p = &amp;s;
  //3.通过指针访问数据
  cout &lt;&lt; "姓名：" &lt;&lt; p-&gt;name
    &lt;&lt; " 年龄：" &lt;&lt; p-&gt;age
    &lt;&lt; " 分数：" &lt;&lt; p-&gt;score &lt;&lt; endl;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-4-结构体嵌套结构体"><a href="#8-4-结构体嵌套结构体" class="headerlink" title="8.4 结构体嵌套结构体"></a>8.4 结构体嵌套结构体</h3><p>作用: 结构体中的成员可以是另一个结构体</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//结构体嵌套
#include&lt;string&gt;
struct Student
{
  string name;
  int age;
  int score;
};
struct Teacher
{
  int id;
  string name;
  int age;
  struct Student stu;
};

int main()
{
  //1.创建结构体变量
  Teacher t;
  t.id = 10;
  t.name = "老王";
  t.age = 50;
  t.stu.name = "小王";
  t.stu.age = 18;
  t.stu.score = 100;
  cout &lt;&lt; "老师姓名：" &lt;&lt; t.name
    &lt;&lt; " 老师年龄：" &lt;&lt; t.age
    &lt;&lt; "学生姓名：" &lt;&lt; t.stu.name
    &lt;&lt; " 学生年龄：" &lt;&lt; t.stu.age
    &lt;&lt; " 学生分数：" &lt;&lt; t.stu.score &lt;&lt; endl;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-5-结构体做函数参数"><a href="#8-5-结构体做函数参数" class="headerlink" title="8.5 结构体做函数参数"></a>8.5 结构体做函数参数</h3><p>作用: 将结构体作为参数向函数中传递</p><p>传递方式有俩种:</p><ul><li>值传递</li><li>地址传递</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
struct student
{
  string name;
  int age;
  int score;
};
//值传递
void  printStudent1(struct student s)
{
  cout &lt;&lt; "值传递子函数 : 姓名：" &lt;&lt; s.name &lt;&lt; endl;
  cout &lt;&lt; "值传递子函数 : 年龄：" &lt;&lt; s.age &lt;&lt; endl;
  cout &lt;&lt; "值传递子函数 : 分数：" &lt;&lt; s.score &lt;&lt; endl;
}
//地址传递
void  printStudent2(struct student *p)
{
  cout &lt;&lt; "地址传递子函数 : 姓名：" &lt;&lt; p-&gt;name &lt;&lt; endl;
  cout &lt;&lt; "地址传递子函数 : 年龄：" &lt;&lt; p-&gt;age &lt;&lt; endl;
  cout &lt;&lt; "地址传递子函数 : 分数：" &lt;&lt; p-&gt;score &lt;&lt; endl;
}
int main()
{
  struct student s;
  s.name = "张三";
  s.age = 20;
  s.score = 85;
  cout &lt;&lt; "main : 姓名：" &lt;&lt; s.name &lt;&lt; endl;
  cout &lt;&lt; "main : 年龄：" &lt;&lt; s.age&lt;&lt; endl;
  cout &lt;&lt; "main : 分数：" &lt;&lt; s.score &lt;&lt; endl;
  printStudent1(s);
  printStudent2(&amp;s);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.png"></p><blockquote><p>总结:如果不想修改主函数中的数据用值传递,反之用地址传递</p></blockquote><h3 id="8-6-结构体中const使用场景"><a href="#8-6-结构体中const使用场景" class="headerlink" title="8.6 结构体中const使用场景"></a>8.6 结构体中const使用场景</h3><p>作用: 用const来防止误操作</p><h5 id="案例-结构体"><a href="#案例-结构体" class="headerlink" title="案例: 结构体"></a>案例: 结构体</h5><p>案例描述: 设计一个英雄的结构体,包括成员姓名,年龄,性别;创建结构体数组,数组中存放5名英雄。通过冒泡排序算法,将数组中的英雄按照年龄进行升序排序,最终打印排序后的结果</p><p>五名英雄信息如下:</p><pre class="line-numbers language-none"><code class="language-none">{"刘备",23,"男"},
{"关羽",22,"男"},
{"张飞",20,"男"},
{"赵云",21,"男"},
{"貂蝉",19,"女"},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//英雄结构体
struct Hero
{
  string name;
  int age;
  string sex;
};
void bubbleSort(struct Hero heroArray[], int length)
{
  for (int i = 0; i &lt; length-1; i++)
  {
    for (int j = 0; j &lt; length-i-1; j++)
    {
      if (heroArray[j].age &gt; heroArray[j + 1].age)
      {
        struct Hero temp = heroArray[j];
        heroArray[j] = heroArray[j + 1];
        heroArray[j + 1] = temp;
      }
    }
  }
}
void printHero(struct Hero heroArray[], int length)
{
  for (int i = 0; i &lt; length; i++)
  {
    cout &lt;&lt; "姓名：" &lt;&lt; heroArray[i].name &lt;&lt; " 年龄：" &lt;&lt; heroArray[i].age &lt;&lt; " 性别：" &lt;&lt; heroArray[i].sex &lt;&lt; endl;
  }
}
int main()
{
  struct Hero heroArray[5] = {
  {"刘备",23,"男"},
    {"关羽",22,"男"},
    {"张飞",20,"男"},
    {"赵云",21,"男"},
    {"貂蝉",19,"女"} };
  int length = sizeof(heroArray) / sizeof(heroArray[0]);
  cout &lt;&lt; "排序前:" &lt;&lt; endl;
  printHero(heroArray, length);
  bubbleSort(heroArray, length);
  cout &lt;&lt; "排序后:" &lt;&lt; endl;
  printHero(heroArray, length);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><p><img src="/liaojie.github.io/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/liaojie1314/PicGo/images/%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B.png"></p><h5 id="通讯录管理系统"><a href="#通讯录管理系统" class="headerlink" title="通讯录管理系统"></a>通讯录管理系统</h5><p>功能要求:</p><ul><li>菜单功能:用户选择功能的界面 void showMenu()</li><li>添加联系人:向通讯录中添加新人,信息包括(姓名、性别、年龄、联系电话、家庭地址)最多记录1000人<br>步骤:<ul><li>设计联系人结构体</li><li>设计通讯录结构体</li><li>main函数中创建通讯录</li><li>封装添加联系人函数</li><li>测试添加联系人功能</li></ul></li><li>显示联系人:显示通讯录中所有联系人的信息<br>步骤:<ul><li>封装显示联系人函数</li><li>测试显示联系人功能</li></ul></li><li>删除联系人:按照姓名进行删除指定联系人<br>步骤:<ul><li>封装检测联系人是否存在</li><li>封装删除联系人函数</li><li>测试删除指定联系人</li></ul></li><li>查找联系人:按照姓名查看指定联系人信息<br>步骤:<ul><li>封装查找联系人函数</li><li>测试查找指定联系人</li></ul></li><li>修改联系人:按照姓名重新修改指定联系人<br>步骤:<ul><li>封装修改联系人函数</li><li>测试修改指定联系人</li></ul></li><li>清空联系人:清空通讯录中所有信息</li><li>退出通讯录:退出当前使用的通讯录 当用户选择0时,退出</li></ul><p>提示代码:<br><code>system("cls");</code>//清屏</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
#define MAX 1000
//联系人结构体
struct Person
{
  string m_Name;
  int  m_Sex;
  int m_Age;
  string m_Phone;
  string m_Addr;
};
//通讯录结构体
struct Addressbooks
{
  struct Person personArray[MAX];
  int m_Size;
};
//添加联系人
void addPerson(Addressbooks* abs)
{
  if (abs-&gt;m_Size==MAX)
  {
    cout &lt;&lt; "通讯录已满，无法添加" &lt;&lt; endl;
    return;
  }
  else
  {
    string name;
    cout &lt;&lt; "请输入姓名:" &lt;&lt; endl;
    cin &gt;&gt; name;
    abs-&gt;personArray[abs-&gt;m_Size].m_Name = name;
    cout &lt;&lt; "请输入性别:" &lt;&lt; endl;
    cout &lt;&lt; "1  ---  男" &lt;&lt; endl;
    cout &lt;&lt; "2  ---  女" &lt;&lt; endl;
    int sex = 0;
    
    while (true)
    {
      cin &gt;&gt; sex;
      if (sex==1||sex==2)
      {
        abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;
        break;
      }
      cout &lt;&lt; "输入有误，重新输入" &lt;&lt; endl;
    }
    cout &lt;&lt; "请输入年龄:" &lt;&lt; endl;
    int age = 0;
    while (true)
    {
      
      cin &gt;&gt; age;
      if (age &gt; 0 &amp;&amp; age&lt;150)
      {
        abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;
        break;
      }
      cout &lt;&lt; "输入有误，重新输入" &lt;&lt; endl;
    }
    
    cout &lt;&lt; "请输入联系电话:" &lt;&lt; endl;
    string phone;
    cin &gt;&gt; phone;
    abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;
    cout &lt;&lt; "请输入家庭住址:" &lt;&lt; endl;
    string address;
    cin &gt;&gt; address;
    abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address;
    abs-&gt;m_Size++;//更新
    cout &lt;&lt; "添加成功" &lt;&lt; endl;
    system("pause");
    system("cls");//清屏
  }
}
//显示联系人
void showPerson(Addressbooks* abs)
{
  if (abs-&gt;m_Size == 0)
  {
    cout &lt;&lt; "当前记录为空" &lt;&lt; endl;
  }
  else
  {
    for (int i = 0; i &lt; abs-&gt;m_Size; i++)
    {
      cout &lt;&lt; "姓名：" &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; "\t";
      cout &lt;&lt; "性别：" &lt;&lt; (abs-&gt;personArray[i].m_Sex==1?"男":"女")&lt;&lt; "\t";
      cout &lt;&lt; "年龄：" &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; "\t";
      cout &lt;&lt; "电话：" &lt;&lt; abs-&gt;personArray[i].m_Phone&lt;&lt; "\t";
      cout &lt;&lt; "地址：" &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl;

    }
  }
  system("pause");
  system("cls");
}
//检查联系人是否存在，存在返回其在数组中位置，不存在返回-1
int isExist(Addressbooks* abs, string name)
{
  for (int i = 0; i &lt; abs-&gt;m_Size; i++)
  {
    if (abs-&gt;personArray[i].m_Name == name)
    {
      return i;
    }
  }
  return -1;
}
//删除联系人
void deletePerson(Addressbooks* abs)
{
  cout &lt;&lt; "请输入删除的联系人" &lt;&lt; endl;
  string name;
  cin &gt;&gt; name;
  int ret = isExist(abs, name);
  if ( ret!= -1)
  {
    for (int i = ret; i &lt; abs-&gt;m_Size; i++)
    {
      //数据前移
      abs-&gt;personArray[i] = abs-&gt;personArray[i + 1];
    }
    abs-&gt;m_Size--;//更新
    cout &lt;&lt; "删除成功" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "查无此人" &lt;&lt; endl;
  }
  system("pause");
  system("cls");//清屏
}
//查找联系人
void findPerson(Addressbooks *abs)
{
  cout &lt;&lt; "请输入要查找的联系人" &lt;&lt; endl;
  string name;
  cin &gt;&gt; name;
  int ret=isExist(abs, name);
  if (ret != -1)
  {
    cout &lt;&lt; "姓名：" &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; "\t";
    cout &lt;&lt; "性别：" &lt;&lt; (abs-&gt;personArray[ret].m_Sex == 1 ? "男" : "女") &lt;&lt; "\t";
    cout &lt;&lt; "年龄：" &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; "\t";
    cout &lt;&lt; "电话：" &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; "\t";
    cout &lt;&lt; "地址：" &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "查无此人" &lt;&lt; endl;
  }
  system("pause");
  system("cls");//清屏
}
//修改联系人
void modifyPerson(Addressbooks* abs)
{
  cout &lt;&lt; "请输入要修改的联系人" &lt;&lt; endl;
  string name;
  cin &gt;&gt; name;
  int ret = isExist(abs, name);
  if (ret != -1)
  {
    string name;
    cout &lt;&lt; "请输入姓名:" &lt;&lt; endl;
    cin &gt;&gt; name;
    abs-&gt;personArray[ret].m_Name = name;
    cout &lt;&lt; "请输入性别:" &lt;&lt; endl;
    cout &lt;&lt; "1  ---  男" &lt;&lt; endl;
    cout &lt;&lt; "2  ---  女" &lt;&lt; endl;
    int sex = 0;

    while (true)
    {
      cin &gt;&gt; sex;
      if (sex == 1 || sex == 2)
      {
        abs-&gt;personArray[ret].m_Sex = sex;
        break;
      }
      cout &lt;&lt; "输入有误，重新输入" &lt;&lt; endl;
    }
    cout &lt;&lt; "请输入年龄:" &lt;&lt; endl;
    int age = 0;
    while (true)
    {
      cin &gt;&gt; age;
      if (age &gt; 0 &amp;&amp; age &lt; 150)
      {
        abs-&gt;personArray[ret].m_Age = age;
        break;
      }
      cout &lt;&lt; "输入有误，重新输入" &lt;&lt; endl;
    }
    cout &lt;&lt; "请输入联系电话:" &lt;&lt; endl;
    string phone;
    cin &gt;&gt; phone;
    abs-&gt;personArray[ret].m_Phone = phone;
    cout &lt;&lt; "请输入家庭住址:" &lt;&lt; endl;
    string address;
    cin &gt;&gt; address;
    abs-&gt;personArray[ret].m_Addr = address;
  }
  else
  {
    cout &lt;&lt; "查无此人" &lt;&lt; endl;
  }
  system("pause");
  system("cls");//清屏
}
//清空联系人
void clearPerson(Addressbooks* abs)
{
  abs-&gt;m_Size = 0;
  cout &lt;&lt; "通讯录已清空" &lt;&lt; endl;
  system("pause");
  system("cls");//清屏
}
//菜单界面
void showMenu()
{
  cout &lt;&lt; "************************" &lt;&lt; endl;
  cout &lt;&lt; "***** 1.添加联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 2.显示联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 3.删除联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 4.查找联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 5.修改联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 6.清空联系人 *****" &lt;&lt; endl;
  cout &lt;&lt; "***** 0.退出通讯录 *****" &lt;&lt; endl;
  cout &lt;&lt; "************************" &lt;&lt; endl;
}
int main()
{
  Addressbooks abs;
  abs.m_Size = 0;
  int select = 0;
  while (true)
  {
    showMenu();//菜单
    cin &gt;&gt; select;
    switch (select)
    {
    case 1://1.添加联系人
      addPerson(&amp;abs);//地址传递，可以修饰实参
      break;
    case 2://2.显示联系人
      showPerson(&amp;abs);
      break;
    case 3://3.删除联系人
      deletePerson(&amp;abs);
      break;
    case 4://4.查找联系人
      findPerson(&amp;abs);
      break;
    case 5://5.修改联系人
      modifyPerson(&amp;abs);
      break;
    case 6://6.清空联系人
      clearPerson(&amp;abs);
      break;
    case 0://0.退出通讯录
      cout &lt;&lt; "欢迎下次使用!" &lt;&lt; endl;
      system("pause");
      return 0;
      break;
    default:
      cout &lt;&lt; "请重新输入" &lt;&lt; endl;
      break;
    }
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-C-核心编程"><a href="#2-C-核心编程" class="headerlink" title="2 C++核心编程"></a>2 C++核心编程</h2><h3 id="2-1-内存分区模式"><a href="#2-1-内存分区模式" class="headerlink" title="2.1 内存分区模式"></a>2.1 内存分区模式</h3><ul><li>代码区:存放函数体的二进制代码,由操作系统进行管理的 特点:共享、只读</li><li>全局区:存放全局变量和静态变量以及常量 该区域的数据在程序结束后由操作系统释放</li><li>栈区:由编译器自动分配释放,存放函数的参数值,局部变量等 不要返回局部变量的地址:第一次可以正确打印是因为编译器做了保留,第二次这个数据就不再保留了</li><li>堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 主要利用new在堆区开辟内存</li></ul><p>程序运行前:代码区、全局区</p><p>不在全局区：局部变量，const修饰局部变量(局部常量)<br>全局区：全局变量，静态变量(static关键字修饰 eg:static int s_a = 10),常量:字符串常量、const修饰全局变量</p><p>程序运行后:栈区、堆区</p><p><strong>内存4区意义:</strong><br>不同区域存放的数据,赋予不同的生命周期,给我们更大的灵活编程</p><p>指针本质是局部变量</p><h4 id="2-1-1-new操作符"><a href="#2-1-1-new操作符" class="headerlink" title="2.1.1 new操作符"></a>2.1.1 new操作符</h4><p>C++中利用<code>new</code>操作符在堆区开辟数据<br>堆区开辟的数据,由程序员手动开辟、手动释放,释放利用操作符<code>delete</code></p><p>语法: <code>new 数据类型</code></p><p>利用new创建的数据,会返回该数据对应的类型的指针<br>释放数组<code>delete[] arr;</code></p><h3 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h3><h4 id="2-2-1-引用的基本使用"><a href="#2-2-1-引用的基本使用" class="headerlink" title="2.2.1 引用的基本使用"></a>2.2.1 引用的基本使用</h4><p>作用: 给变量起别名</p><p>语法: <code>数据类型 &amp;别名 = 原名</code></p><ul><li>引用必须初始化</li><li>引用一旦初始化就不能更改</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

int main()
{
  //引用基本语法:
  //数据类型 &amp;别名=原名
  int a = 10;
  int&amp; b = a;
  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
  int c = 100;
  b = c;//赋值操作不是更改应用
  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
}
//a=10,b=10
//a=100,b=100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-引用做函数参数"><a href="#2-2-2-引用做函数参数" class="headerlink" title="2.2.2 引用做函数参数"></a>2.2.2 引用做函数参数</h4><p>作用: 函数传参时,可以利用引用的技术让形参修饰实参<br>优点: 简化指针修改实参</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

int main()
{
  int a = 10;
  int b = 20;
  mySwap(a,b);
  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
}
//引用做函数参数
//优点:简化指针修改实参
//作用：让形参修饰实参
void mySwap(int &amp;a,int &amp;b)
{
  int temp=a;
  a=b;
  b=temp;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-引用做函数返回值"><a href="#2-2-3-引用做函数返回值" class="headerlink" title="2.2.3 引用做函数返回值"></a>2.2.3 引用做函数返回值</h4><p>作用: 引用是可以作为函数的返回值存在的</p><p>1.不能返回局部变量的引用<br>2.函数的调用可以作为左值</p><p>本质：指针常量 int * const ref = &amp;a</p><h4 id="2-2-4-常量引用"><a href="#2-2-4-常量引用" class="headerlink" title="2.2.4 常量引用"></a>2.2.4 常量引用</h4><p>作用: 常量引用主要用来修饰形参,防止误操作</p><p>在函数形参列表中,可以加<code>const修饰形参</code>,防止形参改变实参</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
void showValue(const int&amp; val);

int main()
{
  //常量引用
  /*int a = 10;
  int&amp; ref = a;*/
  //const int&amp; ref = 10;//加入const变为只读，不能修改
  int a = 100;
  showValue(a);
  system("pause");
  return 0;
}
void showValue(const int&amp; val)
{
  cout &lt;&lt; "val=" &lt;&lt; val &lt;&lt; endl;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-函数-提升"><a href="#2-3-函数-提升" class="headerlink" title="2.3 函数(提升)"></a>2.3 函数(提升)</h3><h4 id="2-3-1-函数默认参数"><a href="#2-3-1-函数默认参数" class="headerlink" title="2.3.1 函数默认参数"></a>2.3.1 函数默认参数</h4><p>在C++中,函数的形参列表中的形参是可以有默认值的</p><p>语法: <code>返回值类型 函数名 (参数 = 默认值){}</code></p><p>注意:<br>1.如果某个位置已经有了默认参数,那么从这个位置往后,从左往右都必须有默认值<br>2.如果函数声明有默认参数,函数实现就不能有默认参数(声明和实现只能有一个默认参数)</p><h4 id="2-3-2-函数占位参数"><a href="#2-3-2-函数占位参数" class="headerlink" title="2.3.2 函数占位参数"></a>2.3.2 函数占位参数</h4><p>语法: <code>返回值类型 函数名 (数据类型){}</code></p><p>占位参数也可以有默认参数(void func(int a,int = 10))</p><h4 id="2-3-3-函数重载"><a href="#2-3-3-函数重载" class="headerlink" title="2.3.3 函数重载"></a>2.3.3 函数重载</h4><p>作用: 函数名可以相同,提高复用性</p><p>条件：<br>1.同一作用域<br>2.函数名称相同<br>3.函数参数<em>类型不同</em>，或者<em>个数不同</em>，或者<em>顺序不同</em></p><p>函数返回值不可以作为函数重载的条件</p><ul><li>引用可作为重载条件：void func(int&amp; a)(传入变量时执行)与 void func(const int&amp; a)（传入数据时执行）</li><li>函数重载遇到函数默认参数</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
void func()
{
  cout &lt;&lt; "func()的调用" &lt;&lt; endl;
}
void func(int a)
{
  cout &lt;&lt; "func(int a)的调用" &lt;&lt; endl;
}
void func(double a)
{
  cout &lt;&lt; "func(double a)的调用" &lt;&lt; endl;
}
void func(int a,double b)
{
  cout &lt;&lt; "func(int a,double b)的调用" &lt;&lt; endl;
}
void func(double a,int b)
{
  cout &lt;&lt; "func(double a,int b)的调用" &lt;&lt; endl;
}
int main()
{
  //条件：
  //1.同一作用域
  //2.函数名称相同
  //3.函数参数类型不同，或者个数不同，或者顺序不同
  //函数返回值不可以作为函数重载的条件
  //func();
  //func(10);
  //func(3.14);
  //func(10,3.14);
  func(3.14,10);
  //引用可作为重载条件：void func(int&amp; a)(传入变量执行)与 void func(const int&amp; a)（传入数据执行）
  
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-类和对象"><a href="#2-4-类和对象" class="headerlink" title="2.4 类和对象"></a>2.4 类和对象</h3><p>C++面向对象三大特性为:<code>封装、继承、多态</code></p><p>C++认为<code>万事万物皆为对象</code>,对象上有其属性和行为</p><p>具有相同性质的对象可以抽象称为类</p><h4 id="2-4-1-封装"><a href="#2-4-1-封装" class="headerlink" title="2.4.1 封装"></a>2.4.1 封装</h4><p>封装的意义:</p><ul><li>将属性和行为作为一个整体,表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p>封装意义一:<br>在设计类的时候,属性和行为写在一起,表现事物</p><p>语法: <code>class 类名{ 访问权限: 属性 / 行为 };</code></p><p>类中的属性和行为 我们统一称为 成员<br>属性: 成员属性 成员变量<br>行为: 成员函数 成员方法</p><p>封装意义二:<br>类在设计时,可以把属性和行为放在不同的权限下,加以控制<br>访问权限有三种:</p><p>1.public 公共权限 成员 类内可以访问 类外可以访问<br>2.protected保护权限 成员 类内可以访问 类外不可以访问 儿子可以访问父亲中的保护内容<br>3.private 私有权限 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中的私有内容</p><p><strong>struct和class区别:</strong></p><ul><li>struct默认权限为公共</li><li>class默认权限为私有</li></ul><p><strong>成员属性设置为私有:</strong><br>优点:<br>1.将所有成员属性设置为私有,可以自己控制读写权限 set写;get读<br>2.对于写权限,我们可以检测数据的有效性</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//class 与 struct区别:
/*
* class默认私有
* struct默认公共
*/
class Student
{//类中属性与行为称为成员
  //属性 成员属性 成员变量 (设置为私有)
  //行为 成员函数 成员方法
public://权限：
  /*
  * public 公共 成员类内可以访问 成员类外可以访问
  * protected 保护 成员类内可以访问 成员类外不可以访问
  * private 私有 成员类内可以访问 成员类外不可以访问
  */
  string m_Name;
  int m_Id;
  void showStudent()//显示姓名与学号
  {
    cout &lt;&lt; "姓名：" &lt;&lt; m_Name &lt;&lt; ";学号：" &lt;&lt; m_Id &lt;&lt; endl;
  }
  //给姓名赋值
  void setName(string name)
  {
    m_Name = name;
  }
  //给学号赋值
  void setId(int id)
  {
    m_Id = id;
  }
protected:
  string m_Car;
private:
  string m_Password;
public:
  void func()
  {
    m_Name = "张三";
    m_Car = "bike";
    m_Password = "123456";
  }
};
/*int main()
{
  Student s1;
  //s1.m_Name = "张三";
  s1.setName("张三");
  s1.m_Id = 1;
  s1.showStudent();
  system("pause");
  return 0;
}*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-设计立方体类"><a href="#案例-设计立方体类" class="headerlink" title="案例: 设计立方体类"></a>案例: 设计立方体类</h5><p>案例描述:</p><p>设计立方体类(Cube)<br>求出立方体的面积和体积<br>分别用全局函数和成员函数判断俩个立方体是否相等</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//创建类
class Cube
{
public:
  //设置长
  void setL(int l)
  {
    m_L = l;
  }
  //获取长
  int getL()
  {
    return m_L;
  }
  //设置宽
  void setW(int w)
  {
    m_W = w;
  }
  //获取宽
  int getW()
  {
    return m_W;
  }
  //设置高
  void setH(int h)
  {
    m_H = h;
  }
  //获取高
  int getH()
  {
    return m_H;
  }
  //获取立方体面积
  int calculateS()
  {
    return 2 * m_L*m_W + 2 * m_W*m_H + 2 * m_H*m_L;
  }
  //获取立方体体积
  int calculateV() {
    return m_L * m_W * m_H;
  }
  //利用成员函数判断俩个立方体是否相等
  bool isSameByClass(Cube &amp;c)
  {
    if (m_L == c.getL() &amp;&amp; m_W == c.getW() &amp;&amp; m_H == c.getH())
    {
      return true;
    }
    return false;
  }
private:
  int m_L;//长
  int m_W;//宽
  int m_H;//高
};
//利用全局函数判断俩立方体是否相等
bool isSame(Cube &amp;c1, Cube &amp;c2)
{
  if (c1.getL()==c2.getL()&amp;&amp;c1.getW()==c2.getW()&amp;&amp;c1.getH()==c2.getH())
  {
    return true;
  }
  return false;
}
int main()
{
  Cube c1;
  c1.setL(10);
  c1.setH(10);
  c1.setW(10);
  cout &lt;&lt; "面积为:" &lt;&lt; c1.calculateS() &lt;&lt; endl;
  cout &lt;&lt; "体积为:" &lt;&lt; c1.calculateV() &lt;&lt; endl;
  Cube c2;
  c2.setL(10);
  c2.setH(10);
  c2.setW(10);
  cout &lt;&lt; "全局函数判断" &lt;&lt; endl;
  bool ret = isSame(c1, c2);
  if (ret)
  {
    cout &lt;&lt; "c1与c2相等" &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; "c1与c2不相等" &lt;&lt; endl;
  }
  cout &lt;&lt; "成员函数判断" &lt;&lt; endl;
  ret = c1.isSameByClass(c2);
  if (ret)
  {
    cout &lt;&lt; "c1与c2相等" &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; "c1与c2不相等" &lt;&lt; endl;
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-点和圆的关系"><a href="#案例-点和圆的关系" class="headerlink" title="案例: 点和圆的关系"></a>案例: 点和圆的关系</h5><p>案例描述:<br>设计一个圆形类(Circle)和一个点类(Point),计算点和圆的关系</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//点与圆关系
#include&lt;iostream&gt;
using namespace std;
//点类
class Point
{
public:
  //设置x
  void setX(int x)
  {
    m_X = x;
  }
  //获取x
  int getX()
  {
    return m_X;
  }
  //设置y
  void setY(int y)
  {
    m_Y = y;
  }
  //获取y
  int getY()
  {
    return m_Y;
  }
private:
  int m_X;
  int m_Y;
};
//圆类
class Circle
{
public:
  //设置半径
  void setR(int r)
  {
    m_R = r;
  }
  //获取半径
  int getR()
  {
    return m_R;
  }
  //设置圆心
  void setCenter(Point center)
  {
    m_Center=center;
  }
  //获取圆心
  Point getCenter()
  {
    return m_Center;
  }
private:
  int m_R;
  Point m_Center;
};
void isInCircle(Circle&amp; c, Point&amp; p)
{
  //计算俩点间距离平方
  int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
    (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());
  //计算半径平方
  int rDistance = c.getR() * c.getR();
  if (distance==rDistance)
  {
    cout &lt;&lt; "点在圆上" &lt;&lt; endl;
  }
  else if (distance&gt;rDistance)
  {
    cout &lt;&lt; "点在圆外" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "点在圆内" &lt;&lt; endl;
  }
}
int main()
{
  Circle c;
  c.setR(10);
  Point center;
  center.setX(10);
  center.setY(0);
  c.setCenter(center);

  Point p;
  p.setX(10);
  p.setY(10);
  isInCircle(c, p);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分文件:</p><p>point.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
//点类
class Point
{
public:
  //设置x
  void setX(int x);
  //获取x
  int getX();
  //设置y
  void setY(int y);
  //获取y
  int getY();
private:
  int m_X;
  int m_Y;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>point.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"point.h"
//点类
//设置x
void Point::setX(int x)
{
  m_X = x;
}
//获取x
int Point::getX()
{
  return m_X;
}
//设置y
void Point::setY(int y)
{
  m_Y = y;
}
//获取y
int Point::getY()
{
  return m_Y;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>circle.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include"point.h"
//圆类
class Circle
{
public:
  //设置半径
  void setR(int r);
  //获取半径
  int getR();
  //设置圆心
  void setCenter(Point center);
  //获取圆心
  Point getCenter();
private:
  int m_R;
  Point m_Center;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>circle.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"circle.h"
//圆类
//设置半径
void Circle::setR(int r)
{
  m_R = r;
}
//获取半径
int Circle::getR()
{
  return m_R;
}
//设置圆心
void Circle::setCenter(Point center)
{
  m_Center = center;
}
//获取圆心
Point Circle::getCenter()
{
  return m_Center;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//点与圆关系
#include&lt;iostream&gt;
using namespace std;
#include"point.h"
#include"circle.h"
void isInCircle(Circle&amp; c, Point&amp; p)
{
  //计算俩点间距离平方
  int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
    (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());
  //计算半径平方
  int rDistance = c.getR() * c.getR();
  if (distance==rDistance)
  {
    cout &lt;&lt; "点在圆上" &lt;&lt; endl;
  }
  else if (distance&gt;rDistance)
  {
    cout &lt;&lt; "点在圆外" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "点在圆内" &lt;&lt; endl;
  }
}
int main()
{
  Circle c;
  c.setR(10);
  Point center;
  center.setX(10);
  center.setY(0);
  c.setCenter(center);

  Point p;
  p.setX(10);
  p.setY(10);
  isInCircle(c, p);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-对象的初始化和清理"><a href="#2-4-2-对象的初始化和清理" class="headerlink" title="2.4.2 对象的初始化和清理"></a>2.4.2 对象的初始化和清理</h4><p>构造函数和析构函数:解决对象的初始化和清理问题</p><p>如果我们不提供构造和析构,编译器会提供编译器提供的构造函数和析构函数是空实现。</p><p><strong>构造函数语法:</strong><code>类名(){}</code><br>1.构造函数无返回值 不用写void<br>2.函数名与类名相同<br>3.可以有参数，可以发生重载<br>4.创建对象时会自动调用构造函数且只调用一次</p><p><strong>析构函数:</strong><code>~类名(){}</code><br>1.无返回值 不用写void<br>2.函数名与类名相同 在名称前加<code>~</code><br>3.不可以有参数，不可以发生重载<br>4.对象在销毁前会自动调用，且只调用一次</p><p>构造函数的分类及调用<br>1.分类</p><ul><li>按参数分:有参构造和无参构造</li><li>按类型分:普通构造和拷贝构造</li></ul><p>2.三种调用方式</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p>拷贝构造函数调用时机</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p>构造函数调用规则<br>默认情况下,C++编译器至少给一个类添加3个函数<br>1.默认构造函数(无参,函数体为空)<br>2.默认析构函数(无参,函数体为空)<br>3.默认拷贝构造函数,对属性进行值拷贝</p><p>构造函数调用规则如下:</p><ul><li>如果用户定义有参构造函数,C++不在提供默认无参构造,但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数,C++不会再提供其他构造函数</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;


class Person
{
public:
  //构造函数 初始化
/*1构造函数无返回值 不用写void
* 2.函数名与类名相同
* 3.可以有参数，可以发生重载
* 4.创建对象时，构造函数会自动调用，且只调用一次
*/
  Person()
  {
    cout &lt;&lt; "无参构造函数调用" &lt;&lt; endl;
  }
  Person(int a)
  {
    cout &lt;&lt; "有参构造函数调用" &lt;&lt; endl;
  }
  //析构函数 清理(作用：将堆区开辟数据做释放操作)
  /*
  * 1.无返回值 不用写void
  * 2.函数名与类名相同 在名称前加~
  * 3.不可以有参数，不可以发生重载
  * 4.对象在销毁前会自动调用，且只调用一次
  */
  ~Person()
  {
    cout &lt;&lt; "析构函数调用" &lt;&lt; endl;
  }
  //拷贝构造函数
  Person(const Person&amp; p)
  {
    cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl;
  }
};
void test01()
{
  //调用
  //1.括号法
  //Person p1;//栈上数据，test01执行完毕后会释放这个对象
  //Person p2(10);
  //Person p3(p2);
  //2.显示法
  Person p1;
  Person p2=Person(10);
  Person p3=Person(p2);
  Person(10);//匿名对象 (不能用拷贝对象初始化)
  //3.隐式转换法
  Person p4 = 10;
  Person p5 = p4;
}
int main()
{
  //test01();
  Person p;
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>深拷贝和浅拷贝:<br>浅拷贝:简单的赋值拷贝操作<br>深拷贝:在堆区重新申请空间,进行拷贝操作</p><p>浅拷贝：问题：堆区内存重复释放<br>深拷贝：<code>m_Height=new int(*p.m_Height);</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class Person
{
public:
  Person()
  {
    cout &lt;&lt; "Person默认构造函数调用" &lt;&lt; endl;
  }
  Person(int age,int height)
  {
    m_Age = age;
    m_Height = new int(height);
    cout &lt;&lt; "Person有参构造函数调用" &lt;&lt; endl;
  }
  Person(const Person&amp; p)
  {
    cout &lt;&lt; "拷贝构造函数的调用" &lt;&lt; endl;
    m_Age = p.m_Age;
    //m_Height = p.m_Height;编译器默认实现
    //深拷贝操作
    m_Height = new int(*p.m_Height);
  }
  ~Person()
  {
    //析构代码,将堆区开辟的数据释放
    if (m_Height != NULL)
    {
      delete m_Height;
      m_Height = NULL;
    }
    cout &lt;&lt; "Person析构函数调用" &lt;&lt; endl;
  }
  int m_Age;//年龄
  int* m_Height;
};
void test01()
{
  Person p1(18,160);
  cout &lt;&lt; "p1的年龄:" &lt;&lt; p1.m_Age &lt;&lt;"身高:"&lt;&lt;*p1.m_Height&lt;&lt; endl;
  Person p2(p1);
  cout &lt;&lt; "p2的年龄:" &lt;&lt; p2.m_Age &lt;&lt; "身高:" &lt;&lt; *p2.m_Height &lt;&lt; endl;

}
int main()
{
  test01();
  system("pause");
  return 0;
  /*
  Person有参构造函数调用
  p1的年龄:18身高:160
  拷贝构造函数的调用
  p2的年龄:18身高:160
  Person析构函数调用
  Person析构函数调用
  */
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>初始化列表:</strong></p><p>作用: C++提供了初始化列表语法,用来初始化属性</p><p>语法: <code>构造函数():属性1(值1),属性2(值2)...{}</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class Person
{
public:
  //传统初始化
  /*Person(int a, int b, int c)
  {
    m_A = a;
    m_B = b;
    m_C = c;
  }*/
  //初始化列表
  Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c)
  {

  }
  int m_A;
  int m_B;
  int m_C;
};
void test01()
{
  //Person p(10, 20, 30);
  Person p(30, 20, 10);
  cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; endl;
  cout &lt;&lt; "m_B=" &lt;&lt; p.m_B &lt;&lt; endl;
  cout &lt;&lt; "m_C=" &lt;&lt; p.m_C &lt;&lt; endl;

}
int main()
{
  test01();
  system("pause");
  return 0;
}
//m_A=30
//m_B=20
//m_C=10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类对象作为类成员:</strong></p><p>C++类中的成员可以是另一个类的对象,我们称该成员为对象成员</p><p>例如:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A{}
class B
{
  A a;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B类中有对象A作为成员,A为对象成员</p><p>当其他类对象作为本类成员,构造时先构造类对象,再构造自身<br>构造先构造其他再构造自身，析构与其相反</p><p><strong>静态成员:</strong></p><p>静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员</p><p>静态成员分为:</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><h4 id="2-4-3-C-对象模型和this指针"><a href="#2-4-3-C-对象模型和this指针" class="headerlink" title="2.4.3 C++对象模型和this指针"></a>2.4.3 C++对象模型和this指针</h4><p>类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上</p><p>空对象占用内存空间为1<br>C++编译器会给每个空对象分配一个字节的空间,是为了区分空对象占内存的位置<br>每个空对象也应该有一个独一无二的内存空间</p><p><strong>this指针:</strong><br><code>this指针指向被调用的成员函数所属的对象</code></p><p>this指针是隐含每一个非静态的成员函数内的一种指针<br>this指针不需要定义,直接使用即可</p><p>this指针用途:</p><ul><li>当形参和成员变量同名时,可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身,可使用<code>return *this</code></li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//this：指向被调用成员函数所属的对象 

class Person
{
public:
  Person(int age)
  {
    this-&gt;age = age;
  }
  Person&amp; PersonAddAge(Person &amp;p)//返回引用
  {
    this-&gt;age += p.age;
    return *this;//this 为指向p2的指针
  }
  int age;
};
//1.解决名称冲突
void test01()
{
  Person p1(18);
  cout &lt;&lt; "p1的年龄为" &lt;&lt; p1.age &lt;&lt; endl;
}
//2.返回对象本身用*this
void test02()
{
  Person p1(10);
  Person p2(10);
  p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);//链式编程
  cout &lt;&lt; "p2的年龄为" &lt;&lt; p2.age &lt;&lt; endl;

}
int main()
{
  test02();
  system("pause");
  return 0;
}
//p2的年龄为40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空指针访问成员函数:</strong><br>C++中空指针也是可以调用成员函数的,但是也要注意有没有用到this指针</p><p>如果用到this指针,需要加以判断保证代码的健壮性</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(this==NULL)
{
  return;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>const修饰成员函数:</strong></p><p>常函数:</p><ul><li>成员函数后加const后我们称为这个函数为<em>常函数</em></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后,在常函数中依然可以修改</li></ul><p>常对象:</p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//常函数
class Person
{
public:
  //this指针本质：指针常量：指针指向不可以修改
  //const Person* const this;
  void showPerson() const//修饰this指针，让this指向的值也不能修改
  {
    this-&gt;m_B = 100;
  }
  int m_A;
  mutable int m_B;//即使在常函数中也可以修改
};
void test01()
{
  Person p;
  p.showPerson();
}

void test02()
{
  const Person p;//常对象:只能调用常函数
  p.m_B = 100;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-4-友元"><a href="#2-4-4-友元" class="headerlink" title="2.4.4 友元"></a>2.4.4 友元</h4><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>关键字:<code>friend</code></p><p>友元三种实现:</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//友元：friend
/*
* 1.全局函数做友元：在class 添加：friend 全局函数;(friend void Person(Building* building);)
* 2.类做友元：在class 添加：friend 类;(friend class Person;)
* 3.成员函数做友元：在class 添加：friend 成员函数;(friend void Person::visit();)
*/
class Building
{
  //可以访问Building中私有成员
  friend void goodGay(Building* building);
public:
  Building()
  {
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
  }
public:
  string m_SittingRoom;
private:
  string m_BedRoom;
};
//全局函数
void goodGay(Building *building)
{
  cout &lt;&lt; "访问" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
  cout &lt;&lt; "访问" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}
void test01()
{
  Building building;
  goodGay(&amp;building);
}
int main()
{
  test01();
  //类外构造函数 类名::函数名（）{}
  system("pause");
  return 0;
}
//访问客厅
//访问卧室<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-5-运算符重载"><a href="#2-4-5-运算符重载" class="headerlink" title="2.4.5 运算符重载"></a>2.4.5 运算符重载</h4><p>对已有的运算符重新进行定义,赋予其另一种功能,以适应不用的数据类型</p><p>加法重载代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//运算符重载也可以发生函数重载
//加法
#include&lt;iostream&gt;
using namespace std;
class Person
{
public:
  //1.成员函数
  //Person operator+(Person&amp; p)
  //{
    //Person temp;
    //temp.m_A = this-&gt;m_A + p.m_A;
    //temp.m_B = this-&gt;m_B + p.m_B;
    //return temp;
  //}
  int m_A;
  int m_B;
};
//全局函数
Person operator+(Person&amp; p1,Person &amp;p2)
{
  Person temp;
  temp.m_A = p1.m_A + p2.m_A;
  temp.m_B = p1.m_B + p2.m_B;
  return temp;
}
void test01()
{
  Person p1;
  p1.m_A = 10;
  p1.m_B = 10;
  Person p2;
  p2.m_A = 10;
  p2.m_B = 10;
  Person p3 = p1 + p2;
  cout &lt;&lt; "p3.m_A=" &lt;&lt; p3.m_A &lt;&lt; endl;
  cout &lt;&lt; "p3.m_B=" &lt;&lt; p3.m_B &lt;&lt; endl;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>左移重载:<br>作用:可以输出自定义数据类型<br>不会利用成员函数重载<code>&lt;&lt;</code>运算符,因为无法实现cout在左边<br>只能利用全局函数重载左移运算符<br>左移重载代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//运算符重载也可以发生函数重载
//左移
#include&lt;iostream&gt;
using namespace std;
class Person
{
  friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p);
public:
  Person(int a,int b)
  {
    m_A = a;
    m_B = b;
  }
    
private:
  //成员函数:通常不用
  int m_A;
  int m_B;
};
//全局函数
ostream&amp; operator&lt;&lt;(ostream &amp;cout,Person &amp;p)
{
  cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; "m_B=" &lt;&lt; p.m_B;
  return cout;
}
void test01()
{
  Person p(10,10);
  cout &lt;&lt; p&lt;&lt;endl;
  
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递增重载:<br>作用:通过重载递增运算符,实现自己的整型数据<br>递增重载代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//运算符重载也可以发生函数重载
//递增
#include&lt;iostream&gt;
using namespace std;
class MyInteger
{
  friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);
    
public:
  MyInteger()
  {
    m_Num = 0;
  }
  //重载++前置
  MyInteger&amp; operator++()//返回引用是为了对一个数据进行++
  {
    m_Num++;
    return *this;
  }
  //重载++后置
  MyInteger operator++(int)//int 表示占位参数 可以用于区分前置和后置递增 返回值
  {
    //先记录，再递增，最后返回记录值
    MyInteger temp = *this;
    m_Num++;
    return temp;
  }
private:
  int m_Num;
};
//全局函数
ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)
{
  cout &lt;&lt;myint.m_Num;
  return cout;
}
void test01()
{
  MyInteger myint;
  cout &lt;&lt; ++myint &lt;&lt; endl;
  cout &lt;&lt; myint &lt;&lt; endl;
}
void test02()
{
  MyInteger myint1;
  cout &lt;&lt; myint1++ &lt;&lt; endl;
  cout &lt;&lt; myint1 &lt;&lt; endl;
}
int main()
{
  test01();
  test02();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>赋值重载:<br>C++编译器至少给一个类添加4个函数<br>1.默认构造函数(无参,函数体为空)<br>2.默认析构函数(无参,函数体为空)<br>3.默认拷贝构造函数,对属性进行值拷贝<br>4.赋值运算符 operator=,对属性进行值拷贝</p><p>如果类中有属性指向堆区,做赋值操作时也会出现深浅拷贝问题<br>赋值重载代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//运算符重载也可以发生函数重载
//赋值
#include&lt;iostream&gt;
using namespace std;
class Person
{
public:
  Person(int age)
  {
    m_Age = new int(age);
  }
  ~Person()
  {
    if (m_Age!= NULL)
    {
      delete m_Age;
      m_Age = NULL;
    }
  }
  //重载赋值
  Person&amp; operator=(Person&amp; p)
  {
    //深拷贝 先判断时是否有属性在堆区，如果有先释放干净，再进行深拷贝
    if (m_Age != NULL)
    {
      delete m_Age;
      m_Age = NULL;
    }
    m_Age = new int(*p.m_Age);//深拷贝
    return *this;
  }
  int *m_Age;
};
void test01()
{
  Person p1(18);
  Person p2(20);
  p2 = p1;//赋值
  cout &lt;&lt; "p1的年龄为" &lt;&lt; *p1.m_Age &lt;&lt; endl;
  cout &lt;&lt; "p2的年龄为" &lt;&lt; *p2.m_Age &lt;&lt; endl;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关系运算符重载:<br>作用:重载关系运算符,可以让俩个自定义类型对象进行对比操作<br>关系运算符重载代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//关系运算符
#include&lt;iostream&gt;
using namespace std;
class Person
{
public:
  Person(string name,int age)
  {
    m_Age = age;
    m_Name = name;
  }
  //重载==
  bool operator==(Person&amp; p)
  {
    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
    {
      return true;
    }
    return false;
  }
  //重载!=
  bool operator!=(Person&amp; p)
  {
    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
    {
      return false;
    }
    return true;
  }
  string m_Name;
  int m_Age;
};
void test01()
{
  Person p1("Tom", 18);
  Person p2("Tom", 18);
  if (p1 == p2)
  {
    cout &lt;&lt; "p1与p2相等" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "p1与p2不相等" &lt;&lt; endl;
  }
  if (p1 != p2)
  {
    cout &lt;&lt; "p1与p2不相等" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "p1与p2相等" &lt;&lt; endl;
  }
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数调用运算符重载:</p><ul><li>函数调用运算符()也可以发生重载</li><li>由于重载后使用的方式非常像函数的调用,因此称为仿函数</li><li>仿函数没有固定写法,非常灵活<br>小括号重载代码:</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//小括号 十分灵活
#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
class MyPrint
{
public:
  void operator() (string test)
  {
    cout &lt;&lt; test &lt;&lt; endl;
  }
};
void test01()
{
  MyPrint myPrint;
  myPrint("hello world");
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结:<br>1.对于内置的数据类型的表达式的运算符是不可能改变的<br>2.不要滥用运算符重载</p><h4 id="2-4-6-继承"><a href="#2-4-6-继承" class="headerlink" title="2.4.6 继承"></a>2.4.6 继承</h4><p>继承是面向对象三大特性之一</p><p>好处:减少重复代码</p><p>基本语法: <code>class 子类 : 继承方式 父类</code><br>子类也称为派生类<br>父类也称为基类</p><p>派生类中的成员,包含俩大部分:<br>一类是从基类继承过来的,一类是自己增加的成员<br>从基类继承过来的表现其共性,而新增的成员体现了其个性</p><p>继承方式一共有三种:</p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//公共继承
class Base1
{
public:
  int m_A;
protected:
  int m_B;
private:
  int m_C;
};
class Son1 :public Base1
{
public:
  void func()
  {
    m_A = 10;//父类公共，子类公共
    m_B = 10;//父类保护，子类保护
    //父类私有，子类访问不到
  }
};
void test01()
{
  Son1 s1;
  s1.m_A = 100;
}
//保护继承
class Base2
{
public:
  int m_A;
protected:
  int m_B;
private:
  int m_C;
};
class Son2 :protected Base2
{
public:
  void func()
  {
    m_A = 10;//父类公共，子类保护
    m_B = 10;//父类保护，子类保护
    //父类私有，子类访问不到
  }
};
void test02()
{
  Son2 s2;
}
//私有继承
class Base3
{
public:
  int m_A;
protected:
  int m_B;
private:
  int m_C;
};
class Son3 :private Base3
{
public:
  void func()
  {
    m_A = 10;//父类公共，子类私有
    m_B = 10;//父类保护，子类私有
    //父类私有，子类访问不到
  }
};
void test03()
{
  Son3 s3;
}
int main()
{
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承中的对象模型:<br>父类中所有非静态成员属性都会被子类继承下去<br>父类中的私有成员属性 是被编译器隐藏了 所以访问不到 但是确实被继承下去了</p><p>查看对象模型:打开开发人员命令行工具找到对应.cpp所在的目录,输入<code>cl /dl reportSingleClassLayout所属类名 "对应.cpp"</code></p><p>继承中的构造和析构顺序:<br>先构造父类,再构造子类;析构与构造顺序相反<br>子类继承父类后,当创建子类对象,也会调用父类的构造函数</p><p>继承同名成员(函数)处理方式:</p><ul><li>访问子类同名成员(函数) 直接访问即可</li><li>访问父类同名成员(函数) 需要加作用域 <code>s.Base::m_A</code></li></ul><p>如果子类中出现和父类同名的成员函数,子类的同名成员会隐藏掉父类中所有同名成员函数<br>如果想访问到父类中隐藏的同名成员函数,需要加作用域</p><p>继承同名静态成员处理方式:<br>静态成员和非静态成员出现同名,处理方式一致</p><p>可以通过对象访问,也可以通过类名访问</p><ul><li>访问子类同名成员(函数) 直接访问即可<ul><li>对象:<code>s.m_A</code></li><li>类名:<code>Son::m_A</code></li></ul></li><li>访问父类同名成员(函数) 需要加作用域<ul><li>对象:<code>s.Base::m_A</code></li><li>类名:<code>Son::Base::m_A</code></li></ul></li></ul><p>如果子类中出现和父类同名的成员函数,子类的同名成员会隐藏掉父类中所有同名成员函数<br>如果想访问到父类中隐藏的同名成员函数,需要加作用域</p><p>多继承语法:<br>C++允许一个类继承多个类</p><p>语法:<code>class 子类 : 继承方式 父类1, 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现,需要加作用域区分</p><p>当父类中出现同名函数,需要加作用域区分</p><p><em>C++实际开发中不建议用多继承</em></p><p>菱形继承:<br>概念:</p><ul><li>俩个派生类B、C继承同一个基类A</li><li>又有某个类D同时继承俩个派生类</li><li>这种继承方式被称为菱形继承,或者钻石继承<br>问题:</li></ul><p>1.某个类D使用数据时,会产生二义性<br>2.D继承了A的俩份数据,我们其实只需要一份就行</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//菱形继承:虚继承（继承之前加上virtual）Animal叫做虚基类 可以解决菱形继承问题
#include&lt;iostream&gt;
using namespace std;
//动物类
class Animal
{
public:
  int m_Age;
};
//羊类
class Sheep :virtual public Animal
{

};
//驼类
class Tuo :virtual public Animal
{

};
//羊驼类
class SheepTuo :public Sheep, public Tuo
{

};
void test01()
{
  SheepTuo st;
  st.Sheep::m_Age = 18;
  st.Tuo::m_Age = 28;
  //菱形继承，俩个父类拥有相同数据，需加作用域区分
  cout &lt;&lt; "Sheep::m_Age=" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;
  cout &lt;&lt; "Tuo::m_Age=" &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;
  //只需一份数据
  cout &lt;&lt; "st.m_Age=" &lt;&lt; st.m_Age &lt;&lt; endl;
}
int main()
{
  test01();
  system("pause");
  return 0;
}
//Sheep::m_Age=28
//Tuo::m_Age=28
//st.m_Age=28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-7-多态"><a href="#2-4-7-多态" class="headerlink" title="2.4.7 多态"></a>2.4.7 多态</h4><p>多态是C++面向对象三大特性之一</p><p>多态分为俩类:</p><ul><li>静态多态:函数重载和运算符重载属于静态重载,复用函数名</li><li>动态多态:派生类和虚函数实现运行时多态<br>条件:<ul><li>1.有继承关系</li><li>2.子类重写父类的虚函数 重写 函数返回值类型 函数名 参数列表 完全相同<br>使用:</li><li>父类的指针或者引用执行子类对象</li></ul></li></ul><p>静态多态和动态多态区别:</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><h5 id="案例-计算器类"><a href="#案例-计算器类" class="headerlink" title="案例: 计算器类"></a>案例: 计算器类</h5><p>案例描述:<br>分别利用普通写法和多态技术,设计实现俩个操作数进行运算的计算机类</p><p>多态的优点:</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//重写父类虚函数 virtual+函数名
class Calulator
{
public:
  int getResult(string oper)
  {
    if (oper == "+")
    {
      return m_Num1 + m_Num2;
    }
    else if (oper=="-")
    {
      return m_Num1 - m_Num2;
    }
    else if (oper=="*")
    {
      return m_Num1 * m_Num2;
    }
    //如果想扩展新的功能,需要修改源码
    //在真正开发中 提倡 开闭原则
    //开闭原则:对扩展进行开发,对修改进行关闭
  }
  int m_Num1;
  int m_Num2;
};
void test01()
{
  Calulator c;
  c.m_Num1 = 10;
  c.m_Num2 = 10;
  cout &lt;&lt; c.m_Num1 &lt;&lt; "+" &lt;&lt; c.m_Num2 &lt;&lt; "=" &lt;&lt; c.getResult("+") &lt;&lt; endl;
  cout &lt;&lt; c.m_Num1 &lt;&lt; "-" &lt;&lt; c.m_Num2 &lt;&lt; "=" &lt;&lt; c.getResult("-") &lt;&lt; endl;
  cout &lt;&lt; c.m_Num1 &lt;&lt; "*" &lt;&lt; c.m_Num2 &lt;&lt; "=" &lt;&lt; c.getResult("*") &lt;&lt; endl;
}
class AbstractCalculator
{
public:
  virtual int getResult()
  {
    return 0;
  }
  int m_Num1;
  int m_Num2;
};
class AddCalculator :public AbstractCalculator
{
public:
  int getResult()
  {
    return m_Num1+m_Num2;
  }
};
class SubCalculator :public AbstractCalculator
{
public:
  int getResult()
  {
    return m_Num1 - m_Num2;
  }
};
class MulCalculator :public AbstractCalculator
{
public:
  int getResult()
  {
    return m_Num1 * m_Num2;
  }
};
void test02()
{
  AbstractCalculator* abc = new AddCalculator;
  abc-&gt;m_Num1 = 10;
  abc-&gt;m_Num2 = 12;
  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; "+" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; "=" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
  //用完后销毁
  delete abc;
  abc = new SubCalculator;
  abc-&gt;m_Num1 = 10;
  abc-&gt;m_Num2 = 12;
  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; "-" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; "=" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
  delete abc;
  abc = new MulCalculator;
  abc-&gt;m_Num1 = 10;
  abc-&gt;m_Num2 = 12;
  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; "*" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; "=" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
  delete abc;
}
int main()
{
  test01();
  test02();
  system("pause");
  return 0;
}
//10+10=20
//10-10=0
//10*10=100
//10+12=22
//10-12=-2
//10*12=120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>纯虚函数和抽象类:</p><p>在多态中,通常父类中虚函数的实现是毫无意义的,主要都是调用子类重写的内容,因此可以将虚函数改为<code>纯虚函数</code></p><p>纯虚函数语法: <code>virtual 返回值类型 函数名 (参数列表) = 0;</code></p><p>当类中有了纯虚函数,这个类就称为<code>抽象类</code></p><p>抽象类特点:</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数,否则也属于抽象类</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class Base//抽象类：无法实例化对象,子类必须重写父类的纯虚函数，否则子类也属于抽象类
{
public:
  virtual void func() = 0;//纯虚函数
};
class Son :public Base
{
public:
  virtual void func()
  {
    cout &lt;&lt; "func函数调用" &lt;&lt; endl;
  }
};
void test01()
{
  Base* base = new Son;
  base-&gt;func();
  delete base;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虚析构和纯虚析构:</p><p>多态使用时,如果子类中有属性开辟到堆区,那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式:将父类中的析构函数改为<code>虚析构</code>或者<code>纯虚析构</code></p><p>虚析构和纯虚析构共性:</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构共性:</p><ul><li>如果有纯虚析构,该类属于抽象类,无法实例化对象</li></ul><p>虚析构语法: <code>virtual ~类名(){}</code><br>纯虚析构语法:<br><code>virtual ~类名() = 0;</code><br><code>类名::~类名(){}</code></p><p>如果子类中没有堆区数据,可以不写为虚析构或纯虚析构</p><h5 id="案例-电路组装"><a href="#案例-电路组装" class="headerlink" title="案例: 电路组装"></a>案例: 电路组装</h5><p>案例描述:<br>电脑主要组成部件为CPU(用于计算),显卡(用于显示),内存条(用于存储)<br>将每个零件封装出抽象基类,并且提供不同厂商生产不同的零件,例如Intel厂商和Lenovo厂商<br>创建电脑类提供让电脑工作的函数,并且调用每个零件工作的接口<br>测试时组装三台不同的电脑进行工作</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
class CPU
{
public:
  virtual void calculator() = 0;
};
class VideoCard
{
public:
  virtual void display() = 0;
};
class Memory
{
public:
  virtual void storage() = 0;
};
class Computer
{
public:
  Computer(CPU* cpu, VideoCard* vc, Memory* mem)
  {
    m_cpu = cpu;
    m_vc = vc;
    m_mem = mem;
  }
  void work()
  {
    m_cpu-&gt;calculator();
    m_vc-&gt;display();
    m_mem-&gt;storage();
  }
  ~Computer()
  {
    if (m_cpu != NULL)
    {
      delete m_cpu;
      m_cpu = NULL;
    }
    if (m_vc != NULL)
    {
      delete m_vc;
      m_vc = NULL;
    }
    if (m_mem != NULL)
    {
      delete m_mem;
      m_mem = NULL;
    }
  }
private:
  CPU* m_cpu;
  VideoCard* m_vc;
  Memory* m_mem;
};
class IntelCPU :public CPU
{
  virtual void calculator()
  {
    cout &lt;&lt; "Intel Cpu开始计算" &lt;&lt; endl;
  }
};
class IntelVideoCard :public VideoCard
{
  virtual void display()
  {
    cout &lt;&lt; "Intel 显卡开始显示" &lt;&lt; endl;
  }
};
class IntelMemory :public Memory
{
  virtual void storage()
  {
    cout &lt;&lt; "Intel 内存条开始存储" &lt;&lt; endl;
  }
};
class LenovoCPU :public CPU
{
  virtual void calculator()
  {
    cout &lt;&lt; "Lenovo CPU开始计算" &lt;&lt; endl;
  }
};
class LenovoVideoCard :public VideoCard
{
  virtual void display()
  {
    cout &lt;&lt; "Lenovo 显卡开始显示" &lt;&lt; endl;
  }
};
class LenovoMemory :public Memory
{
  virtual void storage()
  {
    cout &lt;&lt; "Lenovo 内存条开始存储" &lt;&lt; endl;
  }
};
void test01()
{
  CPU* intelCpu = new IntelCPU;
  VideoCard* intelCard = new IntelVideoCard;
  Memory* intelMem = new IntelMemory;
  Computer* computer1 = new Computer(intelCpu, intelCard, intelMem);
  computer1-&gt;work();
  delete computer1;
  Computer* computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);
  computer2-&gt;work();
  delete computer2;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-文件操作"><a href="#2-5-文件操作" class="headerlink" title="2.5 文件操作"></a>2.5 文件操作</h3><p>程序运行时产生的数据都属于临时数据,程序一旦运行结束都会被释放<br>通过<code>文件可以将数据持久化</code><br>C++中对文件操作需要包含头文件<code>&lt;fstream&gt;</code></p><p>文件类型分为俩种:<br>1.<code>文本文件</code> - 文件以文本<code>ASCII码</code>形式存储在计算机中<br>2.<code>二进制文件</code>- 文件以文本的<code>二级制</code>形式存储在计算机中,用户一般不能直接读懂他们</p><p>操作文件的三大类:<br>1.ofstream: 写操作<br>2.ifstream: 读操作<br>3.fstream : 读写操作</p><h4 id="2-5-1-文本文件"><a href="#2-5-1-文本文件" class="headerlink" title="2.5.1 文本文件"></a>2.5.1 文本文件</h4><p>一.写文件<br>步骤:<br>1.包含头文件<br><code>#include&lt;fstream&gt;</code><br>2.创建流对象<br><code>ofstream ofs;</code><br>3.打开文件<br><code>ofs.open("文件路径",打开方式);</code><br>4.写数据<br><code>ofs&lt;&lt;"写入的数据"</code><br>5.关闭文件<br><code>ofs.close();</code></p><p>文件打开方式:<br>|打开方式|解释|<br>|—|—|<br>|ios::in|为读文件而打开文件|<br>|ios::out|为写文件而打开文件|<br>|ios::ate|初始位置:文件尾|<br>|ios::app|追加方式写文件|<br>|ios::trunc|如果文件存在先删除,再创建|<br>|ios::binary|二进制方式|</p><p>注意:文件打开方式可以配合使用,利用<code>|</code>操作符<br>例如:用二进制方式写文件 <code>ios::binary | ios::out</code></p><p>二.读文件</p><p>步骤:</p><p>1.包含头文件 <code>#include&lt;fstream&gt;</code><br>2.创建流对象 <code>ifstream ifs;</code><br>3.打开文件并判断文件是否打开成功 <code>ifs.open("文件路径",打开方式);"</code><br>4.读数据 <code>四种方式读取</code><br>5.关闭文件 <code>ifs.close();</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;fstream&gt;
#include&lt;string&gt;
void test01()
{
  ofstream ofs;//创建文件流
  ofs.open("test.txt",ios::out);//指定打开方式 写文件
  ofs &lt;&lt; "姓名：张三" &lt;&lt; endl;
  ofs &lt;&lt; "性别：男" &lt;&lt; endl;
  ofs &lt;&lt; "年龄：18" &lt;&lt; endl;
  ofs.close();//关闭文件

}
void test02()
{
  ifstream ifs;
  ifs.open("test.txt", ios::in);
  if (!ifs.is_open())
  {
    cout &lt;&lt; "文件打开失败" &lt;&lt; endl;
    return;
  }
  //读文件
  /*1.
  char buf[1024] = { 0 };
  while (ifs&gt;&gt;buf)
  {
    cout &lt;&lt; buf &lt;&lt; endl;
  }*/
  /*2.
  char buf[1024] = { 0 };
  while (ifs.getline(buf,sizeof(buf)))
  {
    cout &lt;&lt; buf &lt;&lt; endl;
  }*/
  /*3.
  string buf;
  while (getline(ifs,buf))
  {
    cout &lt;&lt; buf &lt;&lt; endl;
  }*/
  //4.不推荐
  char c;
  while ((c=ifs.get())!=EOF) //EOF 文件尾
  {
    cout &lt;&lt; c &lt;&lt; endl;
  }
  //关闭文件
  ifs.close();
}
int main()
{
  test02();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-2-二进制文件"><a href="#2-5-2-二进制文件" class="headerlink" title="2.5.2 二进制文件"></a>2.5.2 二进制文件</h4><p>打开方式:<code>ios::binary</code></p><p>1.写文件主要利用流对象调用成员函数write<br>函数原型: <code>ostream&amp; write(const char * buffer,int len);</code><br>参数:字符指针buffer指向内存中一段空间,len是读写的字节数</p><p>2.读文件主要利用流对象调用成员函数read<br>函数原型: <code>istream&amp; read(char * buffer,int len);</code><br>参数:字符指针buffer指向内存中一段空间,len是读写的字节数</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;fstream&gt;
#include&lt;string&gt;
//二进制写文件
class Person
{
public:
  char m_Name[64];
  int m_Age;
};
void test03()
{
  ofstream ofs;
  ofs.open("person.txt", ios::out | ios::binary);
  Person p = { "张三",18 };
  ofs.write((const char*)&amp;p, sizeof(Person));
  ofs.close();
}
void test04()
{
  ifstream ifs;
  ifs.open("person.txt", ios::in | ios::binary);
  if (!ifs.is_open())
  {
    cout &lt;&lt; "文件打开失败" &lt;&lt; endl;
    return;
  }
  Person p;
  ifs.read((char*)&amp;p, sizeof(Person));
  cout &lt;&lt; "姓名：" &lt;&lt; p.m_Name &lt;&lt; "  年龄:" &lt;&lt; p.m_Age &lt;&lt; endl;
  ifs.close();
}
int main()
{
  test04();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-职工管理系统"><a href="#案例-职工管理系统" class="headerlink" title="案例: 职工管理系统"></a>案例: 职工管理系统</h5><p>案例描述:利用C++来实现一个基于多态的职工管理系统</p><p>公司中职工分为三种:普通职工、经理、老板,显示信息时,需要显示职工编号、职工姓名、职工岗位、以及职责</p><p>普通职工职责:完成经理交给的任务<br>经理职责:完成老板交给的任务,并下发任务给员工<br>老板职责:管理公司所有事物</p><p>管理系统需要实现的功能如下:</p><ul><li>退出管理系统:退出当前管理系统 <code>void ExitSystem();</code></li><li>增加职工信息:实现批量添加职工功能,将信息录入到文件中,职工信息为:职工编号、姓名、部门编号</li><li>显示职工信息:显示公司内部所有职工信息</li><li>删除离职职工:按照编号删除指定的职工</li><li>修改职工信息:按照编号修改职工个人信息</li><li>查找职工信息:按照职工的编号或者职工的姓名进行查找相关的人员信息</li><li>按照编号排序:按照职工编号进行排序,排序规则由用户指定</li><li>清空所有文档:清空文件中记录的所有职工信息(清空前需要再次确定,防止误删)</li></ul><p>代码:</p><p>创建管理类workerManager:</p><ul><li>与用户沟通的菜单界面 <code>void Show_Menu();</code></li><li>对职工增删改查的操作</li><li>与文件的读写交互</li></ul><p>workerManager.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once//防止头文件重复包含
#include&lt;iostream&gt;
using namespace std;
#include"worker.h"
#include"employee.h"
#include"manager.h"
#include"boss.h"
#include&lt;fstream&gt;
#define FILENAME "empFile.txt"
class WorkerManager
{
public:
  WorkerManager();
  void Show_Menu();//展示菜单
  void ExitSystem();//退出系统
  int m_EmpNum;//职工人数
  Worker** m_EmpArray;//职工数组指针
  //添加职工
  void Add_Emp();
  //保存文件
  void save();

  bool m_FileIsEmpty;
  //统计文件人数
  int get_EmpNum();
  void init_Emp();
  //显示职工
  void Show_Emp();
  //删除职工
  void Del_Emp();
  //判断职工是否存在
  int IsExist(int id);
  //修改职工
  void Mod_Emp();
  //查找职工
  void Find_Emp();
  //排序
  void Sort_Emp();
  //清空文件
  void Clean_File();
  ~WorkerManager();

};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>workerManager.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"workerManager.h"
WorkerManager::WorkerManager()
{

  //1.文件不存在
  ifstream ifs;
  ifs.open(FILENAME, ios::in);
  if (!ifs.is_open())
  {
    cout &lt;&lt; "文件不存在" &lt;&lt; endl;
    //初始化属性
    this-&gt;m_EmpNum = 0;
    this-&gt;m_EmpArray = NULL;
    this-&gt;m_FileIsEmpty = true;
    ifs.close();
    return;
  }//文件存在但为空
  char ch;
  ifs &gt;&gt; ch;
  if (ifs.eof())
  {
    //文件为空
    cout &lt;&lt; "文件为空" &lt;&lt; endl;
    //初始化属性
    this-&gt;m_EmpNum = 0;
    this-&gt;m_EmpArray = NULL;
    this-&gt;m_FileIsEmpty = true;
    ifs.close();
    return;
  }
  //3.文件存在并不为空
  int num = this-&gt;get_EmpNum();
  cout &lt;&lt; "职工人数为:" &lt;&lt; num &lt;&lt; endl;
  this-&gt;m_EmpNum = num;

  this-&gt;m_EmpArray = new Worker * [this-&gt;m_EmpNum];//开辟空间
  this-&gt;init_Emp();//将文件中的数据存储到数组中
  //测试代码
  /*for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
  {
    cout &lt;&lt; "职工编号:" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id
      &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name
      &lt;&lt; "部门编号:" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;
  }*/
}
void WorkerManager::Show_Menu()
{
  cout &lt;&lt; "******************************" &lt;&lt; endl;
  cout &lt;&lt; "**** 欢迎使用职工管理系统 ****" &lt;&lt; endl;
  cout &lt;&lt; "******* 0.退出管理系统 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 1.添加职工信息 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 2.显示职工信息 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 3.删除离职职工 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 4.修改职工信息 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 5.查找职工信息 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 6.按照编号排序 *******" &lt;&lt; endl;
  cout &lt;&lt; "******* 7.清空所用文档 *******" &lt;&lt; endl;
  cout &lt;&lt; "******************************" &lt;&lt; endl;
  cout &lt;&lt; endl;
}
void WorkerManager::ExitSystem()
{
  cout &lt;&lt; "欢迎下次使用" &lt;&lt; endl;
  system("pause");
  exit(0);
}
//添加职工
void WorkerManager::Add_Emp()
{
  cout &lt;&lt; "请输入添加职工数量:" &lt;&lt; endl;
  int addNum = 0;
  cin &gt;&gt; addNum;
  if (addNum&gt;0)
  {
    //添加
    //计算添加空间大小
    int newSize = this-&gt;m_EmpNum + addNum;
    //开辟新空间
    Worker** newSpace = new Worker * [newSize];
    //将原来空间数据拷贝到新空间
    if (this-&gt;m_EmpArray!=NULL)
    {
      for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
      {
        newSpace[i] = this-&gt;m_EmpArray[i];
      }
    }
    //添加新数据
    for (int i = 0; i &lt; addNum; i++)
    {
      int id;
      string name;
      int dSelect;//部门选择
      cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工编号:" &lt;&lt; endl;
      cin &gt;&gt; id;
      cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工姓名:" &lt;&lt; endl;
      cin &gt;&gt; name;
      cout &lt;&lt; "请选择该职工岗位:" &lt;&lt; endl;
      cout &lt;&lt; "1.普通员工" &lt;&lt; endl;
      cout &lt;&lt; "2.经理" &lt;&lt; endl;
      cout &lt;&lt; "3.老板" &lt;&lt; endl;
      cin &gt;&gt; dSelect;
      Worker* worker = NULL;
      switch (dSelect)
      {
      case 1:
        worker = new Employee(id, name, 1);
        break;
      case 2:
        worker = new Manager(id, name, 2);
        break;
      case 3:
        worker = new Boss(id, name, 3);
        break;
      default:
        break;
      }
      //将创建的职工指针保存到数组中
      newSpace[this-&gt;m_EmpNum + i] = worker;
    }
    //释放原有空间
    delete[] this-&gt;m_EmpArray;
    //更改新空间指向
    this-&gt;m_EmpArray = newSpace;
    //更新新的职工人数
    this-&gt;m_EmpNum = newSize;
    //更新职工不为空
    this-&gt;m_FileIsEmpty = false;
    //成功添加后保存到文件中
    cout &lt;&lt; "成功添加" &lt;&lt; addNum &lt;&lt; "名新职工" &lt;&lt; endl;
    this-&gt;save();
  }
  else
  {
    cout &lt;&lt; "输入有误" &lt;&lt; endl;
  }
  system("pause");
  system("cls");
}
//统计文件人数
int WorkerManager::get_EmpNum()
{
  ifstream ifs;
  ifs.open(FILENAME, ios::in);
  int id;
  string name;
  int dId;
  int num = 0;
  while (ifs&gt;&gt;id&amp;&amp;ifs&gt;&gt;name&amp;&amp;ifs&gt;&gt;dId)
  {
    num++;
  }
  return num;
}
void WorkerManager::save()
{
  ofstream ofs;
  ofs.open(FILENAME, ios::out);
  for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
  {
    ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; " "
      &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; " "
      &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;
  }
  ofs.close();
}
void WorkerManager::init_Emp()
{
  ifstream ifs;
  ifs.open(FILENAME, ios::in);
  int id;
  string name;
  int dId;
  int index = 0;
  while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)
  {
    Worker* worker = NULL;
    if (dId==1)
    {
      worker = new Employee(id, name, dId);
    }else if (dId == 2)
    {
      worker = new Manager(id, name, dId);
    }
    else
    {
      worker = new Boss(id, name, dId);
    }
    this-&gt;m_EmpArray[index] = worker;
    index++;
  }
  ifs.close();
}
//显示职工
void WorkerManager::Show_Emp()
{
  //判断文件是否为空
  if (this-&gt;m_FileIsEmpty)
  {
    cout &lt;&lt; "文件不存在或者记录为空" &lt;&lt; endl;
  }
  else
  {
    for (int i = 0; i &lt; m_EmpNum; i++)
    {
      //利用多态调用程序接口
      this-&gt;m_EmpArray[i]-&gt;showInfo();
    }
  }
  system("pause");
  system("cls");
}
//删除职工
void WorkerManager::Del_Emp()
{
  if (this-&gt;m_FileIsEmpty)
  {
    cout &lt;&lt; "文件不存在或记录为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "请输入想要删除职工的编号:" &lt;&lt; endl;
    int id = 0;
    cin &gt;&gt; id;
    int index = this-&gt;IsExist(id);
    if (index!=-1)
    {
      //数据前移
      for (int i = index; i &lt; this-&gt;m_EmpNum-1; i++)
      {
        this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1];
      }
      this-&gt;m_EmpNum--;//更新人数
      //更新到文件中
      this-&gt;save();
      cout &lt;&lt; "删除成功" &lt;&lt; endl;
    }
    else
    {
      cout &lt;&lt; "未找到职工，删除失败" &lt;&lt; endl;
    }
  }
  system("pause");
  system("cls");
}
//判断职工是否存在
int WorkerManager::IsExist(int id)
{
  int index = -1;
  for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
  {
    if (this-&gt;m_EmpArray[i]-&gt;m_Id == id)
    {
      //找到职工
      index = i;
      break;
    }
  }
  return index;
}
//修改职工
void WorkerManager::Mod_Emp()
{
  if (this-&gt;m_FileIsEmpty)
  {
    cout &lt;&lt; "文件不存在或记录为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "请输入要修改职工的编号:" &lt;&lt; endl;
    int id;
    cin &gt;&gt; id;
    int ret = this-&gt;IsExist(id);
    if (ret!=-1)
    {
      delete this-&gt;m_EmpArray[ret];
      int newId = 0;
      string newName = "";
      int dSelect = 0;
      cout &lt;&lt; "查找到" &lt;&lt; id &lt;&lt; "号职工，请输入新的职工号:" &lt;&lt; endl;
      cin &gt;&gt; newId;
      cout &lt;&lt; "请输入新的姓名:" &lt;&lt; endl;
      cin &gt;&gt; newName;
      cout &lt;&lt; "请输入新的岗位:" &lt;&lt; endl;
      cout &lt;&lt; "1.普通员工" &lt;&lt; endl;
      cout &lt;&lt; "2.经理" &lt;&lt; endl;
      cout &lt;&lt; "3.老板" &lt;&lt; endl;
      cin &gt;&gt; dSelect;
      Worker* worker = NULL;
      switch (dSelect)
      {
      case 1:
        worker = new Employee(newId, newName, dSelect);
        break;
      case 2:
        worker = new Manager(newId, newName, dSelect);
        break;
      case 3:
        worker = new Boss(newId, newName, dSelect);
        break;
      default:
        break;
      }
      this-&gt;m_EmpArray[ret] = worker;
      cout &lt;&lt; "修改成功" &lt;&lt; endl;
      this-&gt;save();
    }
    else
    {
      cout &lt;&lt; "查无此人，修改失败" &lt;&lt; endl;
    }
  }
  system("pause");
  system("cls");
}
//查找职工
void WorkerManager::Find_Emp()
{
  if (this-&gt;m_FileIsEmpty)
  {
    cout &lt;&lt; "文件不存在或记录为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "请输入查找的方式:" &lt;&lt; endl;
    cout &lt;&lt; "1.按职工编号查找" &lt;&lt; endl;
    cout &lt;&lt; "2.按职工姓名查找" &lt;&lt; endl;
    int select = 0;
    cin &gt;&gt; select;
    if (select == 1)
    {
      int id;
      cout &lt;&lt; "请输入查找的职工编号:" &lt;&lt; endl;
      cin &gt;&gt; id;
      int ret = IsExist(id);
      if (ret != -1)
      {
        cout &lt;&lt; "查找成功!该职工信息如下:" &lt;&lt; endl;
        this-&gt;m_EmpArray[ret]-&gt;showInfo();
      }
      else {
        cout &lt;&lt; "查无此人" &lt;&lt; endl;
      }
    }
    else if (select == 2)
    {
      string name;
      cout &lt;&lt; "请输入查找的职工姓名:" &lt;&lt; endl;
      cin &gt;&gt; name;
      bool flag = false;//添加是否查到的标志
      for (int i = 0; i &lt; m_EmpNum; i++)
      {
        if (this-&gt;m_EmpArray[i]-&gt;m_Name==name)
        {
          cout &lt;&lt; "查找成功!职工编号为:" 
            &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id 
            &lt;&lt; "号职工信息如下" &lt;&lt; endl;
          flag = true;
          this-&gt;m_EmpArray[i]-&gt;showInfo();
        }
      }
      if (flag == false)
      {
        cout &lt;&lt; "查找失败，查无此人" &lt;&lt; endl;
      }
    }
    else
    {
      cout &lt;&lt; "输入有误" &lt;&lt; endl;
    }
  }
  system("pause");
  system("cls");
}
//排序
void WorkerManager::Sort_Emp()
{
  if (this-&gt;m_FileIsEmpty)
  {
    cout &lt;&lt; "文件不存在或记录为空" &lt;&lt; endl;
    system("pause");
    system("cls");
  }
  else
  {
    cout &lt;&lt; "请选择排序方式" &lt;&lt; endl;
    cout &lt;&lt; "1.按照职工号升序" &lt;&lt; endl;
    cout &lt;&lt; "2.按照职工号降序" &lt;&lt; endl;
    int select = 0;
    cin &gt;&gt; select;
    for (int i = 0; i &lt; m_EmpNum; i++)
    {
      int minOrMax = i;//声明最小或最大值下标
      for (int  j = i+1; j &lt; this-&gt;m_EmpNum; j++)
      {
        if (select == 1)
        {
          if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &gt; this-&gt;m_EmpArray[j]-&gt;m_Id)
          {
            minOrMax = j;
          }
        }
        else if (select == 2)
        {
          if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &lt; this-&gt;m_EmpArray[j]-&gt;m_Id)
          {
            minOrMax = j;
          }
        }
        else
        {
          cout &lt;&lt; "输入有误" &lt;&lt; endl;
        }
      }
      if (i!=minOrMax)
      {
        Worker* temp = this-&gt;m_EmpArray[i];
        this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[minOrMax];
        this-&gt;m_EmpArray[minOrMax] = temp;
      }
    }
    cout &lt;&lt; "排序成功,排序后的结果为:" &lt;&lt; endl;
    this-&gt;save();
    this-&gt;Show_Emp();//展示职工
  }
}
//清空文件
void WorkerManager::Clean_File()
{
  cout &lt;&lt; "确认清空？" &lt;&lt; endl;
  cout &lt;&lt; "1.确定" &lt;&lt; endl;
  cout &lt;&lt; "2.返回" &lt;&lt; endl;
  int select = 0;
  cin &gt;&gt; select;
  if (select == 1)
  {
    ofstream ofs(FILENAME,ios::trunc);//删除文件后重新创建
    ofs.close();
    if (this-&gt;m_EmpArray != NULL)
    {
      for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
      {
        //删除堆区每个对象
          delete this-&gt;m_EmpArray[i];
          this-&gt;m_EmpArray[i] = NULL;       
      }//删除堆区数组指针
      delete[] this-&gt;m_EmpArray;        
      this-&gt;m_EmpArray = NULL;
      this-&gt;m_EmpNum = 0;
      this-&gt;m_FileIsEmpty = true;
    }
    cout &lt;&lt; "清空成功" &lt;&lt; endl;
  }
  system("pause");
  system("cls");
}
WorkerManager::~WorkerManager()
{
  if (this-&gt;m_EmpArray!=NULL)
  {
    for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
    {
      if (this-&gt;m_EmpArray != NULL)
      {
        delete this-&gt;m_EmpArray[i];
      }
    }
    delete[] this-&gt;m_EmpArray;
    this-&gt;m_EmpArray = NULL;
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建抽象职工类:</p><p>职工的分类:普通职工、经理、老板<br>将三种职工抽象到一个类(worker)中,利用多态管理不同职工种类<br>职工的属性:职工编号、职工姓名、职工所在部门编号<br>职工的行为:岗位职责描述,获取岗位名称</p><p>worker.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
class Worker//职工抽象类
{
public:
  //显示个人信息
  virtual void showInfo() = 0;

  //获取岗位名称
  virtual string getDeptName() = 0;
  int m_Id;
  string m_Name;
  int m_DeptId;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老板类:</p><p>boss.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include"worker.h"
//老板类
class Boss :public Worker
{
public:
  //构造函数
  Boss(int id, string name, int dId);
  //显示个人信息
  virtual void showInfo();

  //获取岗位名称
  virtual string getDeptName();
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>boss.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"boss.h"
//构造函数
Boss::Boss(int id, string name, int dId)
{
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
}
//显示个人信息
void Boss::showInfo()
{
  cout &lt;&lt; "职工编号:" &lt;&lt; this-&gt;m_Id
    &lt;&lt; "\t\t职工姓名:" &lt;&lt; this-&gt;m_Name
    &lt;&lt; "\t\t岗位:" &lt;&lt; this-&gt;getDeptName()
    &lt;&lt; "\t\t岗位职责: 管理公司所有事务" &lt;&lt; endl;
}

//获取岗位名称
string Boss::getDeptName()
{
  return string("老板");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通员工类:</p><p>employee.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//普通员工
#pragma once
#include&lt;iostream&gt;
using namespace std;
#include"worker.h"
class Employee :public Worker
{
public:
  //构造函数
  Employee(int id,string name,int dId);
  //显示个人信息
  virtual void showInfo();

  //获取岗位名称
  virtual string getDeptName();
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>employee.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"employee.h"
//构造函数
Employee::Employee(int id, string name, int dId)
{
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
}
//显示个人信息
void Employee::showInfo()
{
  cout &lt;&lt; "职工编号:" &lt;&lt; this-&gt;m_Id
    &lt;&lt; "\t\t职工姓名:" &lt;&lt; this-&gt;m_Name
    &lt;&lt; "\t\t岗位:" &lt;&lt; this-&gt;getDeptName()
    &lt;&lt; "\t\t岗位职责: 完成经理交给的任务" &lt;&lt; endl;
}

//获取岗位名称
string Employee::getDeptName()
{
  return string("员工");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经理类:</p><p>manager.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include"worker.h"
//经理类
class Manager:public Worker
{
public:
  //构造函数
  Manager(int id, string name, int dId);
  //显示个人信息
  virtual void showInfo();

  //获取岗位名称
  virtual string getDeptName();
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>manager.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"manager.h"
//构造函数
Manager::Manager(int id, string name, int dId)
{
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
}
//显示个人信息
void Manager::showInfo()
{
  cout &lt;&lt; "职工编号:" &lt;&lt; this-&gt;m_Id
    &lt;&lt; "\t\t职工姓名:" &lt;&lt; this-&gt;m_Name
    &lt;&lt; "\t\t岗位:" &lt;&lt; this-&gt;getDeptName()
    &lt;&lt; "\t\t岗位职责: 完成老板交给的任务，并下发任务给员工" &lt;&lt; endl;
}

//获取岗位名称
string Manager::getDeptName()
{
  return string("经理");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include"workerManager.h"
#include"worker.h";
#include"employee.h"
#include"manager.h"
#include"boss.h"
int main()
{
  //多态测试代码
  /*
  Worker* worker = NULL;
  worker = new Employee(1, "张三", 1);
  worker-&gt;showInfo();
  worker = new Manager(2, "李四", 2);
  worker-&gt;showInfo();
  worker = new Boss(3, "王五", 3);
  worker-&gt;showInfo();
  */
  
  //实例化对象
  WorkerManager wm;
  int choice = 0;
  while (true)
  {
    wm.Show_Menu();
    cout &lt;&lt; "请输入你的选择:" &lt;&lt; endl;
    cin &gt;&gt; choice;
    switch (choice)
    {
    case 0://退出系统
      wm.ExitSystem();
      break;
    case 1://添加职工信息
      wm.Add_Emp();
      break;
    case 2://显示职工信息
      wm.Show_Emp();
      break;
    case 3://删除离职职工
      wm.Del_Emp();
      break;
    case 4://修改职工信息
      wm.Mod_Emp();
      break;
    case 5://查找职工信息
      wm.Find_Emp();
      break;
    case 6://按照编号排序
      wm.Sort_Emp();
      break;
    case 7://清空所用文档
      wm.Clean_File();
      break;
    default:
      system("cls");
      break;
    }
  }
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-C-提高编程"><a href="#3-C-提高编程" class="headerlink" title="3 C++提高编程"></a>3 C++提高编程</h2><p><code>泛型编程</code>和<code>STL</code></p><h3 id="3-1-模板"><a href="#3-1-模板" class="headerlink" title="3.1 模板"></a>3.1 模板</h3><p>模板就是建立通用的模具,大大提高复用性</p><p>特点:</p><ul><li>模板不可以直接使用,它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h4 id="3-1-1-函数模板"><a href="#3-1-1-函数模板" class="headerlink" title="3.1.1 函数模板"></a>3.1.1 函数模板</h4><ul><li>C++另一种编程思想称为<code>泛型编程</code>,主要利用的技术就是模板</li><li>C++提供俩种模板机制:<code>函数模板</code>和<code>类模板</code></li></ul><p>函数模板作用:<br>建立一个通用函数,其函数返回值类型和形参类型可以不具体制定,用一个<code>虚拟的类型</code>来代表</p><p>语法:<br><code>template&lt;typename T&gt; 函数声明或定义</code></p><p>解释:<br>template –声明创建模板<br>typename –表面其后面的符号是一种数据类型,可以用class代替<br>T –通用的数据类型,名称可以替换,通常为大写字母</p><p>注意事项:</p><ul><li>自动类型推导,必须推导出一致的数据类型T才可以使用</li><li>模板必须要确定出T的数据类型才可以使用</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//函数模板
//1.如果函数模板和普通函数都可以调用，优先调用普通函数
//2.可以通过空模板参数列表（mySwap&lt;&gt;(a,b)）强制调用函数模板
//3.函数模板可以发生函数重载
//4.如果函数模板可以发生更好的匹配，优先调用函数模板
template&lt;typename T&gt;//声明一个模板，T为通用数据类型
void mySwap(T&amp; a, T&amp; b)
{
  T temp = a;
  a = b;
  b = temp;
}
template&lt;class T&gt;
void func()
{
  cout &lt;&lt; "func调用" &lt;&lt; endl;
}
void swapInt(int&amp; a, int&amp; b)
{
  int temp = a;
  a = b;
  b = temp;
}
void swapDouble(double&amp; a, double&amp; b)
{
  double temp = a;
  a = b;
  b = temp;
}
void test01()
{
  int a = 10;
  int b = 20;
  //swapInt(a, b);
  //使用
  //1.自动类型推导 必须推导出一致的数据类型T才能使用   不可以发生隐式类型转换
  //mySwap(a, b);
  //2.显示指定类型 可以发生隐式类型转换
  mySwap&lt;int&gt;(a, b);
  cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
  double c = 1.1;
  double d = 2.2;
  swapDouble(c, d);
  cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl;
  cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl;
  func&lt;int&gt;();
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通函数与函数模板的区别:</p><ul><li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li><li>函数模板调用时,如果利用自动类型推导,不会发生隐式类型转换</li><li>如果利用显式指定类型的方式,可以发生隐式类型转换</li></ul><p>建议使用显式指定类型</p><p>普通函数与函数模板调用规则:<br>1.如果函数模板和普通函数都可以实现,优先调用普通函数<br>2.可以通过空模板参数列表来强制调用函数模板 <code>func&lt;&gt;();</code><br>3.函数模板也可以发生重载<br>4.如果函数模板可以产生更好的匹配,优先调用函数模板</p><p>模板局限性:<br>传入参数为数组或者自定义数据类型,就无法正常使用<br>解决方法:用特定数据类型提供具体化操作 重载 <code>template&lt;&gt; bool myCompare(Person &amp;p1,Person &amp;p2){函数实现}</code></p><h4 id="3-1-2-类模板"><a href="#3-1-2-类模板" class="headerlink" title="3.1.2 类模板"></a>3.1.2 类模板</h4><p>作用:建立一个通用类,类中的成员数据类型可以不具体制定,用一个<code>虚拟的类型</code>来表示。</p><p>语法:<br><code>template&lt;typename T&gt; 类</code></p><p>解释:<br>template –声明创建模板<br>typename –表面其后面的符号是一种数据类型,可以用class代替<br>T –通用的数据类型,名称可以替换,通常为大写字母</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//类模板
//1.没用自动类型推导使用方式
//2.类模板在模板参数列表中可以有默认参数
//类模板成员函数在调用时创建
template&lt;class NameType,class AgeType&gt;
class Person
{
public:
  Person(NameType name,AgeType age)
  {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
  }
  void showPerson()
  {
    cout &lt;&lt; "name:" &lt;&lt; this-&gt;m_Name &lt;&lt; "age:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
  }
  NameType m_Name;
  AgeType m_Age;
};
void test01()
{
  Person&lt;string, int&gt;p1("张三", 78);
  p1.showPerson();
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类模板和函数模板区别:<br>1.类模板没有自动类型推导的使用方式,只能用显式指定类型<br>2.类模板在模板参数列表中可以有默认参数</p><p>类模板中成员函数创建时机:</p><ul><li>普通类中成员函数一开始就创建</li><li>类模板中成员函数在调用时才创建</li></ul><p>类模板对象做函数参数<br>三种传入方式:<br>1.指定传入的类型 –直接显示对象的数据类型<br>2.参数模板化 –将对象中的参数变为模板进行传递<br>3.整个类模板化 –将这个对象类型模板化进行传递</p><p>代码:</p><p>分文件编写:<br>问题:<br>类模板中成员函数创建时期是在调用阶段,导致文件编写时调用不到<br>解决方法:<br>1.直接包含.cpp源文件</p><p>person.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include"person.h"
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age)
{
  this-&gt;m_Name = name;
  this-&gt;m_Age = age;
}
//成员函数类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson()
{
  cout &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>person.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
template&lt;class T1, class T2&gt;
class Person
{
public:
  Person(T1 name, T2 age);
  void showPerson();
  T1 m_Name;
  T2 m_Age;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.将声明和实现写在同一个文件中,并更改后缀名为.hpp,hpp是约定的名称,并不是强制</p><p>person.hpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//类模板对象做函数参数
template&lt;class T1, class T2&gt;
class Person
{
public:
  Person(T1 name, T2 age);
  /*{
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
  }*/
  void showPerson();
  /*{
    cout &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
  }*/
  T1 m_Name;
  T2 m_Age;
};
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age)
{
  this-&gt;m_Name = name;
  this-&gt;m_Age = age;
}
//成员函数类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson()
{
  cout &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//1.
//#include"person.cpp"
//2.
#include"person.hpp"
//#include&lt;string&gt;
////类模板对象做函数参数
//template&lt;class T1,class T2&gt;
//class Person
//{
//public:
//  Person(T1 name, T2 age);
//  /*{
//    this-&gt;m_Name = name;
//    this-&gt;m_Age = age;
//  }*/
//  void showPerson();
//  /*{
//    cout &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
//  }*/
//  T1 m_Name;
//  T2 m_Age;
//};
//构造函数类外实现
//template&lt;class T1, class T2&gt;
//Person&lt;T1, T2&gt;::Person(T1 name, T2 age)
//{
//  this-&gt;m_Name = name;
//  this-&gt;m_Age = age;
//}
////成员函数类外实现
//template&lt;class T1, class T2&gt;
//void Person&lt;T1,T2&gt;::showPerson()
//{
//  cout &lt;&lt; "姓名:" &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
//}
//1.指定传入类型  &lt;最常用&gt;
void printPerson1(Person&lt;string ,int&gt;&amp;p)
{
  p.showPerson();
}
void test01()
{
  Person&lt;string, int&gt;p("张三", 78);
  printPerson1(p);
}

//2.参数模板化
template&lt;class T1,class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp; p)
{
  p.showPerson();
  cout &lt;&lt; "T1的类型为:" &lt;&lt; typeid(T1).name() &lt;&lt; endl;
  cout &lt;&lt; "T2的类型为:" &lt;&lt; typeid(T2).name() &lt;&lt; endl;
}
void test02()
{
  Person&lt;string, int&gt;p("李四", 98);
  printPerson2(p);
}
//3.整个类模板化
template&lt;class T&gt;
void printPerson3(T&amp; p)
{
  p.showPerson();
  cout &lt;&lt; "T的类型为:" &lt;&lt; typeid(T).name() &lt;&lt; endl;
}
void test03()
{
  Person&lt;string, int&gt;p("王五", 8);
  printPerson3(p);
}
int main()
{
  test03();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看数据类型:<code>typeid(T).name()</code></p><p>类模板与继承:</p><ul><li>当子类继承的父类是一个类模板时,子类在声明的时候要指定出父类中T的类型</li><li>如果不指定,编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型,子类也需变为类模板</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
//类模板与继承
template&lt;class T&gt;
class Base
{
  T m;
};
class Son:public Base&lt;int&gt;
{
  
};
void test01()
{
  Son s1;
}
//如果想灵活指定父类中T类型，子类也需要变类模板
template&lt;class T1,class T2&gt;
class Son2 :public Base&lt;T2&gt;
{
public:
  Son2()
  {
    cout &lt;&lt; "T1的类型为" &lt;&lt; typeid(T1).name() &lt;&lt; endl;
    cout &lt;&lt; "T2的类型为" &lt;&lt; typeid(T2).name() &lt;&lt; endl;
  }
  T1 obj;
};
void test01()
{
  Son2&lt;int, char&gt;s2;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类模板成员函数类外实现</p><ul><li>加模板参数列表和作用域</li></ul><p>类模板和友元:</p><ul><li>全局函数类内实现 –直接在类内声明友元就行了</li><li>全局函数类外实现 –需要提前让编译器知道全局函数的存在</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//类模板与友元
//提前让编译器知道Person类存在
template&lt;class T1, class T2&gt;
class Person;
//通过全局函数 打印Person信息
template&lt;class T1, class T2&gt;
void print2(Person&lt;T1, T2&gt; p)
{
  cout &lt;&lt; "姓名:" &lt;&lt; p.m_Name &lt;&lt; " 年龄:" &lt;&lt; p.m_Age &lt;&lt; endl;
}
template&lt;class T1,class T2&gt;
class Person
{
  //全局函数 类内实现
  friend void print1(Person&lt;T1,T2&gt; p)
  {
    cout &lt;&lt; "姓名:" &lt;&lt; p.m_Name &lt;&lt; " 年龄:" &lt;&lt; p.m_Age &lt;&lt; endl;
  }
  //全局函数 类外实现
  //空模板参数列表
  //如果全局函数是类外实现，需要让编译器提前知道这个函数的存在
  friend void print2&lt;&gt;(Person&lt;T1, T2&gt; p);
public:
  Person(T1 name, T2 age);
  {
      this-&gt;m_Name = name;
      this-&gt;m_Age = age;
  }
private:
  T1 m_Name;
  T2 m_Age;
};

void test01()
{
  Person&lt;string, int&gt;p("Tom", 20);
  print2(p);
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-类模板案例"><a href="#案例-类模板案例" class="headerlink" title="案例: 类模板案例"></a>案例: 类模板案例</h5><p>案例描述:</p><ul><li>可以对内置函数类型以及自定义数据类型进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//自己的通用的数组类
#pragma once
#include&lt;iostream&gt;
using namespace std;
template&lt;class T&gt;
class MyArray
{
public:
  //有参构造 参数 容量
  MyArray(int capacity)
  {
    //cout &lt;&lt; "MyArray的有参构造" &lt;&lt; endl;
    this-&gt;m_Capacity = capacity;
    this-&gt;m_Size = 0;
    this-&gt;pAddress = new T[this-&gt;m_Capacity];
  }
  //拷贝构造
  MyArray(const MyArray&amp; arr)
  {
    //cout &lt;&lt; "MyArray的拷贝构造" &lt;&lt; endl;
    this-&gt;m_Capacity = arr.m_Capacity;
    this-&gt;m_Size = arr.m_Size;
    //this-&gt;pAddress = arr.pAddress;浅拷贝问题:重复释放内存
    this-&gt;pAddress = new T[arr.m_Capacity];//深拷贝
    //将arr中的数据都拷贝过来
    for (int i = 0; i &lt; this-&gt;m_Size; i++)
    {
      this-&gt;pAddress[i] = arr.pAddress[i];
    }
  }
  //operator=防止浅拷贝问题 a=b=c
  MyArray&amp; operator=(const MyArray&amp; arr)
  {
    //cout &lt;&lt; "MyArray的operator=" &lt;&lt; endl;
    //先判断原来堆区是否有数据,如果有先释放
    if (this-&gt;pAddress != NULL)
    {
      delete[] this-&gt;pAddress;
      this-&gt;pAddress = NULL;
      this-&gt;m_Capacity = 0;
      this-&gt;m_Size = 0;
    }
    //深拷贝
    this-&gt;m_Capacity = arr.m_Capacity;
    this-&gt;m_Size = arr.m_Size;
    this-&gt;pAddress = new T[arr.m_Capacity];
    for (int i = 0; i &lt; this-&gt;m_Size; i++)
    {
      this-&gt;pAddress[i] = arr.pAddress[i];
    }
    return *this;
  }
  //尾插法
  void Push_Back(const T&amp; val)
  {
    //判断容量是否等于大小
    if (this-&gt;m_Capacity==this-&gt;m_Size)
    {
      return;
    }
    this-&gt;pAddress[this-&gt;m_Size] = val;
    this-&gt;m_Size++;
  }
  //尾删法
  void Pop_Back()
  {
    if (this-&gt;m_Size == 0) {
      return;
    }
    this-&gt;m_Size--;
  }
  //通过下标访问
  
  T&amp; operator[](int index)
  {
    return this-&gt;pAddress[index];
  }
  //返回数组容量
  int getCapacity()
  {
    return this-&gt;m_Capacity;
  }

  //返回数组大小
  int getSize()
  {
    return this-&gt;m_Size;
  }

  //析构函数
  ~MyArray() {
    if (this-&gt;pAddress!=NULL)
    {
      //cout &lt;&lt; "MyArray的析构函数" &lt;&lt; endl;
      delete[] this-&gt;pAddress;
      this-&gt;pAddress = NULL;
    }
  }
private:
  T* pAddress;//指针指向堆区开辟的真实数组
  int m_Capacity;//容量
  int m_Size;//数组大小
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include"MyArray.hpp"

void printArray(MyArray &lt;int&gt;&amp; arr)
{
  for (int i = 0;i &lt; arr.getSize();i++)
  {
    cout &lt;&lt; arr[i] &lt;&lt; endl;
  }
}
void Test01()
{
  MyArray &lt;int&gt;arr1(5);
  for (int i = 0;i &lt; 5;i++)
  {
    arr1.Push_Back(i);//尾插法
  }
  cout &lt;&lt; "arr1:" &lt;&lt; endl;
  printArray(arr1);
  cout &lt;&lt; "arr1容量:" &lt;&lt; arr1.getCapacity() &lt;&lt; " 大小:" &lt;&lt; arr1.getSize() &lt;&lt; endl;
  MyArray &lt;int&gt;arr2(arr1);
  arr2.Pop_Back();
  cout &lt;&lt; "arr2:" &lt;&lt; endl;
  printArray(arr2);
  cout &lt;&lt; "arr2容量:" &lt;&lt; arr2.getCapacity() &lt;&lt; " 大小:" &lt;&lt; arr2.getSize() &lt;&lt; endl;
  //MyArray&lt;int&gt;arr3(100);
  //arr3 = arr1;
}
//测试自定义数据类型
class Person
{
public:
  Person() {};
  Person(string name, int age)
  {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
  }
  string m_Name;
  int m_Age;

};
void printPersonArray(MyArray&lt;Person&gt;&amp; arr)
{
  for (int i = 0;i &lt; arr.getSize();i++)
  {
    cout &lt;&lt; "姓名:" &lt;&lt; arr[i].m_Name &lt;&lt; " 年龄:" &lt;&lt; arr[i].m_Age &lt;&lt; endl;
  }
}
void Test02()
{
  MyArray&lt;Person&gt; arr(10);
  Person p1("孙悟空", 999);
  Person p2("韩信", 20);
  Person p3("李白", 25);
  Person p4("安其拉", 18);
  Person p5("蔡文姬", 12);
  arr.Push_Back(p1);
  arr.Push_Back(p2);
  arr.Push_Back(p3);
  arr.Push_Back(p4);
  arr.Push_Back(p5);
  printPersonArray(arr);
  cout &lt;&lt; "arr容量:" &lt;&lt; arr.getCapacity() &lt;&lt; " 大小:" &lt;&lt; arr.getSize() &lt;&lt; endl;
}
int main() {
  Test02();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-STL"><a href="#3-2-STL" class="headerlink" title="3.2 STL"></a>3.2 STL</h3><p>STL(标准模块库)<br>从广义上分为:<code>容器</code>、<code>算法</code>、<code>迭代器</code><br>容器和算法间通过迭代器进行无缝连接</p><p>STL六大组件:容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器<br>1.容器:各种数据结构,如vector、list、deque、set、map等,用来存放数据。<br>2.算法:各种常用的算法,如sort、find、copy、for_each等。<br>3.迭代器:扮演了容器与算法之间的胶合剂。<br>4.仿函数:行为类似函数,可作为算法的某种策略。<br>5.适配器(配接器):一种用来修饰容器或者仿函数或迭代器接口的东西。<br>6.空间配置器:负责空间的配置与管理。</p><h4 id="3-2-1-容器算法迭代器"><a href="#3-2-1-容器算法迭代器" class="headerlink" title="3.2.1 容器算法迭代器"></a>3.2.1 容器算法迭代器</h4><p>容器:置物之所也<br>STL容器就是运用最广泛的一些数据结构实现出来<br>常见的数据结构:数组、链表、树、栈、队列、集合、映射表 等<br>分类:</p><ul><li>序列式容器:强调值的排序,序列式容器中的每个元素有固定的位置。</li><li>关联式容器:二叉树结构,各元素之间没有严格的物理上的顺序关系。</li></ul><p>算法:问题之解法也<br>有限的步骤,解决逻辑或数学上的问题,这一门学科我们叫做算法<br>分类:</p><ul><li>质变算法:是指运算过程中会更改区间内的元素的内容。例如拷贝,替换,删除等等</li><li>非质变算法:是指运算过程中不会更改区间内的元素的内容。例如查找,计数,遍历,寻求极值等等</li></ul><p>迭代器:容器和算法之间粘合剂<br>提供一种方法,使之能够依序寻访某个容器所含的各个元素,而又无需暴露该容器的内部表示方式。<br>每个容器都有自己专属的迭代器<br>迭代器使用非常类似于指针,初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类:</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读,支持<code>++、==、!=</code></td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写,支持<code>++</code></td></tr><tr><td>前向迭代器</td><td>读写操作,并能向前推进迭代器</td><td>读写,支持<code>++、==、!=</code></td></tr><tr><td>双向迭代器</td><td>读写操作,并能向前和向后操作</td><td>读写,支持<code>++、--</code></td></tr><tr><td>随机访问迭代器</td><td>读写操作,可以以跳跃的方式访问任意数据,功能最强的迭代器</td><td>读写,支持<code>++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</code></td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器和随机访问迭代器</p><h5 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h5><p>容器: <code>vector</code><br>算法: <code>for_each</code><br>迭代器: <code>vector&lt;int&gt;::iterator</code></p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;//标准算法头文件
using namespace std;
//STL六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配装器

//vector容器存放内置数据类型
void MyPrint(int val)
{
  cout &lt;&lt; val &lt;&lt; endl;
}
void test01()
{
  vector&lt;int&gt; v;
  //向容器中插入数据
  v.push_back(10);
  v.push_back(20);
  v.push_back(30);
  v.push_back(40);
  //通过迭代器访问数据
  vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器，指向容器中第一个元素
  vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器，指向容器最后一个元素的下一个位置
  //第一种遍历方式
  while (itBegin!=itEnd)
  {
    cout &lt;&lt; *itBegin &lt;&lt; endl;
    itBegin++;
  }
  //第二种
  for (vector&lt;int&gt;::iterator it = v.begin();it != v.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; endl;
  }
  //第三种 STL(for_each)包含头文件#include&lt;algorithm&gt;
  for_each(v.begin(), v.end(), MyPrint);
}
//容器嵌套容器
void test02()
{
  vector&lt;vector&lt;int&gt;&gt;v;
  //创建小容器
  vector&lt;int&gt;v1;
  vector&lt;int&gt;v2;
  vector&lt;int&gt;v3;
  vector&lt;int&gt;v4;

  //向小容器中添加数据
  for (int i = 0;i &lt; 4;i++)
  {
    v1.push_back(i + 1);
    v2.push_back(i + 2);
    v3.push_back(i + 3);
    v4.push_back(i + 4);
  }
  //将小容器插入到大容器中
  v.push_back(v1);
  v.push_back(v2);
  v.push_back(v3);
  v.push_back(v4);
  //通过大容器将所有数据遍历一遍
  for (vector&lt;vector&lt;int&gt;&gt;::iterator it= v.begin(); it!=v.end(); it++)
  {
    //(*it)---容器vector&lt;int&gt;
    for (vector&lt;int&gt;::iterator vit = (*it).begin();vit != (*it).end(); vit++)
    {
      cout &lt;&lt; *vit &lt;&lt; " ";

    }
    cout &lt;&lt; endl;
  }
}
int main()
{
  test02();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vector也可以存放自定义数据类型</p><h4 id="3-2-2-string容器"><a href="#3-2-2-string容器" class="headerlink" title="3.2.2 string容器"></a>3.2.2 string容器</h4><p>本质: string 是C++风格的字符串,而string本质上是一个类</p><p>string 和 char* 区别:</p><ul><li>char* 是一个指针</li><li>string 是一个类,类内部封装了char* ,管理这个字符串,是一个 char* 型的容器。</li></ul><p>特点:<br>string类内部封装了很多成员方法<br>例如:查找find,拷贝copy,删除delete,替换replace,插入insert<br>string 管理char* 所分配的内存,不用担心复制越界和取值越界等,由类内部进行负责</p><h5 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h5><p>构造函数原型:</p><ul><li><code>string();</code> //创建一个空的字符串 例如:string str;<br><code>string(const char* s);</code> //使用字符串s初始化</li><li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li><li><code>string(int n,char c);</code> //使用n个字符c初始化</li></ul><h5 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h5><p>功能:给string字符串进行赋值</p><p>赋值的函数原型:</p><ul><li><code>string&amp; operator=(const char* s);</code> //给char* 类型字符串 赋值给当前字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s,int n);</code> //把字符串s的前n个字符赋值给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code> //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n,char c);</code> //把n个字符c赋给当前字符串</li></ul><p>operator=方式比较实用</p><h5 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h5><p>功能:实现在字符串末尾拼接字符串</p><p>函数原型:</p><ul><li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li><li><code>string&amp; append(const char *s);</code> //把字符串s拼接到当前字符串结尾</li><li><code>string&amp; append(const char *s,int n);</code> //把字符串s的前n个字符连接到当前的字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s,int pos,int n);</code> //字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><h5 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h5><p>功能:</p><ul><li>查找:查找指定字符串是否存在</li><li>替换:在指定的位置替换字符串</li></ul><p>函数原型:</p><ul><li><code>int find(const string&amp; str,int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s,int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s,int pos,int n) const;</code> //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c,int pos = 0) const;</code> //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str,int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s,int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s,int pos,int n) const;</code> //从pos位置查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c,int pos = 0) const;</code> //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos,int n,const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos,int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li></ul><h5 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h5><p>功能:字符串之间的比较</p><p>比较方式:<br>字符串比较是按字符的ASCII码进行对比</p><ul><li>= 返回 0</li><li><blockquote><p>返回 1</p></blockquote></li><li>&lt; 返回 -1</li></ul><p>函数原型:</p><ul><li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul><p>主要用于比较俩个字符串是否相等</p><h5 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h5><p>存取方式:</p><ul><li><code>char&amp; operator[](int n);</code> //通过<code>[]</code>方式取字符</li><li><code>char&amp; at(int n);</code> //通过at方法获取字符</li></ul><h5 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h5><p>功能:对string字符串进行插入和删除字符操作</p><p>函数原型:</p><ul><li><code>string&amp; insert(int pos,const char* s);</code> //插入字符串</li><li><code>string&amp; insert(int pos,const string&amp; str);</code> //插入字符串</li><li><code>string&amp; insert(int pos,int n,char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos,int n = npos);</code> //删除从pos开始的n个字符</li></ul><p>插入和删除下标从0开始</p><h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><p>功能:从字符串中获取想要的子串</p><p>函数原型:</p><ul><li><code>string substr(int pos = 0,int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//string 构造函数
void test01()
{
  string s1;//默认构造
  const char* str = "hello world";
  string s2(str);
  cout &lt;&lt; "s2=" &lt;&lt; s2 &lt;&lt; endl;
  string s3(s2);
  cout &lt;&lt; "s3=" &lt;&lt; s3 &lt;&lt; endl;
  string s4(10, 'a');
  cout &lt;&lt; "s4=" &lt;&lt; s4 &lt;&lt; endl;
}
//string 赋值操作
void test02()
{
  string str1;
  str1 = "hello world";
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;

  string str2;
  str2 = str1;
  cout &lt;&lt; "str2=" &lt;&lt; str2 &lt;&lt; endl;

  string str3;
  str3 = 's';
  cout &lt;&lt; "str3=" &lt;&lt; str3 &lt;&lt; endl;

  string str4;
  str4.assign("hello c++");
  cout &lt;&lt; "str4=" &lt;&lt; str4 &lt;&lt; endl;

  string str5;
  str5.assign("hello c++",5);
  cout &lt;&lt; "str5=" &lt;&lt; str5 &lt;&lt; endl;

  string str6;
  str6.assign(str5);
  cout &lt;&lt; "str6=" &lt;&lt; str6 &lt;&lt; endl;

  string str7;
  str7.assign(10, 'w');
  cout &lt;&lt; "str7=" &lt;&lt; str7 &lt;&lt; endl;
}
//string字符串拼接
void test03()
{
  string str1 = "我";
  str1 += "爱学习";
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;
  str1 += ':';
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;
  string str2=" java,python";
  str1 += str2;
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;
  string str3 = "I";
  str3.append(" Love");
  cout &lt;&lt; "str3=" &lt;&lt; str3 &lt;&lt; endl;
  str3.append(" You,",4);
  cout &lt;&lt; "str3=" &lt;&lt; str3 &lt;&lt; endl;
  //str3.append(str2);
  str3.append(str2, 0, 5);//第二个为开始位置（从0开始）第三个参数为截取长度
  cout &lt;&lt; "str3=" &lt;&lt; str3 &lt;&lt; endl;
}
//string字符串查找
void test04()
{
  string str1 = "abcdefgde";
  int pos=str1.find("de");
  cout &lt;&lt; "find:pos=" &lt;&lt; pos &lt;&lt; endl;
  //rfind和find区别
  //rfind从右往左查找，find从左往右查找
  pos = str1.rfind("de");
  cout &lt;&lt; "rfind:pos=" &lt;&lt; pos &lt;&lt; endl;
}
//字符串替换
void test05()
{
  string str1 = "abcdefg";
  //从1号位置(从0开始)起，3个字符替换为“1111”
  str1.replace(1, 3, "1111");
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;//a1111efg
}
//字符串比较
void test06()
{
  string str1 = "xbcd";
  string str2 = "abcd";
  //主要用于比较是否相等
  if (str1.compare(str2) == 0)
  {
    cout &lt;&lt; "str1=str2" &lt;&lt; endl;
  }
  else if (str1.compare(str2) &gt; 0)
  {
    cout &lt;&lt; "str1&gt;str2" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "str1&lt;str2" &lt;&lt; endl;
  }
}
//字符存取
void test07()
{
  string str1 = "hello";
  str1[0] = 'x';
  str1.at(1) = 'x';
  //1.通过[]访问单个字符
  for (int i = 0;i &lt; str1.size();i++)
  {
    cout &lt;&lt; str1[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
  //2.通过at方式访问单个字符
  for (int i = 0;i &lt; str1.size();i++)
  {
    cout &lt;&lt; str1.at(i) &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//字符串插入和删除
void test08()
{
  string str1 = "hello";
  //插入
  str1.insert(1, "111");
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;
  //删除
  str1.erase(1, 3);//第一个参数：从当前位置起,第二个参数：删除多少个
  cout &lt;&lt; "str1=" &lt;&lt; str1 &lt;&lt; endl;
}
//string 子串
void test09()
{
  string str = "abcdefg";
  string subStr = str.substr(1, 3);//第一个参数：从当前位置起,第二个参数：截取多少个
  cout &lt;&lt; "subStr=" &lt;&lt; subStr &lt;&lt; endl;
  /*
  string email = "xxx@qq.com";
  int pos = email.find("@");
  string username = email.substr(0,pos);
  */
}
int main()
{
  test09();
  system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-3-vector容器"><a href="#3-2-3-vector容器" class="headerlink" title="3.2.3 vector容器"></a>3.2.3 vector容器</h4><p>功能: vector数据结构与数组非常相似,也称为单端数组</p><p>vector与普通数组区别: 不同之处在于数组是静态空间,而vector可以<code>动态扩展</code></p><p>动态扩展:</p><ul><li>并不是在原空间之后续接新空间,而是找更大的内存空间,然后将原数据拷贝新空间,释放原空间</li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h5 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h5><p>功能:创建vector容器</p><p>函数原型:</p><ul><li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现,默认构造函数</li><li><code>vector(v.begin(),v.end());</code> //将v[begin(),end())区间中的元素拷贝给本身。</li><li><code>vector(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数</li></ul><h5 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h5><p>功能:给vector容器进行赋值</p><p>函数原型:</p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code> //重载等号操作符</li><li><code>assign(begin,end);</code> //将[begin,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code> //将n个elem拷贝赋值给本身</li></ul><h5 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h5><p>功能:对vector容器的容量和大小操作</p><p>函数原型:</p><ul><li><code>empty();</code> //判断容器是否为空</li><li><code>capacity();</code> //容器的容量</li><li><code>size();</code> //返回容器中元素的个数</li><li><code>resize(int num);</code> //重新指定容器的长度为num。若容器变长,则以默认值填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li><li><code>resize(int num,elem);</code> //重新指定容器的长度为num。若容器变长,则以elem填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li></ul><h5 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h5><p>功能:对vector容器进行插入、删除操作</p><p>函数原型:</p><ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos,ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos,int count,ele);</code> //迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指定的元素</li><li><code>erase(const_iterator start,const_iterator end);</code> //删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul><h5 id="vector数据读取"><a href="#vector数据读取" class="headerlink" title="vector数据读取"></a>vector数据读取</h5><p>功能:对vector中的数据的存取操作</p><p>函数原型:</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个元素</li><li><code>back();</code> //返回容器中最后一个元素</li></ul><h5 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h5><p>功能:实现俩个容器中元素进行互换</p><p>函数原型:</p><ul><li><code>swap(vec);</code> //将vec与本身元素互换</li></ul><h5 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h5><p>功能:减少vector在动态扩展容量时的扩展次数</p><p>函数原型:</p><ul><li><code>reserve(int len);</code> //容器预留len个元素长度,预留位置不初始化,元素不可访问</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;

void printVector(vector&lt;int&gt;&amp;v)
{
  for (vector&lt;int&gt;::iterator it = v.begin();it != v.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//vector容器构造
void test01()
{
  vector&lt;int&gt;v1;//默认构造 无参构造
  for (int i = 0; i &lt; 10; i++)
  {
    v1.push_back(i);
  }
  printVector(v1);
  //通过区间方式进行构造
  vector&lt;int&gt;v2(v1.begin(), v1.end());
  printVector(v2);
  //n个elem方式构造
  vector&lt;int&gt;v3(10, 100);
  printVector(v3);
  //拷贝构造
  vector&lt;int&gt;v4(v3);
  printVector(v4);
}
//vector赋值操作
void test02()
{
  vector&lt;int&gt;v1;
  for (int i = 0; i &lt; 10; i++)
  {
    v1.push_back(i);
  }
  printVector(v1);
  //赋值 operator=
  vector&lt;int&gt;v2;
  v2 = v1;
  printVector(v2);
  //assign
  vector&lt;int&gt;v3;
  v3.assign(v1.begin(), v1.end());
  printVector(v3);
  //n个elem
  vector&lt;int&gt;v4;
  v4.assign(10, 100);
  printVector(v4);
}
//vector容量和大小
void test03()
{
  vector&lt;int&gt;v1;
  for (int i = 0; i &lt; 10; i++)
  {
    v1.push_back(i);
  }
  printVector(v1);

  if (v1.empty())
  {
    cout &lt;&lt; "v1为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "v1不为空" &lt;&lt; " 容量为 " &lt;&lt; v1.capacity() &lt;&lt; " 大小 " &lt;&lt; v1.size() &lt;&lt; endl;
  }
  //重新指定大小
  v1.resize(15,100);//默认以0填充 这里指定为100
  printVector(v1);
  v1.resize(5);
  printVector(v1);//超出容器长度的元素被删除
}
//vector插入和删除
void test04()
{
  vector&lt;int&gt;v1;
  v1.push_back(10);
  v1.push_back(20);
  v1.push_back(30);
  v1.push_back(40);
  v1.push_back(50);
  //遍历
  printVector(v1);
  //尾删
  v1.pop_back();
  printVector(v1);
  //插入
  v1.insert(v1.begin(), 100);
  printVector(v1);

  v1.insert(v1.begin(), 2, 1000);
  printVector(v1);

  //删除 参数也是迭代器
  v1.erase(v1.begin());
  printVector(v1);
  //清空
  //v1.erase(v1.begin(), v1.end());
  //printVector(v1);
  v1.clear();
  printVector(v1);
}
//vector数据读取
void test05()
{
  vector&lt;int&gt;v1;
  for (int i = 0; i &lt; 10; i++)
  {
    v1.push_back(i);
  }
  //利用[]访问元素
  for (int i = 0;i &lt; v1.size();i++)
  {
    cout &lt;&lt; v1[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
  //利用at访问元素
  for (int i = 0;i &lt; v1.size();i++)
  {
    cout &lt;&lt; v1.at(i)&lt;&lt; " ";
  }
  cout &lt;&lt; endl;
  //获取第一个元素
  cout &lt;&lt; "第一个元素:" &lt;&lt; v1.front() &lt;&lt; endl;
  //获取最后一个元素
  cout &lt;&lt; "最后一个元素:" &lt;&lt; v1.back() &lt;&lt; endl;
}
//vector互换容器
//1.基本使用
void test06()
{
  vector&lt;int&gt;v1;
  for (int i = 0; i &lt; 10; i++)
  {
    v1.push_back(i);
  }
  cout &lt;&lt; "交换前:" &lt;&lt; endl;
  printVector(v1);
  vector&lt;int&gt;v2;
  for (int i = 10; i &gt;0; i--)
  {
    v2.push_back(i);
  }
  printVector(v2);
  cout &lt;&lt; "交换后:" &lt;&lt; endl;
  v1.swap(v2);
  printVector(v1);
  printVector(v2);
}
//2.实际用途
//巧用swap可以收缩内存空间
void test07()
{
  vector&lt;int&gt;v;
  for (int i = 0; i &lt; 100000; i++)
  {
    v.push_back(i);
  }
  cout &lt;&lt; "v 的容量:" &lt;&lt; v.capacity() &lt;&lt; endl;
  cout &lt;&lt; "v 的大小:" &lt;&lt; v.size() &lt;&lt; endl;
  v.resize(3);//重新指定大小
  cout &lt;&lt; "v 的容量:" &lt;&lt; v.capacity() &lt;&lt; endl;
  cout &lt;&lt; "v 的大小:" &lt;&lt; v.size() &lt;&lt; endl;
  //巧用swap可以收缩内存空间
  vector&lt;int&gt;(v).swap(v);
  cout &lt;&lt; "v 的容量:" &lt;&lt; v.capacity() &lt;&lt; endl;
  cout &lt;&lt; "v 的大小:" &lt;&lt; v.size() &lt;&lt; endl;
}
//vector预留空间
void test08()
{
  vector&lt;int&gt;v;
  //利用reserve预留空间
  v.reserve(100000);
  int num = 0;
  int* p = NULL;
  for (int i = 0; i &lt; 100000; i++)
  {
    v.push_back(i);
    if (p != &amp;v[0])
    {
      p = &amp;v[0];
      num++;
    }
  }
  cout &lt;&lt; num &lt;&lt; endl;
}
int main()
{
  test08();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-deque容器"><a href="#3-2-4-deque容器" class="headerlink" title="3.2.4 deque容器"></a>3.2.4 deque容器</h4><p>功能:双端数组,可以对头端进行插入和删除操作</p><p>deque与vector区别:</p><ul><li>vector对于头部的插入删除效率低,数据量越大,效率越低</li><li>deque相对而言,对头部的插入删除速度比vector快</li><li>vector访问元素时的速度比deque快,这和俩者内部实现有关</li></ul><p>deque内部工作原理:<br>deque内部有个<code>中控器</code>,维护每段缓冲区中的内容,缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址,使得使用deque时像一片连续的内存空间</p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h5 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h5><p>功能:deque容器构造</p><p>函数原型:</p><ul><li><code>deque&lt;T&gt;deqT;</code> //默认构造形式</li><li><code>deque(beg,end);</code> //构造函数将[beg,end)区间中的元素拷贝给本身</li><li><code>deque(n,elem);</code> //构造函数将n个elem拷贝给本身</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul><h5 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h5><p>功能:给deque容器赋值</p><p>函数原型:</p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</li><li><code>assign(beg,end);</code> //将[beg,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code> //将n个elem拷贝赋值给本身</li></ul><h5 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h5><p>功能:对deque容器的大小进行操作</p><p>函数原型:</p><ul><li><code>deque.empty();</code> //判断容器是否为空</li><li><code>deque.size();</code> //返回容器中元素的个数</li><li><code>deque.resize(num);</code> //重新指定容器的长度为num。若容器变长,则以默认值填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li><li><code>deque.resize(num,elem);</code> //重新指定容器的长度为num。若容器变长,则以elem填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li></ul><h5 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h5><p>功能:向deque容器中插入和删除数据</p><p>函数原型:</p><p>俩端插入操作:</p><ul><li><code>push_back(elem);</code> //在容器尾部插入一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul><p>指定位置操作:</p><ul><li><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝,返回新数据的位置</li><li><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据,无返回值</li><li><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据,无返回值</li><li><code>clear();</code> //删除容器中所有数据</li><li><code>erase(beg,end);</code> //删除[beg,end)区间的数据,返回下一个数据的位置</li><li><code>erase(pos);</code> //删除pos位置的数据,返回下一个数据的位置</li></ul><h5 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h5><p>功能:对deque中的数据的存取操作</p><p>函数原型:</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><h5 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h5><p>功能:利用算法实现对deque容器进行排序</p><p>算法:</p><ul><li><code>sort(iterator beg,iterator end)</code> //对beg和end区间内元素进行排序</li></ul><p>对于支持随机访问的迭代器的容器,都可以利用sort算法直接对其进行排序</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;deque&gt;
#include&lt;algorithm&gt;//标准算法头文件
void printDeque(const deque&lt;int&gt;&amp; d)
{
  for (deque&lt;int&gt;::const_iterator it = d.begin();it != d.end();it++)
  {
    //容器里的数据不可以修改
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//deque构造函数
void test01()
{
  deque&lt;int&gt;d1;
  for (int i = 0;i &lt; 10;i++)
  {
    d1.push_back(i);
  }
  printDeque(d1);
  deque&lt;int&gt;d2(d1.begin(),d1.end());
  printDeque(d2);
  deque&lt;int&gt;d3(10,100);
  printDeque(d3);
  deque&lt;int&gt;d4(d3);
  printDeque(d4);
}
//deque赋值操作
void test02()
{
  deque&lt;int&gt;d1;
  for (int i = 0;i &lt; 10;i++)
  {
    d1.push_back(i);
  }
  printDeque(d1);
  //operator=赋值
  deque&lt;int&gt;d2;
  d2 = d1;
  printDeque(d2);
  //assign 赋值
  deque&lt;int&gt;d3;
  d3.assign(d1.begin(), d1.end());
  printDeque(d3);

  deque&lt;int&gt;d4;
  d4.assign(10, 100);
  printDeque(d4);
}
//deque大小操作
void test03()
{
  deque&lt;int&gt;d1;
  for (int i = 0;i &lt; 10;i++)
  {
    d1.push_back(i);
  }
  printDeque(d1);
  if (d1.empty())
  {
    cout &lt;&lt; "d1为空" &lt;&lt; endl;
  }
  else 
  {
    cout &lt;&lt; "d1不为空" &lt;&lt; endl;
    cout &lt;&lt; "d1大小为:" &lt;&lt; d1.size() &lt;&lt; endl;//没有容量概念
  }
  //重新指定大小
  d1.resize(15,1);
  printDeque(d1);//默认以0填充

  d1.resize(5);
  printDeque(d1);
}
//deque插入和删除
void test04()
{
  deque&lt;int&gt;d1;
  //尾插
  d1.push_back(10);
  d1.push_back(20);
  //头插
  d1.push_front(100);
  d1.push_front(200);
  printDeque(d1);//200 100 10 20
  //尾删
  d1.pop_back();
  printDeque(d1);
  //头删
  d1.pop_front();
  printDeque(d1);
}
//指定位置插入和删除
void test05()
{
  deque&lt;int&gt;d1;
  //尾插
  d1.push_back(10);
  d1.push_back(20);
  //头插
  d1.push_front(100);
  d1.push_front(200);
  printDeque(d1);
  //insert 插入
  d1.insert(d1.begin(), 1000);
  printDeque(d1);

  d1.insert(d1.begin(), 2, 10000);
  printDeque(d1);

  //按照区间插入
  deque&lt;int&gt;d2;
  d2.push_back(1);
  d2.push_back(2);
  d2.push_back(3);

  d1.insert(d1.begin(), d2.begin(), d2.end());
  printDeque(d1);

  //删除
  deque&lt;int&gt;::iterator it = d1.begin();
  it++;//第二个元素
  d1.erase(it);
  printDeque(d1);

  //清空
  //d1.erase(d1.begin(), d1.end());
  d1.clear();
  printDeque(d1);
}
//deque数据存取
void test06()
{
  deque&lt;int&gt;d1;
  //尾插
  d1.push_back(10);
  d1.push_back(20);
  d1.push_back(30);
  //头插
  d1.push_front(100);
  d1.push_front(200);
  d1.push_front(300);
  //通过[]方式访问元素
  for (int i = 0;i &lt; d1.size();i++)
  {
    cout &lt;&lt; d1[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
  //通过at方式访问元素
  for (int i = 0;i &lt; d1.size();i++)
  {
    cout &lt;&lt; d1.at(i) &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
  cout &lt;&lt; "第一个元素:" &lt;&lt; d1.front() &lt;&lt; endl;
  cout &lt;&lt; "最后一个元素:" &lt;&lt; d1.back() &lt;&lt; endl;
}
//deque排序
void test07()
{
  deque&lt;int&gt;d;
  //尾插
  d.push_back(10);
  d.push_back(20);
  d.push_back(30);
  //头插
  d.push_front(100);
  d.push_front(200);
  d.push_front(300);
  printDeque(d);

  //排序  #include&lt;algorithm&gt;//标准算法头文件
  sort(d.begin(), d.end());
  cout &lt;&lt; "排序后:" &lt;&lt; endl;
  printDeque(d);
}
int main()
{
  test07();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-评委打分"><a href="#案例-评委打分" class="headerlink" title="案例: 评委打分"></a>案例: 评委打分</h5><p>案例描述:<br>有5名选手:选手ABCDE,10个评委分别对每一个选手打分,去除最高分,去除评委最低分,求平均分</p><p>实现步骤:<br>1.创建五名选手,放到vector中<br>2.遍历vector容器,取出每一位选手,执行for循环,可以把10个评分分存到deque容器中<br>3.sort算法对deque容器中的分数进行排序,取出最高和最低分<br>4.deque容器遍历一遍,累加总分<br>5.获取平均分</p><p><a target="_blank" rel="noopener" href="https://github.com/liaojie1314/JudgesScore">代码</a></p><h4 id="3-2-5-stack容器"><a href="#3-2-5-stack容器" class="headerlink" title="3.2.5 stack容器"></a>3.2.5 stack容器</h4><p>stack是一种先进后出的数据结构,它只有一个出口</p><p>栈中只有顶端元素才可以被访问,因此不允许有遍历的行为</p><ul><li>入栈: <code>push</code></li><li>出栈: <code>pop</code></li></ul><h5 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h5><p>构造函数:</p><ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现,stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul><p>赋值操作:</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul><p>数据存取:</p><ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul><p>大小操作:</p><ul><li><code>empty();</code> //判断栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;stack&gt;
void test01()
{
  stack&lt;int&gt;s;
  //入栈
  s.push(10);
  s.push(20);
  s.push(30);
  s.push(40);
  if (!s.empty())
  {
    cout &lt;&lt; "栈顶元素: " &lt;&lt; s.top() &lt;&lt; endl;
    s.pop();//出栈
  }
  cout &lt;&lt; "栈的大小: " &lt;&lt; s.size() &lt;&lt; endl;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-queue容器"><a href="#3-2-6-queue容器" class="headerlink" title="3.2.6 queue容器"></a>3.2.6 queue容器</h4><p>queue是一种先进先出的数据结构,他有2个出口</p><p>队列容器只允许从一端新增数据,从另一端移除数据</p><p>队列中只有队头元素和队尾元才可以被访问,因此不允许有遍历的行为</p><ul><li>入队: <code>push</code></li><li>出队: <code>pop</code></li></ul><h5 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h5><p>构造函数:</p><ul><li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现,queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul><p>赋值操作:</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul><p>数据存取:</p><ul><li><code>push(elem);</code> //向队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul><p>大小操作:</p><ul><li><code>empty();</code> //判断队列是否为空</li><li><code>size();</code> //返回队列的大小</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;queue&gt;
void test01()
{
  queue&lt;int&gt;q;
  //入队
  q.push(10);
  q.push(20);
  q.push(30);
  q.push(40);
  if (!q.empty())
  {
    cout &lt;&lt; "第一个元素: " &lt;&lt; q.front() &lt;&lt; endl;
    cout &lt;&lt; "最后一个元素: " &lt;&lt; q.back() &lt;&lt; endl;
    q.pop();//出队
    cout &lt;&lt; "第一个元素: " &lt;&lt; q.front() &lt;&lt; endl;
    cout &lt;&lt; "最后一个元素: " &lt;&lt; q.back() &lt;&lt; endl;
  }
  cout &lt;&lt; "队列的大小: " &lt;&lt; q.size() &lt;&lt; endl;
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-7-list容器"><a href="#3-2-7-list容器" class="headerlink" title="3.2.7 list容器"></a>3.2.7 list容器</h4><p>功能:将数据进行链式存储</p><p><code>链表</code>是一种物理存储单元上非连续的存储结构,数据结构的逻辑顺序是通过链表中的指针链接实现的</p><ul><li>优点:可以对任意位置快速插入和删除</li><li>缺点:遍历速度没有数组快,占用空间比数组大</li></ul><p>链表组成:链表由一系列结点组成</p><p>结点的组成:一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域</p><p>STL中的链表是一个双向循环链表</p><p>list中的迭代器只支持前移和后移,属于<code>双向迭代器</code></p><p>list优点:</p><ul><li>采用动态存储分配,不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便,修改指针即可,不需要移动大量元素</li></ul><p>list缺点:</p><ul><li>空间(指针域)和时间(遍历)耗费较大</li></ul><p>插入和删除操作都不会造成原有list迭代器的失效,这在vector中是不成立的</p><blockquote><p>STL中List和vector是最常使用的容器</p></blockquote><h5 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h5><p>功能:创建list容器</p><p>函数原型:</p><ul><li><code>list&lt;T&gt; lst;</code> //list采用模板类实现,对象的默认构造形式</li><li><code>list(beg,end);</code> //构造函数将[beg,end)区间的元素拷贝给本身</li><li><code>list(n,elem);</code> ////构造函数将n个elem拷贝给本身</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数</li></ul><h5 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h5><p>功能:给list容器进行赋值,以及交换list容器</p><p>函数原型:</p><ul><li><code>assign(beg,end);</code> //将[beg,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code> //将n个elem拷贝赋值给本身</li><li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身元素互换</li></ul><h5 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h5><p>功能:对list容器的大小进行操作</p><p>函数原型:</p><ul><li><code>size();</code> //返回容器中元素的个数</li><li><code>empty();</code> //判断容器是否为空</li><li><code>resize(num);</code> //重新指定容器的长度为num。若容器变长,则以默认值填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li><li><code>resize(num,elem);</code> //重新指定容器的长度为num。若容器变长,则以elem填充新位置;如果容器变短,则末尾超出容器长度的元素被删除</li></ul><h5 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h5><p>功能:对list容器数据进行插入、删除操作</p><p>函数原型:</p><ul><li><code>push_back(elem);</code> //在容器尾部加入一个元素</li><li><code>pop_back();</code> //删除容器中最后一个元素</li><li><code>push_front(elem);</code> //在容器开头插入一个元素</li><li><code>pop_front();</code> //从容器开头移除第一个元素</li><li><code>insert(pos,elem);</code> //在pos位置插入elem元素的拷贝,返回新数据的位置</li><li><code>insert(pos,n,ele);</code> //在pos位置插入n个elem数据,无返回值</li><li><code>clear();</code> //删除容器中所有数据</li><li><code>erase(beg,end);</code> //删除[beg,end)区间的数据,返回下一个数据的位置</li><li><code>erase(pos);</code> //删除pos位置的数据,返回下一个数据的位置</li><li><code>remove(elem);</code> //删除容器中所有与elem值匹配的元素</li></ul><h5 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h5><p>功能:对list中的数据进行存取</p><p>函数原型:</p><ul><li><code>front();</code> //返回第一个元素</li><li><code>back();</code> //返回最后一个元素</li></ul><h5 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h5><p>功能:将容器中的元素反转,以及将容器中的数据进行排序</p><p>函数原型:</p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;list&gt;

void printList(const list&lt;int&gt;&amp; l)
{
  for (list&lt;int&gt;::const_iterator it = l.begin();it != l.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
void test01()
{
  //创建list容器
  list&lt;int&gt;l1;
  //添加数据
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  l1.push_back(40);
  //遍历容器
  printList(l1);
  //区间方式构造
  list&lt;int&gt;l2 (l1.begin(), l1.end());
  printList(l2);
  //拷贝构造
  list&lt;int&gt;l3(l2);
  printList(l3);
  //n个elem
  list&lt;int&gt;l4(10, 1000);
  printList(l4);
}
//list赋值和交换
void test02()
{
  //创建list容器
  list&lt;int&gt;l1;
  //添加数据
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  l1.push_back(40);
  //遍历容器
  printList(l1);
  list&lt;int&gt;l2;
  l2 = l1;
  printList(l2);

  list&lt;int&gt;l3;
  l3.assign(l2.begin(), l2.end());
  printList(l3);

  list&lt;int&gt;l4;
  l4.assign(10, 1000);
  printList(l4);
}
//交换
void test03()
{
  //创建list容器
  list&lt;int&gt;l1;
  //添加数据
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  l1.push_back(40);
  list&lt;int&gt;l2;
  l2.assign(10, 1000);
  cout &lt;&lt; "交换前:" &lt;&lt; endl;
  printList(l1);
  printList(l2);
  cout &lt;&lt; endl;
  l1.swap(l2);
  cout &lt;&lt; "交换后:" &lt;&lt; endl;
  printList(l1);
  printList(l2);
}
//list大小操作
void test04()
{
  //创建list容器
  list&lt;int&gt;l1;
  //添加数据
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  l1.push_back(40);
  if (l1.empty())
  {
    cout &lt;&lt; "l1为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "l1不为空" &lt;&lt; endl;
    cout &lt;&lt; "l1的大小为:" &lt;&lt; l1.size() &lt;&lt; endl;
  }
  //重新指定大小
  l1.resize(10);
  printList(l1);
  l1.resize(2);
  printList(l1);
}
//list插入和删除
void test05()
{
  //创建list容器
  list&lt;int&gt;l1;
  //尾插
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  //头插
  l1.push_front(100);
  l1.push_front(200);
  l1.push_front(300);
  printList(l1);

  //尾删
  l1.pop_back();
  printList(l1);
  //头删
  l1.pop_front();
  printList(l1);

  //插入
  list&lt;int&gt;::iterator it = l1.begin();
  l1.insert(++it, 1000);
  printList(l1);

  //删除
  it = l1.begin();
  l1.erase(++it);//删除第二个元素
  printList(l1);

  //移除
  l1.push_back(10000);
  l1.push_back(10000);
  l1.push_back(10000);
  printList(l1);
  l1.remove(10000);
  printList(l1);

  //清空
  l1.clear();
  printList(l1);
}
//list数据存取
void test06()
{
  //创建list容器
  list&lt;int&gt;l1;
  //尾插
  l1.push_back(10);
  l1.push_back(20);
  l1.push_back(30);
  l1.push_back(40);
  //cout&lt;&lt;l1.at(0)&lt;&lt;endl;//错误 不支持at访问数据
  //cout&lt;&lt;l1[0]&lt;&lt;endl;//错误 不支持[]访问数据
  cout &lt;&lt; "第一个元素:" &lt;&lt; l1.front() &lt;&lt; endl;
  cout &lt;&lt; "最后一个元素:" &lt;&lt; l1.back() &lt;&lt; endl;
  //list容器的迭代器是双向迭代器,不支持随机访问
  list&lt;int&gt;::iterator it = l1.begin();
  //it = it + 1;//错误 不可以跳跃访问 即使是+1
}
//list反转和排序
bool myCompare(int val1, int val2)
{
  return val1 &gt; val2;
}
void test07()
{
  //创建list容器
  list&lt;int&gt;l1;
  //尾插
  l1.push_back(90);
  l1.push_back(30);
  l1.push_back(20);
  l1.push_back(70);
  printList(l1);
  //反转
  l1.reverse();
  printList(l1);
  //排序
  l1.sort();//默认排序规则 从小到大
  printList(l1);

  l1.sort(myCompare);//指定规则 从大到小
  printList(l1);

}
int main()
{
  test07();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-list容器排序"><a href="#案例-list容器排序" class="headerlink" title="案例: list容器排序"></a>案例: list容器排序</h5><p>案例描述:<br>将Person自定义数据类型进行排序,Person中属性有姓名、年龄、身高<br>排序规则: 按照年龄进行升序,如果年龄相同按照身高进行降序</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;list&gt;
class Person
{
public:
  Person(string name, int age, int height)
  {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
    this-&gt;m_Height = height;
  }
  string m_Name;
  int m_Age;
  int m_Height;
};
//指定排序规则
bool comparePerson(Person &amp;p1,Person &amp;p2)
{
  if (p1.m_Age == p2.m_Age)
  {
    //年龄相同 身高降序
    return p1.m_Height &gt; p2.m_Height;
  }
  else
  {
    //按照年龄升序
    return p1.m_Age &lt; p2.m_Age;
  }
}
void test01()
{
  list&lt;Person&gt;L;
  //准备数据
  Person p1("刘备", 35, 175);
  Person p2("关羽", 45, 180);
  Person p3("孙权", 40, 170);
  Person p4("赵云", 25, 190);
  Person p5("张飞", 35, 160);
  Person p6("关羽", 35, 200);
  //插入数据
  L.push_back(p1);
  L.push_back(p2);
  L.push_back(p3);
  L.push_back(p4);
  L.push_back(p5);
  L.push_back(p6);
  for (list&lt;Person&gt;::iterator it = L.begin();it != L.end();it++)
  {
    cout &lt;&lt; "姓名: " &lt;&lt; (*it).m_Name &lt;&lt; 
      " 年龄: " &lt;&lt; it-&gt;m_Age &lt;&lt; 
      " 身高: " &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
  }
  //排序
  cout &lt;&lt; "排序后:" &lt;&lt; endl;
  L.sort(comparePerson);
  for (list&lt;Person&gt;::iterator it = L.begin();it != L.end();it++)
  {
    cout &lt;&lt; "姓名: " &lt;&lt; (*it).m_Name &lt;&lt;
      " 年龄: " &lt;&lt; it-&gt;m_Age &lt;&lt;
      " 身高: " &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
  }
}
int main()
{
  test01();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-8-set-multiset容器"><a href="#3-2-8-set-multiset容器" class="headerlink" title="3.2.8 set/multiset容器"></a>3.2.8 set/multiset容器</h4><p>set:<br>所有元素都会在插入时被排序</p><p>本质:set/multiset属于<code>关联式容器</code>,底层结构是用<code>二叉树</code>实现的</p><p>set与multiset区别:</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h5 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h5><p>功能:创建set容器以及赋值</p><p>构造:</p><ul><li><code>set&lt;T&gt; st;</code> //默认构造函数</li><li><code>set(const set &amp;st);</code> //拷贝构造函数</li></ul><p>赋值:</p><ul><li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li></ul><h5 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h5><p>功能:统计set容器大小以及交换set容器</p><p>函数原型:</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换俩个集合容器</li></ul><h5 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h5><p>功能:set容器进行插入和删除数据</p><p>函数原型:</p><ul><li><code>insert(elem);</code> //在容器中插入元素</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素,返回下一个元素的迭代器</li><li><code>erase(beg,end);</code> //删除区间[beg,end)的所有元素,返回下一个元素的迭代器</li><li><code>erase(elem);</code> //删除容器中值为elem的元素</li></ul><h5 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h5><p>功能:对set容器进行查找数据以及统计数据</p><p>函数原型:</p><ul><li><code>find(key);</code> //查找key是否存在,若存在返回该键的元素的迭代器;若不存在返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><h5 id="set与multiset区别"><a href="#set与multiset区别" class="headerlink" title="set与multiset区别"></a>set与multiset区别</h5><p>区别:</p><ul><li>set不允许插入重复元素,而multiset可以</li><li>set插入数据的同时会返回插入结果,表示插入是否成功</li><li>multiset不会检测数据,因此可以插入重复数据</li></ul><h5 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h5><p>功能:成对出现的数据,利用对组可以返回俩个数据</p><p>创建方式:</p><ul><li><code>pair&lt;type,type&gt; p (value1,value2);</code></li><li><code>pair&lt;type,type&gt; p = make_pair(value1,value2);</code></li></ul><h5 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h5><p>1.内置数据类型</p><p>2.自定义数据类型</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;set&gt;
#include&lt;string&gt;

void printSet(set&lt;int&gt;&amp; s)
{
  for (set&lt;int&gt;::iterator it = s.begin();it != s.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//set构造和赋值
void test01()
{
  set&lt;int&gt;s1;
  //插入数据只有insert方法
  s1.insert(10);
  s1.insert(20);
  s1.insert(40);
  s1.insert(30);
  //遍历容器
  //set容器特点:所有元素插入时候自动排序
  //不允许插入重复值
  printSet(s1);
  //拷贝构造
  set&lt;int&gt;s2(s1);
  printSet(s2);
  //赋值
  set&lt;int&gt;s3;
  s3 = s2;
  printSet(s3);
}
//set大小和交换
void test02()
{
  set&lt;int&gt;s1;
  //插入数据只有insert方法
  s1.insert(10);
  s1.insert(20);
  s1.insert(40);
  s1.insert(30);
  if (s1.empty())
  {
    cout &lt;&lt; "s1为空" &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; "s1不为空" &lt;&lt; endl;
    cout &lt;&lt; "s1大小为:" &lt;&lt; s1.size() &lt;&lt; endl;
  }
  set&lt;int&gt;s2;
  s2.insert(1);
  s2.insert(2);
  s2.insert(9);
  s2.insert(3);
  cout &lt;&lt; "交换前:" &lt;&lt; endl;
  printSet(s1);
  printSet(s2);
  cout &lt;&lt; "交换后:" &lt;&lt; endl;
  s1.swap(s2);
  printSet(s1);
  printSet(s2);
}
//set插入和删除
void test03()
{
  set&lt;int&gt;s1;
  //插入数据只有insert方法
  s1.insert(10);
  s1.insert(20);
  s1.insert(40);
  s1.insert(30);
  printSet(s1);

  //删除 排序后的
  s1.erase(s1.begin());
  printSet(s1);

  s1.erase(30);
  printSet(s1);
  //清空
  //s1.erase(s1.begin(), s1.end());
  s1.clear();
  printSet(s1);
}
//set查找和统计
void test04()
{
  set&lt;int&gt;s1;
  //插入数据只有insert方法
  s1.insert(10);
  s1.insert(20);
  s1.insert(40);
  s1.insert(30);
  s1.insert(30);
  s1.insert(30);
  printSet(s1);
  set&lt;int&gt;::iterator pos = s1.find(30);
  if (pos != s1.end()) {
    cout &lt;&lt; "找到元素:" &lt;&lt; *pos &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "没找到" &lt;&lt; endl;
  }
  //统计30 的个数 对于set而言结果只能为0或者1
  int num = s1.count(30);
  cout &lt;&lt; num &lt;&lt; endl;
}
//set与multiset区别
void test05()
{
  set&lt;int&gt;s1;
  //插入数据只有insert方法
  pair&lt;set&lt;int&gt;::iterator,bool&gt; ret =  s1.insert(10);
  if (ret.second)
  {
    cout &lt;&lt; "第一次插入成功" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "第一次插入失败" &lt;&lt; endl;
  }
  ret = s1.insert(10);
  if (ret.second)
  {
    cout &lt;&lt; "第二次插入成功" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "第二次插入失败" &lt;&lt; endl;
  }
  multiset&lt;int&gt;ms;
  ms.insert(10);
  ms.insert(10);
  for (multiset&lt;int&gt;::iterator it = ms.begin();it != ms.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//pair对组创建
void test06()
{
  //1
  pair&lt;string, int&gt;p1("Tom", 20);
  cout &lt;&lt; "姓名:" &lt;&lt; p1.first &lt;&lt; "年龄:" &lt;&lt; p1.second &lt;&lt; endl;
  //2
  pair&lt;string, int&gt;p2 = make_pair("Jory", 18);
  cout &lt;&lt; "姓名:" &lt;&lt; p2.first &lt;&lt; "年龄:" &lt;&lt; p2.second &lt;&lt; endl;
}
//set排序
//内置数据类型
class MyCompare
{
public:
  bool operator()(int v1,int v2) const
  {
    return v1 &gt; v2;
  }
};
void test07()
{
  set&lt;int&gt;s1;
  s1.insert(10);
  s1.insert(40);
  s1.insert(20);
  s1.insert(50);
  s1.insert(30);
  printSet(s1);
  //指定排序规则为从大到小 在插数据之前
  set&lt;int,MyCompare&gt;s2;
  s2.insert(10);
  s2.insert(40);
  s2.insert(20);
  s2.insert(50);
  s2.insert(30);
  for (set&lt;int, MyCompare&gt;::iterator it = s2.begin();it != s2.end();it++)
  {
    cout &lt;&lt; *it &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
//自定义数据类型
class Person
{
public:
  Person(string name, int age)
  {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
  }
  string m_Name;
  int m_Age;
};
class comparePerson
{
public:
  bool operator()(const Person&amp; p1, const Person&amp; p2) const
  {
    //按照年龄降序
    return p1.m_Age &gt; p2.m_Age;
  }
};
void test08()
{
  //自定义数据类型都会指定排序规则
  set&lt;Person,comparePerson&gt;s;
  Person p1("刘备", 24);
  Person p2("关羽", 28);
  Person p3("张飞", 25);
  Person p4("赵云", 21);
  s.insert(p1);
  s.insert(p2);
  s.insert(p3);
  s.insert(p4);
  for (set&lt;Person,comparePerson&gt;::iterator it = s.begin();it != s.end();it++)
  {
    cout &lt;&lt; "姓名:" &lt;&lt; it-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; it-&gt;m_Age &lt;&lt; endl;;
  }
}

int main()
{
  test08();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-9-map-multimap容器"><a href="#3-2-9-map-multimap容器" class="headerlink" title="3.2.9 map/multimap容器"></a>3.2.9 map/multimap容器</h4><ul><li>map中所有元素都是pair</li><li>pair中第一个元素位key(键值),起索引作用,第二个元素为value(实值)</li><li>所有元素都会根据元素的键值自动排序</li></ul><p>本质: map/multimap属于<code>关联式容器</code>,底层结构是用二叉树实现</p><p>优点:</p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap区别:</p><ul><li>map不允许容器中有重复的key值元素</li><li>multimap允许容器中有重复的key值元素</li></ul><h5 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h5><p>功能:对map容器进行构造和赋值操作</p><p>构造:</p><ul><li><code>map&lt;T1,T2&gt; mp;</code> //默认构造函数</li><li><code>map(const map &amp;mp);</code> //拷贝构造函数</li></ul><p>赋值:</p><ul><li><code>map&amp; operator=(const map &amp;map);</code> //重载等号操作符</li></ul><h5 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h5><p>功能:统计map容器大小以及交换map容器</p><p>函数原型:</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换俩个集合容器</li></ul><h5 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h5><p>功能:map容器进行插入和删除数据</p><p>函数原型:</p><ul><li><code>insert(elem);</code> //在容器中插入元素</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素,返回下一个元素的迭代器</li><li><code>erase(beg,end);</code> //删除区间[beg,end)的所有元素,返回下一个元素的迭代器</li><li><code>erase(key);</code> //删除容器中值为key的元素</li></ul><h5 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h5><p>功能:对map容器进行查找数据以及统计数据</p><p>函数原型:</p><ul><li><code>find(key);</code> //查找key是否存在,若存在返回该键的元素的迭代器;若不存在返回map.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><h5 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h5><p>默认按照key值进行从小到大排序</p><p>利用仿函数</p><p>代码:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;map&gt;
#include&lt;string&gt;

void printMap(map&lt;int, int&gt;&amp; m)
{
  for (map&lt;int, int&gt;::iterator it = m.begin();it != m.end();it++)
  {
    cout &lt;&lt; "key = " &lt;&lt; (*it).first &lt;&lt; " value = " &lt;&lt; it-&gt;second &lt;&lt; endl;
  }
  cout &lt;&lt; endl;
}
//map构造和赋值
void test01()
{
  //创建map容器
  map&lt;int, int&gt;m;
  m.insert(pair&lt;int, int&gt;(1, 10));
  m.insert(pair&lt;int, int&gt;(2, 20));
  m.insert(pair&lt;int, int&gt;(3, 30));
  m.insert(pair&lt;int, int&gt;(4, 40));
  printMap(m);
  //拷贝构造
  map&lt;int, int&gt;m2(m);
  printMap(m2);
  map&lt;int, int&gt;m3;
  m3 = m2;
  printMap(m3);
}
//map大小和交换
void test02()
{
  //创建map容器
  map&lt;int, int&gt;m;
  m.insert(pair&lt;int, int&gt;(1, 10));
  m.insert(pair&lt;int, int&gt;(2, 20));
  m.insert(pair&lt;int, int&gt;(3, 30));
  m.insert(pair&lt;int, int&gt;(4, 40));
  if (m.empty())
  {
    cout &lt;&lt; "m为空" &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "m不为空" &lt;&lt; endl;
    cout &lt;&lt; "m的大小为:" &lt;&lt; m.size() &lt;&lt; endl;
  }
  map&lt;int, int&gt;m2;
  m2.insert(pair&lt;int, int&gt;(1, 230));
  m2.insert(pair&lt;int, int&gt;(2, 130));
  m2.insert(pair&lt;int, int&gt;(3, 340));
  m2.insert(pair&lt;int, int&gt;(4, 240));
  cout &lt;&lt; "交换前:" &lt;&lt; endl;
  printMap(m);
  printMap(m2);
  cout &lt;&lt; "交换后:" &lt;&lt; endl;
  m.swap(m2);
  printMap(m);
  printMap(m2);
}
//map插入和删除
void test03()
{
  //创建map容器
  map&lt;int, int&gt;m;
  //插入4种方式
  m.insert(pair&lt;int, int&gt;(1, 10));
  m.insert(make_pair(2, 20));
  m.insert(map&lt;int, int&gt;::value_type(3, 30));
  //[]不建议去插入 可以使用[]通过key访问value
  m[4] = 40;
  printMap(m);
  //删除
  m.erase(m.begin());
  printMap(m);
  m.erase(3);//按照key删除
  printMap(m);
  //清空
  //m.erase(m.begin(), m.end());
  m.clear();
  printMap(m);
}
//map查找和统计
void test04()
{
  map&lt;int, int&gt;m;
  m.insert(pair&lt;int, int&gt;(1, 10));
  m.insert(pair&lt;int, int&gt;(2, 20));
  m.insert(pair&lt;int, int&gt;(3, 30));
  map&lt;int, int&gt;::iterator pos = m.find(3);
  if (pos != m.end())
  {
    cout &lt;&lt; "找到元素: key = " &lt;&lt; (*pos).first &lt;&lt; " value = " &lt;&lt; pos-&gt;second &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; "未找到元素" &lt;&lt; endl;
  }
  //统计 结果只能为0或1 因为map不允许插入重复key
  //multimap的统计结果可能大于1
  int num = m.count(3);
  cout &lt;&lt; "num = " &lt;&lt; num &lt;&lt; endl;
}
//map容器排序
class MyCompare
{
public:
  bool operator()(int v1,int v2) const
  {
    //降序
    return v1 &gt; v2;
  }
};
void test05()
{
  //在插入数据前修改排序规则
  map&lt;int, int,MyCompare&gt;m;
  m.insert(pair&lt;int, int&gt;(1, 10));
  m.insert(pair&lt;int, int&gt;(2, 20));
  m.insert(pair&lt;int, int&gt;(3, 30));  
  m.insert(pair&lt;int, int&gt;(4, 40));  
  m.insert(pair&lt;int, int&gt;(5, 50));  
  for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin();it != m.end();it++)
  {
    cout &lt;&lt; "key = " &lt;&lt; it-&gt;first &lt;&lt; " value = " &lt;&lt; it-&gt;second &lt;&lt; endl;
  }
  cout &lt;&lt; endl;
}
int main()
{
  test05();
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例: 员工分组"></a>案例: 员工分组</h5><p>案例描述:</p><ul><li>公司今天招聘了10个员工(ABCDEFGHIJ),10名员工进入公司之后,需要指派员工去哪个部门工作</li><li>员工信息有:姓名、工资组成;部门分为:策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入 key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><p>步骤:<br>1.创建10名员工,放到vector中<br>2.遍历vector容器,取出每个员工,进行随机分组<br>3.分组后将员工部门编号作为key,具体员工为value,放入到multimap容器中<br>4.分部门显示员工信息</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#define CEHUA 0
#define MEISHU 1
#define YANFA 2
class Worker
{
public:
  string m_Name;
  int m_Salary;
};
void createWorker(vector&lt;Worker&gt;&amp;v)
{
  string nameSeed = "ABCDEFGHIJ";
  for (int i = 0;i &lt; 10;i++)
  {
    Worker worker;
    worker.m_Name = "员工";
    worker.m_Name += nameSeed[i];
    worker.m_Salary = rand() % 10000 + 10000;//10000~19999
    //将员工放入容器中
    v.push_back(worker);
  }
}
void setGroup(vector&lt;Worker&gt;&amp; v, multimap&lt;int, Worker&gt;&amp; m)
{
  for (vector&lt;Worker&gt;::iterator it = v.begin();it != v.end();it++)
  {
    //产生随机编号
    int deptId = rand() % 3;
    m.insert(make_pair(deptId, *it));
  }
}
void showWorkerByGroup(multimap&lt;int, Worker&gt;&amp; m)
{
  cout &lt;&lt; "策划部门:" &lt;&lt; endl;
  multimap&lt;int, Worker&gt;::iterator pos = m.find(CEHUA);
  int count = m.count(CEHUA);//统计具体人数
  int index = 0;
  for (;pos != m.end() &amp;&amp; index &lt; count;pos++, index++)
  {
    cout &lt;&lt; "姓名: " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资: " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
  }
  cout &lt;&lt; "美术部门:" &lt;&lt; endl;
  pos = m.find(MEISHU);
  count = m.count(MEISHU);//统计具体人数
  index = 0;
  for (;pos != m.end() &amp;&amp; index &lt; count;pos++, index++)
  {
    cout &lt;&lt; "姓名: " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资: " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
  }
  cout &lt;&lt; "研发部门:" &lt;&lt; endl;
  pos = m.find(YANFA);
  count = m.count(YANFA);//统计具体人数
  index = 0;
  for (;pos != m.end() &amp;&amp; index &lt; count;pos++, index++)
  {
    cout &lt;&lt; "姓名: " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资: " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
  }
}
int main()
{
  srand((unsigned int)time(NULL));
  //1.创建员工
  vector&lt;Worker&gt;vWorker;
  createWorker(vWorker);
  //2.员工分组
  multimap&lt;int, Worker&gt;mWorker;
  setGroup(vWorker,mWorker);
  //3.分组显示员工
  showWorkerByGroup(mWorker);
  system("pause");
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-STL函数对象"><a href="#3-3-STL函数对象" class="headerlink" title="3.3 STL函数对象"></a>3.3 STL函数对象</h3><p>概念:</p><ul><li>重载函数调用操作符的类,其对象常称为函数对象</li><li>函数对象使用<code>重载的()</code>时,行为类似函数调用,也叫仿函数</li></ul><p>本质:函数对象是一个类,不是一个函数</p><p>使用特点:</p><ul><li>函数对象在使用时,可以像普通函数那样调用,可以有参数和返回值</li><li>函数对象超出普通函数概念,函数对象可以有自己的状态<ul><li>可以使用成员属性记录状态</li></ul></li><li>函数对象可以作为参数传递</li></ul><h4 id="3-3-1-谓词"><a href="#3-3-1-谓词" class="headerlink" title="3.3.1 谓词"></a>3.3.1 谓词</h4><p>概念:</p><ul><li>返回<code>bool类型</code>的仿函数称为谓词</li><li>如果operator()接收一个参数,那么就叫一元谓词</li><li>如果operator()接收二个参数,那么就叫二元谓词</li></ul><h4 id="3-3-2-内建函数对象"><a href="#3-3-2-内建函数对象" class="headerlink" title="3.3.2 内建函数对象"></a>3.3.2 内建函数对象</h4><p>概念:STL内建了一些函数对象</p><p>分类:</p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p>用法:</p><ul><li>这些仿函数所产生的对象用法和一般函数完全相同</li><li>使用内建函数对象,需要引入头文件<code>#include&lt;functional&gt;</code></li></ul><h5 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h5><p>功能描述:</p><ul><li>实现四则运算</li><li>其中negate是一元运算,其他都是二元运算</li></ul><p>仿函数原型:</p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//一元运算 negate
negate&lt;int&gt;n;
cout &lt;&lt; n(50) &lt;&lt; endl;
//二元运算 plus
plus&lt;int&gt;p;
cout &lt;&lt; p(10, 20) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h5><p>功能描述:</p><ul><li>实现关系比较</li></ul><p>仿函数原型:</p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li></ul><h5 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h5><p>功能描述:</p><ul><li>实现逻辑运算</li></ul><p>仿函数原型:</p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li></ul><h3 id="3-4-STL常用算法"><a href="#3-4-STL常用算法" class="headerlink" title="3.4 STL常用算法"></a>3.4 STL常用算法</h3><p>概述:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成</li><li><code>&lt;algorithm&gt;</code> 是所有STL头文件中最大的一个,范围涉及到比较、交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;functional&gt;</code> 体积很小,只包括几个在序列上面进行的简单数学运算的模板函数</li><li><code>&lt;numeric&gt;</code> 定义了一些模板类,用以声明函数对象</li></ul><h4 id="3-4-1-常用遍历算法"><a href="#3-4-1-常用遍历算法" class="headerlink" title="3.4.1 常用遍历算法"></a>3.4.1 常用遍历算法</h4><ul><li><code>for_each</code> //遍历容器</li></ul><p>函数原型:</p><ul><li><p><code>for_each(iterator beg,iterator end,_func);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>_func</code>函数或者函数对象</p></li><li><p><code>transform</code> //搬运容器到另一个容器</p><p>函数原型:</p><ul><li><code>transform(iterator beg1,iterator end1,iterator beg2,_func);</code><br>//<code>beg1</code>源容器开始迭代器<br>//<code>end1</code>源容器结束迭代器<br>//<code>beg2</code>目标容器开始迭代器<br>//<code>_func</code>函数或者函数对象</li></ul></li></ul><p>目标容器需要提前开辟空间</p><h4 id="3-4-2-常用查找算法"><a href="#3-4-2-常用查找算法" class="headerlink" title="3.4.2 常用查找算法"></a>3.4.2 常用查找算法</h4><ul><li><p><code>find</code> //查找元素</p><p>函数原型:</p><ul><li><code>find(iterator beg,iterator end,value);</code><br>//按值查找元素,找到返回指定位置迭代器,找不到返回结束迭代器位置<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>value</code>查找的元素</li></ul></li><li><p><code>find_if</code> //按条件查找元素</p><p>函数原型:</p><ul><li><code>find_if(iterator beg,iterator end,_Pred);</code><br>//按值查找元素,找到返回指定位置迭代器,找不到返回结束迭代器位置<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>_Pred</code>函数或者谓词(返回bool类型的仿函数)</li></ul></li><li><p><code>adjacent_find</code> //查找相邻重复元素</p><p>函数原型:</p><ul><li><code>adjacent_find(iterator beg,iterator end);</code><br>//查找相邻重复元素,返回相邻元素的第一个位置的迭代器<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器</li></ul></li><li><p><code>binary_search</code> //二分查找法</p><p>函数原型:</p><ul><li><code>bool binary_search(iterator beg,iterator end,value);</code><br>//查找指定的元素 找到返回true 否则返回false<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>value</code>查找的元素</li></ul></li><li><p><code>count</code> //统计元素个数</p><p>函数原型:</p><ul><li><code>count(iterator beg,iterator end,value);</code><br>//统计元素出现次数<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>value</code>统计的元素</li></ul></li><li><p><code>count_if</code> //按条件统计元素个数</p><p>函数原型:</p><ul><li><code>count_if(iterator beg,iterator end,_Pred);</code><br>//按条件统计元素出现次数<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>_Pred</code>谓词</li></ul></li></ul><h4 id="3-4-3-常用排序算法"><a href="#3-4-3-常用排序算法" class="headerlink" title="3.4.3 常用排序算法"></a>3.4.3 常用排序算法</h4><ul><li><p><code>sort</code> //对容器内元素进行排序</p><p>函数原型:</p><ul><li><code>sort(iterator beg,iterator end,_Pred);</code><br>//对容器内元素进行排序<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>_Pred</code>谓词</li></ul></li><li><p><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</p><p>函数原型:</p><ul><li><code>random_shuffle(iterator beg,iterator end);</code><br>//指定范围内的元素随机调整次序<br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器</li></ul><p>可以添加随机数种子: <code>srand((unsigned int)time(NULL))</code></p></li><li><p><code>merge</code> //容器元素合并,并存储到另一个容器中</p><p>函数原型:</p><ul><li><code>merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code><br>//注意:俩个容器必须是有序且一致(同升同降)的<br>//<code>beg1</code>容器1开始迭代器<br>//<code>end1</code>容器1结束迭代器<br>//<code>beg2</code>容器2开始迭代器<br>//<code>end2</code>容器2结束迭代器<br>//目标容器需要提前分配空间<br>//<code>dest</code>目标容器开始迭代器</li></ul></li><li><p><code>reverse</code> //反转指定范围的元素</p><p>函数原型:</p><ul><li><code>reverse(iterator beg,iterator end);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器</li></ul></li></ul><h4 id="3-4-4-常用拷贝和构造算法"><a href="#3-4-4-常用拷贝和构造算法" class="headerlink" title="3.4.4 常用拷贝和构造算法"></a>3.4.4 常用拷贝和构造算法</h4><ul><li><p><code>copy</code> //容器内指定范围的元素拷贝到另一个容器中</p><p>函数原型:</p><ul><li><code>copy(iterator beg,iterator end,iterator dest);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//目标容器需要提前分配空间<br>//<code>dest</code>目标容器起始迭代器</li></ul></li><li><p><code>replace</code> //将容器内指定范围的旧元素修改为新元素</p><p>函数原型:</p><ul><li><code>replace(iterator beg,iterator end,oldvalue,newvalue);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>oldvalue</code>旧元素<br>//<code>newvalue</code>新元素</li></ul></li><li><p><code>replace_if</code> //容器内指定范围满足条件的元素替换为新元素</p><p>函数原型:</p><ul><li><code>replace_if(iterator beg,iterator end,_pred,newvalue);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>_pred</code>谓词<br>//<code>newvalue</code>新元素</li></ul></li><li><p><code>swap</code> //互换俩个容器的元素</p><p>函数原型:</p><ul><li><code>swap(container c1,container c2);</code><br>//注意c1、c2必须为同一种容器<br>//<code>c1</code>容器1<br>//<code>c2</code>容器2</li></ul></li></ul><h4 id="3-4-5-常用算术生成算法"><a href="#3-4-5-常用算术生成算法" class="headerlink" title="3.4.5 常用算术生成算法"></a>3.4.5 常用算术生成算法</h4><p>包含头文件<code>#include&lt;numeric&gt;</code></p><ul><li><p><code>accumulate</code> //计算容器元素累计总和</p><p>函数原型:</p><ul><li><code>accumulate(iterator beg,iterator end,value);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>value</code>起始值</li></ul></li><li><p><code>fill</code> //向容器中添加元素</p><p>函数原型:</p><ul><li><code>fill(iterator beg,iterator end,value);</code><br>//<code>beg</code>开始迭代器<br>//<code>end</code>结束迭代器<br>//<code>value</code>填充的值</li></ul></li></ul><h4 id="3-4-6-常用集合算法"><a href="#3-4-6-常用集合算法" class="headerlink" title="3.4.6 常用集合算法"></a>3.4.6 常用集合算法</h4><ul><li><p><code>set_intersection</code> //求俩个容器的交集</p><p>函数原型:</p><ul><li><code>set_intersection(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code><br>//注意:俩个容器必须是有序序列且一致(同升同降)的<br>//<code>beg1</code>容器1开始迭代器<br>//<code>end1</code>容器1结束迭代器<br>//<code>beg2</code>容器2开始迭代器<br>//<code>end2</code>容器2结束迭代器<br>//目标容器需要提前分配空间 resize<br>//最特殊情况 大容器包含小容器 开辟空间 取小容器size即可: <code>resize(min(v1.size(),v2.size()));</code><br>//遍历时结束迭代器使用返回回来的迭代器<code>dest</code><br>//<code>dest</code>目标容器开始迭代器</li></ul></li><li><p><code>set_union</code> //求俩个容器的并集</p><p>函数原型:</p><ul><li><code>set_union(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code><br>//注意:俩个容器必须是有序序列且一致(同升同降)的<br>//<code>beg1</code>容器1开始迭代器<br>//<code>end1</code>容器1结束迭代器<br>//<code>beg2</code>容器2开始迭代器<br>//<code>end2</code>容器2结束迭代器<br>//目标容器需要提前分配空间 resize<br>//最特殊情况 俩容器没有交集 开辟空间 取俩容器size之和即可: <code>resize(v1.size()+v2.size());</code><br>//遍历时结束迭代器使用返回回来的迭代器<code>dest</code><br>//<code>dest</code>目标容器开始迭代器</li></ul></li><li><p><code>set_difference</code> //求俩个容器的差集</p><p>函数原型:</p><ul><li><code>set_union(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code><br>//注意:俩个容器必须是有序序列且一致(同升同降)的<br>//<code>beg1</code>容器1开始迭代器<br>//<code>end1</code>容器1结束迭代器<br>//<code>beg2</code>容器2开始迭代器<br>//<code>end2</code>容器2结束迭代器<br>//目标容器需要提前分配空间 resize<br>//最特殊情况 俩容器没有交集 开辟空间 取大容器size即可: <code>resize(max(v1.size(),v2.size());</code><br>//遍历时结束迭代器使用返回回来的迭代器<code>dest</code><br>//<code>dest</code>目标容器开始迭代器</li></ul></li></ul><h5 id="案例-演讲比赛流程管理系统"><a href="#案例-演讲比赛流程管理系统" class="headerlink" title="案例: 演讲比赛流程管理系统"></a>案例: 演讲比赛流程管理系统</h5><p>比赛规则:</p><ul><li>学校举行一场演讲比赛,共有<code>12人</code>参加。<code>比赛共俩轮</code>,第一轮为淘汰赛,第二轮为决赛</li><li>每名选手都有对应的<code>编号</code>:如10001 ~ 10012</li><li>比赛方式:<code>分组比赛每组6人</code></li><li>每一轮分为俩个小组,整体按照选手编号进行<code>抽签</code>后顺序演讲</li><li>十个评委分别给每个选手打分,去除最高分和最低分,求的平均分为本轮选手的成绩</li><li>当小组演讲完后,淘汰组内排名最后的三个选手,<code>前三名晋级</code>,进入下一轮比赛</li><li>第二轮为决赛,<code>前三名胜出</code></li><li>每轮比赛过后需要<code>显示晋级选手的信息</code></li></ul><p>程序功能:</p><ul><li>开始演讲比赛:完成整届比赛的流程,每个比赛阶段需要给用户一个提示,用户按任意键后继续下一个阶段</li><li>查看往届记录:查看之前比赛前三名结果,每次比赛都会记录到文件中,文件用.csv后缀名保存</li><li>清空比赛记录:将文件中数据清空</li><li>退出比赛程序:可以退出当前程序</li></ul><p><a target="_blank" rel="noopener" href="https://github.com/liaojie1314/SpeechSystem">代码</a></p><h5 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="机房预约系统"></a>机房预约系统</h5><p>身份简介</p><ul><li>学生代表:申请使用机房</li><li>教师:审核学生的预约申请</li><li>管理员:给学生老师创建账号</li></ul><p>机房简介</p><ul><li>1号机房:最大容量20人</li><li>2号机房:最大容量50人</li><li>3号机房:最大容量100人</li></ul><p>申请简介</p><ul><li>申请的订单每周由管理员清空</li><li>学生可以预约未来一周内的机房使用,预约的日期为周一至周五,预约时需要选择时间段(上午、下午)</li><li>教师来审核预约,依据实际情况审核预约通过或者不通过</li></ul><p>系统具体要求</p><ul><li>首先进入登录界面,可选身份有:<ul><li>学生代表</li><li>老师</li><li>管理员</li><li>退出</li></ul></li><li>每个身份都需要进型验证后,进入子菜单<ul><li>学生需要输入:学号、姓名、登录密码</li><li>老师需要输入:职工号、姓名、登录密码</li><li>学生需要输入:管理员姓名、登录密码</li></ul></li><li>学生具体功能<ul><li>申请预约 — 预约机房</li><li>查看自身的预约 — 查看自身的预约状态</li><li>查看所有预约 — 查看全部预约信息以及预约状态</li><li>取消预约 — 取消自身的预约,预约成功或审核中的预约都可以取消</li><li>注销登录 — 退出登录</li></ul></li><li>教师具体功能<ul><li>查看所有预约 — 查看全部预约信息以及预约状态</li><li>审核预约 — 对学生的预约进行审核</li><li>注销登录 — 退出登录</li></ul></li><li>管理员具体功能<ul><li>添加账号 — 添加学生或教师账号,需要检测学生编号和教师职工编号是否重复</li><li>查看账号 — 可以选择查看学生或老师的全部信息</li><li>查看机房 — 查看所有机房的消息</li><li>清空预约 — 清空所有预约记录</li><li>注销登录 — 退出登录</li></ul></li></ul><p><a target="_blank" rel="noopener" href="https://github.com/liaojie1314/ComputerRoomReservationSystem/tree/master">代码</a></p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/liaojie.github.io/about" rel="external nofollow noreferrer">liaojie</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://liaojie.github.io.git/liaojie.github.io/2022/01/15/c-0/">https://liaojie.github.io.git/liaojie.github.io/2022/01/15/c-0/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/liaojie.github.io/about" target="_blank">liaojie</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/liaojie.github.io/tags/C/"><span class="chip bg-color">C++</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/liaojie.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/liaojie.github.io/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="/liaojie.github.io/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/liaojie.github.io/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="/liaojie.github.io/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: 'eedac85cd6c0645124b2',
        clientSecret: '0cbb1e584813da4a45008d2c6048fc84846ef93f',
        repo: 'liaojie1314-gitalk',
        owner: 'liaojie1314',
        admin: "liaojie1314",
        id: '2022-01-15T16-19-05',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');</script><div class="livere-card card" data-aos="fade-up"><div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NDUzMy8zMTAwNA=="><script type="text/javascript">(function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript。</noscript></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/liaojie.github.io/2022/01/15/c-1/"><div class="card-image"><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/medias/featureimages/0.jpg" class="responsive-img" alt="C#"> <span class="card-title">C#</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-01-15 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/liaojie.github.io/categories/C/" class="post-category">C#</a></span></div></div><div class="card-action article-tags"><a href="/liaojie.github.io/tags/C/"><span class="chip bg-color">C#</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/liaojie.github.io/2021/12/29/jupyter-notebook-an-zhuang/"><div class="card-image"><img src="/liaojie.github.io/medias/loading.gif" data-original="/liaojie.github.io/medias/featureimages/6.jpg" class="responsive-img" alt="jupyter notebook安装"> <span class="card-title">jupyter notebook安装</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-12-29 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/liaojie.github.io/categories/%E5%AE%89%E8%A3%85/" class="post-category">安装</a></span></div></div><div class="card-action article-tags"><a href="/liaojie.github.io/tags/jupyter-notebook/"><span class="chip bg-color">jupyter-notebook</span></a></div></div></div></div></article></div><script type="text/javascript" src="/liaojie.github.io/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/liaojie.github.io/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/liaojie.github.io/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/liaojie.github.io/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/liaojie.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2021-2022</span> <span id="year">2021</span> <a href="/liaojie.github.io/about" target="_blank">lj</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">287.9k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><span id="sitetime">载入运行时间...</span><script>function siteTime(){var e=36e5,t=24*e,n=new Date,o="2021",r=n.getFullYear(),a=n.getMonth()+1,i=n.getDate(),l=n.getHours(),m=n.getMinutes(),M=n.getSeconds(),g=Date.UTC(o,"10","18","0","0","0"),d=Date.UTC(r,a,i,l,m,M)-g,s=Math.floor(d/31536e6),u=Math.floor(d/t-365*s),T=Math.floor((d-(365*s+u)*t)/e),c=Math.floor((d-(365*s+u)*t-T*e)/6e4),f=Math.floor((d-(365*s+u)*t-T*e-6e4*c)/1e3);o==r?(document.getElementById("year").innerHTML=r,document.getElementById("sitetime").innerHTML="本站已安全运行 "+u+" 天 "+T+" 小时 "+c+" 分钟 "+f+" 秒"):(document.getElementById("year").innerHTML=o+" - "+r,document.getElementById("sitetime").innerHTML="本站已安全运行 "+s+" 年 "+u+" 天 "+T+" 小时 "+c+" 分钟 "+f+" 秒")}setInterval(siteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/liaojie1314" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:1517438366@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1517438366" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1517438366" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">$(function(){!function(t,i,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),n=document.getElementById(i),r=document.getElementById(s);n.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,i,s,l=!0,a=t.title.trim().toLowerCase(),c=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),u=0===(u=t.url).indexOf("/")?t.url:"/"+u,o=-1,h=-1;""!==a&&""!==c&&m.forEach(function(t,e){n=a.indexOf(t),o=c.indexOf(t),n<0&&o<0?l=!1:(o<0&&(o=0),0===e&&(h=o))}),l&&(f+="<li><a href='"+u+"' class='search-result-title'>"+a+"</a>",e=t.content.trim().replace(/<[^>]+>/g,""),0<=h&&(i=h+80,(r=h-20)<0&&(r=0),0===r&&(i=100),i>e.length&&(i=e.length),s=e.substr(r,i),m.forEach(function(t){var e=new RegExp(t,"gi");s=s.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+s+"...</p>"),f+="</li>")}),f+="</ul>",r.innerHTML=f)})}})}("/liaojie.github.io/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/liaojie.github.io/libs/materialize/materialize.min.js"></script><script src="/liaojie.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="/liaojie.github.io/libs/aos/aos.js"></script><script src="/liaojie.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="/liaojie.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/liaojie.github.io/js/matery.js"></script><script type="text/javascript" color="122 103 238" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="ヽ(●-`Д´-)ノ你要玩捉迷藏嘛",clearTimeout(st)):(document.title="(Ő∀Ő3)ノ好哦！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/liaojie.github.io/libs/others/clicklove.js" async></script><script async src="/liaojie.github.io/libs/others/busuanzi.pure.mini.js"></script><script src="/liaojie.github.io/libs/instantpage/instantpage.js" type="module"></script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>